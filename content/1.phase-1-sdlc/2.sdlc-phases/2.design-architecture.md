---
title: "Design & Architecture"
description: "Learn how software design transforms requirements into technical blueprints that guide development."
estimatedMinutes: 15
difficulty: beginner
learningObjectives:
  - "Understand the difference between high-level and low-level design"
  - "Identify key components of software architecture"
  - "Recognize common architectural patterns used in modern systems"
  - "Apply basic design principles to create maintainable software"
quiz:
  passingScore: 70
  questions:
    - question: "What is the main purpose of the design phase?"
      type: single
      options:
        - "To transform requirements into technical plans for building"
        - "To gather what users want from the software"
        - "To test the completed application"
        - "To deploy the software to production"
      correctAnswer: "To transform requirements into technical plans for building"
      explanation: "The design phase takes requirements (what to build) and creates technical plans (how to build it). These plans guide developers during implementation."

    - question: "Select all components typically defined during high-level design."
      type: multiple
      options:
        - "Major system components and their relationships"
        - "Technology stack choices"
        - "Individual function parameters"
        - "Database table structures"
      correctAnswers:
        - "Major system components and their relationships"
        - "Technology stack choices"
      explanation: "High-level design covers the big picture - system components, technology choices, and how parts connect. Function parameters and database details belong to low-level design."

    - question: "A monolithic architecture places all code in a single deployable unit."
      type: true-false
      correctAnswer: true
      explanation: "This is true. In a monolith, all features live in one codebase and deploy together. This contrasts with microservices, where features are separate services that deploy independently."

    - question: "Which design principle suggests that code should be easy to extend without changing existing code?"
      type: single
      options:
        - "Open/Closed Principle"
        - "Single Responsibility Principle"
        - "Don't Repeat Yourself"
        - "Keep It Simple"
      correctAnswer: "Open/Closed Principle"
      explanation: "The Open/Closed Principle states that software should be open for extension but closed for modification. You add new features by adding new code, not changing existing code."

    - question: "Microservices architecture is always the best choice for any project."
      type: true-false
      correctAnswer: false
      explanation: "This is false. Microservices add complexity and operational overhead. For small teams or simple applications, a monolith is often simpler and more appropriate. The right architecture depends on your specific needs."
---

# Design & Architecture

Design and architecture transform requirements into technical plans. While requirements tell you **what** to build, design tells you **how** to build it. This phase creates the blueprint that developers follow during coding.

Good design decisions make software easier to build, test, and maintain. Poor design decisions create problems that get worse over time.

## What is Software Design?

Software design is the process of planning how software will work internally. It covers everything from big decisions (which technology to use) to small details (how data flows between functions).

::illustration-linear-flow
---
steps:
  - label: Requirements
    sublabel: What to build
    icon: "\U0001F4CB"
    color: violet
  - label: High-Level
    sublabel: System structure
    icon: "\U0001F3D7"
    color: blue
  - label: Low-Level
    sublabel: Component details
    icon: "\U0001F9E9"
    color: cyan
  - label: Ready
    sublabel: Start coding
    icon: "\U0001F680"
    color: emerald
size: full
---
::

## High-Level Design

High-level design focuses on the big picture. It answers questions like:

- What are the major parts of the system?
- How do these parts communicate?
- What technologies will we use?
- Where will data be stored?

### System Architecture

The architecture defines the overall structure. It shows how major components fit together and interact.

::illustration-checklist
---
title: High-Level Design Decisions
items:
  - text: Monolith vs microservices
    icon: "\U0001F3D7"
  - text: Cloud provider selection
    icon: "\U00002601"
  - text: Database type and location
    icon: "\U0001F4BE"
  - text: Communication patterns (REST, events)
    icon: "\U0001F4E1"
  - text: Security boundaries
    icon: "\U0001F512"
note: These decisions are hard to change later
color: violet
size: 2xl
---
::

### Technology Stack

The tech stack includes all tools and technologies needed:

- **Frontend**: React, Vue, Angular
- **Backend**: Node.js, Python, Java
- **Database**: PostgreSQL, MongoDB, Redis
- **Infrastructure**: AWS, Azure, Kubernetes

## Low-Level Design

Low-level design zooms into component details. It answers questions like:

- What classes and functions do we need?
- What data structures will store information?
- What is the exact database schema?
- How will specific features work step by step?

### Database Design

Database design defines tables, columns, relationships, and indexes. A well-designed database makes the application fast and reliable.

### API Design

API design specifies how components talk to each other:

- Endpoint URLs and methods
- Request and response formats
- Error handling approaches
- Authentication methods

## Common Architectural Patterns

Different projects need different architectures. Here are patterns you will encounter often.

### Monolithic Architecture

All code lives in one application that deploys as a single unit.

**Pros:** Simple to develop, test, and deploy initially.
**Cons:** Harder to scale and maintain as the application grows.

### Microservices Architecture

The application splits into small, independent services. Each service handles one business function.

**Pros:** Scale services independently, use different technologies, teams work separately.
**Cons:** More complex to operate, network communication adds overhead.

### Layered Architecture

Code organizes into horizontal layers:

::illustration-pyramid
---
layers:
  - label: Presentation
    description: UI and user interaction
    icon: "\U0001F5A5"
    color: violet
  - label: Business Logic
    description: Rules and processes
    icon: "\U00002699"
    color: blue
  - label: Data Access
    description: Database operations
    icon: "\U0001F4BE"
    color: emerald
footnote: Each layer only talks to the layer below it
size: xl
---
::

## Design Principles

Good design follows proven principles that make code easier to work with.

### Keep It Simple (KISS)

Choose the simplest solution that works. Complex designs are harder to understand, test, and maintain.

### Don't Repeat Yourself (DRY)

Avoid duplicating code. When you need the same logic in multiple places, put it in one place and reuse it.

### Single Responsibility

Each component should do one thing well. A user service handles users. An order service handles orders. Do not mix unrelated concerns.

### Separation of Concerns

Keep different types of logic separate. User interface code should not contain business logic. Business logic should not contain database queries.

## Design Documents

Design decisions should be documented so everyone understands the plan.

Common documents include:
- **Architecture diagrams** - Visual representation of system structure
- **API specifications** - Detailed endpoint documentation
- **Database schemas** - Table and relationship definitions
- **Sequence diagrams** - Step-by-step flow of operations

## Design in DevOps

DevOps influences design decisions:

- **Infrastructure as Code** means infrastructure is designed alongside application code
- **CI/CD requirements** affect how applications are built and deployed
- **Observability needs** require logging, metrics, and tracing built into the design
- **Container deployment** shapes how applications are packaged and configured

## Key Takeaways

- Design transforms requirements into technical plans for development
- High-level design covers system structure and technology choices
- Low-level design details components, databases, and APIs
- Architectural patterns like monoliths and microservices suit different needs
- Design principles like KISS, DRY, and single responsibility guide good decisions

In the next lesson, you will learn about Development and Coding, where designs become working software.
