---
title: "Design & Architecture"
description: "Learn how to transform requirements into a technical plan - making decisions about structure, technology, and patterns before coding begins."
estimatedMinutes: 14
difficulty: beginner
learningObjectives:
  - "Understand the difference between software design and architecture"
  - "Identify key architectural patterns used in modern systems"
  - "Explain the purpose of design documents and diagrams"
  - "Recognize how design decisions affect DevOps practices"
quiz:
  passingScore: 70
  questions:
    - question: "What is the main difference between software design and architecture?"
      type: single
      options:
        - "Architecture covers high-level structure; design covers detailed implementation"
        - "Design is done first; architecture comes after coding"
        - "Architecture is only for large projects; design is for small ones"
        - "There is no difference - they mean the same thing"
      correctAnswer: "Architecture covers high-level structure; design covers detailed implementation"
      explanation: "Architecture defines the big picture: major components and how they connect. Design fills in the details: classes, functions, and algorithms within those components."

    - question: "Which architectural pattern separates an application into Presentation, Business Logic, and Data Access layers?"
      type: single
      options:
        - "Microservices architecture"
        - "Three-tier architecture"
        - "Event-driven architecture"
        - "Monolithic architecture"
      correctAnswer: "Three-tier architecture"
      explanation: "Three-tier (or N-tier) architecture divides the application into presentation (UI), business logic, and data access layers. Each layer has a specific responsibility."

    - question: "Select all benefits of good software architecture."
      type: multiple
      options:
        - "Easier to maintain and update the system"
        - "Faster development with no planning needed"
        - "Better scalability as users grow"
        - "Clearer communication between team members"
      correctAnswers:
        - "Easier to maintain and update the system"
        - "Better scalability as users grow"
        - "Clearer communication between team members"
      explanation: "Good architecture makes systems easier to maintain, scale, and understand. However, it requires planning upfront - it does not eliminate the need for planning."

    - question: "Microservices architecture is always better than monolithic architecture."
      type: true-false
      correctAnswer: false
      explanation: "This is false. Microservices add complexity and are harder to manage. Monoliths are simpler and often better for small teams or early-stage projects. The right choice depends on your specific needs."

    - question: "What should a good architecture diagram show?"
      type: single
      options:
        - "Every line of code in the system"
        - "Major components and how they communicate"
        - "Only the database tables"
        - "The project timeline and budget"
      correctAnswer: "Major components and how they communicate"
      explanation: "Architecture diagrams show the big picture: main components, their responsibilities, and how they interact. They should not show implementation details like individual code lines."
---

# Design & Architecture

After gathering requirements, you know what to build. Now you need to figure out how to build it. The design and architecture phase is where you make critical decisions that shape the entire system.

Think of this phase as creating a blueprint. An architect does not start laying bricks immediately. They draw plans that show where walls go, how rooms connect, and what materials to use. Software architecture works the same way.

## What is Software Architecture?

Software architecture is the **high-level structure** of a system. It defines:

- What major components exist
- How components communicate with each other
- What technologies and platforms to use
- How the system will scale and evolve

Architecture decisions are expensive to change later. Choosing the wrong database or splitting services incorrectly can cost months of rework.

## What is Software Design?

Software design is more **detailed** than architecture. It focuses on:

- How individual components work internally
- Class structures and relationships
- Function signatures and algorithms
- Data structures and formats

::illustration-comparison-map
---
leftTitle: Architecture
rightTitle: Design
leftColor: violet
rightColor: blue
connections:
  - left: System-wide decisions
    right: Component-level decisions
    icon: "\U0001F3D7️"
  - left: Major components
    right: Classes and functions
    icon: "\U0001F9F1"
  - left: Technology choices
    right: Algorithm choices
    icon: "\U0001F527"
  - left: Hard to change later
    right: Easier to refactor
    icon: "\U0001F504"
footnote: Architecture comes first, then design fills in the details
size: full
---
::

## Common Architectural Patterns

### Monolithic Architecture

All code lives in one application. The entire system is deployed as a single unit.

**When to use:**
- Small teams (under 10 developers)
- Simple applications
- Early-stage startups
- When speed of initial development matters most

**Advantages:** Simple to develop, test, and deploy. One codebase to manage.

**Disadvantages:** Hard to scale specific parts. One bug can crash everything. Difficult to adopt new technologies.

### Three-Tier Architecture

The application is split into three layers:

::illustration-linear-flow
---
steps:
  - label: Presentation
    sublabel: User interface
    icon: "\U0001F5A5️"
    color: violet
  - label: Business Logic
    sublabel: Rules & processing
    icon: "\U00002699️"
    color: blue
  - label: Data Access
    sublabel: Database operations
    icon: "\U0001F4BE"
    color: emerald
size: full
---
::

**Presentation Layer:** What users see and interact with (web pages, mobile apps).

**Business Logic Layer:** The rules and processes that make the application work.

**Data Access Layer:** Code that reads and writes to databases.

### Microservices Architecture

The application is split into many small, independent services. Each service does one thing well and communicates with others via APIs.

**When to use:**
- Large teams that need to work independently
- Systems that need to scale different parts differently
- Organizations that want to use different technologies for different services

**Advantages:** Independent deployment. Teams can work without blocking each other. Easy to scale busy services.

**Disadvantages:** More complex to manage. Network calls add latency. Debugging across services is harder.

### Event-Driven Architecture

Components communicate by sending and receiving events. Instead of calling each other directly, services publish events that other services can react to.

**Example:** When a user places an order, the Order Service publishes an "OrderPlaced" event. The Inventory Service, Shipping Service, and Email Service all listen and react independently.

## Design Documents

Before coding, teams often create design documents. These explain what will be built and how.

::illustration-checklist
---
title: What Design Docs Include
items:
  - text: Problem statement and goals
    icon: "\U0001F3AF"
  - text: Proposed solution overview
    icon: "\U0001F4A1"
  - text: Architecture diagrams
    icon: "\U0001F5BC️"
  - text: API contracts and data models
    icon: "\U0001F4CB"
  - text: Security considerations
    icon: "\U0001F512"
  - text: Risks and alternatives considered
    icon: "\U000026A0️"
note: Design docs are living documents that evolve with the project
color: blue
size: 2xl
---
::

### Common Diagrams

**System Context Diagram:** Shows the system as a box and what external systems or users interact with it.

**Component Diagram:** Shows major components inside the system and how they connect.

**Sequence Diagram:** Shows how data flows through the system for a specific use case, step by step.

**Database Schema:** Shows tables, fields, and relationships in the database.

## Making Architecture Decisions

Every decision has trade-offs. There is no perfect architecture. Good architects consider:

### Functional Requirements
Does the architecture support what the system needs to do?

### Non-Functional Requirements
- **Performance:** Can it handle the expected load?
- **Scalability:** Can it grow when users increase?
- **Reliability:** What happens when parts fail?
- **Security:** How is data protected?

### Team Skills
Does the team know the chosen technologies? Learning curves slow projects down.

### Budget and Time
More complex architectures cost more to build and operate.

### Future Needs
Will the architecture support features planned for next year?

## Design Principles

### Separation of Concerns

Each component should have one responsibility. The login module should not also send emails. This makes code easier to understand, test, and change.

### Loose Coupling

Components should depend on each other as little as possible. When one component changes, others should not need to change. Use interfaces and APIs to keep components independent.

### High Cohesion

Related code should live together. All user-related functions in one module, all payment functions in another. Do not scatter related code across the system.

### Don't Repeat Yourself (DRY)

If you write the same code twice, make it a shared function. Duplicate code means duplicate bugs and duplicate maintenance.

## Design and DevOps

Architecture decisions directly affect how DevOps works:

**Monoliths:**
- Simple deployment (one artifact)
- All-or-nothing releases
- Testing the whole system together

**Microservices:**
- Independent deployments for each service
- Need for service discovery and API gateways
- Distributed tracing to debug issues
- More complex CI/CD pipelines

**Design for operations:**
- Include health check endpoints
- Design for graceful degradation when parts fail
- Plan for monitoring and logging from the start
- Consider how deployments will work

## Common Mistakes to Avoid

1. **Over-engineering** - Building for millions of users when you have hundreds. Start simple and evolve.

2. **Under-engineering** - Ignoring obvious future needs. If you know traffic will grow 10x, design for it.

3. **Copying without understanding** - Using microservices because Netflix does, without understanding why Netflix needs them.

4. **Ignoring security** - Security cannot be added later. Design it in from the start.

5. **No documentation** - If the architecture is only in one person's head, the project is at risk.

## Key Takeaways

- Architecture defines the high-level structure; design fills in component-level details
- Common patterns include monolithic, three-tier, microservices, and event-driven
- Every architecture decision has trade-offs - there is no perfect solution
- Design documents and diagrams help teams communicate and make decisions
- Architecture choices directly affect how DevOps practices work
- Start simple and evolve - do not over-engineer for problems you do not have

In the next lesson, you will learn about Development and Coding, where the design becomes working software.
