---
title: "Testing & QA"
description: "Learn how testing and quality assurance ensure software works correctly before reaching users."
estimatedMinutes: 14
difficulty: beginner
learningObjectives:
  - "Understand the purpose and importance of software testing"
  - "Identify different types of testing and when to use each"
  - "Recognize the role of QA in the development process"
  - "Apply the testing pyramid concept to testing strategies"
quiz:
  passingScore: 70
  questions:
    - question: "What is the main purpose of software testing?"
      type: single
      options:
        - "To find defects before software reaches users"
        - "To write new features for the application"
        - "To design the system architecture"
        - "To gather requirements from stakeholders"
      correctAnswer: "To find defects before software reaches users"
      explanation: "Testing finds bugs, errors, and problems before users encounter them. Finding issues early is much cheaper than fixing them after release."

    - question: "Select all types of testing that verify the system works as a whole."
      type: multiple
      options:
        - "Integration testing"
        - "End-to-end testing"
        - "Unit testing"
        - "System testing"
      correctAnswers:
        - "Integration testing"
        - "End-to-end testing"
        - "System testing"
      explanation: "Integration, end-to-end, and system testing all check how parts work together. Unit testing checks individual components in isolation."

    - question: "According to the testing pyramid, teams should have more end-to-end tests than unit tests."
      type: true-false
      correctAnswer: false
      explanation: "The testing pyramid recommends the opposite. Unit tests should be the largest portion because they are fast and cheap. End-to-end tests should be fewer because they are slow and expensive to maintain."

    - question: "What is regression testing designed to catch?"
      type: single
      options:
        - "New code breaking features that previously worked"
        - "Performance issues under heavy load"
        - "Security vulnerabilities in the code"
        - "User interface design problems"
      correctAnswer: "New code breaking features that previously worked"
      explanation: "Regression testing runs existing tests after code changes to ensure nothing that worked before is now broken. It catches unintended side effects of new code."

    - question: "Manual testing is completely replaced by automated testing in modern development."
      type: true-false
      correctAnswer: false
      explanation: "Both types of testing have their place. Automated tests excel at repetitive checks and regression testing. Manual testing is valuable for exploratory testing, usability evaluation, and finding unexpected issues."
---

# Testing & QA

Testing and quality assurance (QA) verify that software works correctly. Before code reaches users, testers check that features work as expected, edge cases are handled, and bugs are found and fixed.

Finding a bug during testing costs far less than finding it in production. Testing is not about proving software works - it is about finding where it does not.

## Why Testing Matters

Every software project has bugs. The question is whether you find them before or after users do.

- **Cost**: Fixing bugs in production costs 10x more than fixing them during development
- **Reputation**: Users lose trust in buggy software
- **Safety**: In critical systems, bugs can cause real harm
- **Time**: Finding bugs early saves time in the long run

## Types of Testing

Different types of tests serve different purposes. Good testing strategies use multiple types together.

::illustration-pyramid
---
layers:
  - label: E2E Tests
    description: Slow, costly, few
    icon: "\U0001F310"
    color: rose
  - label: Integration Tests
    description: Test connections
    icon: "\U0001F517"
    color: amber
  - label: Unit Tests
    description: Fast, cheap, many
    icon: "\U0001F9E9"
    color: emerald
footnote: The testing pyramid - more tests at the bottom
size: xl
---
::

### Unit Testing

Unit tests check individual pieces of code in isolation. They are fast, focused, and easy to write.

```javascript
// Unit test example
test('calculate total', () => {
  const cart = new ShoppingCart();
  cart.addItem('Apple', 1.50);
  cart.addItem('Banana', 0.75);
  expect(cart.total()).toBe(2.25);
});
```

**Characteristics:**
- Test single functions or methods
- Run in milliseconds
- Require no external systems
- Should be the largest portion of your tests

### Integration Testing

Integration tests check how components work together. They verify that connections between parts function correctly.

**Examples:**
- API endpoint calling a database
- Service A communicating with Service B
- Application connecting to external APIs

**Characteristics:**
- Test multiple components together
- Slower than unit tests
- May need test databases or mock services
- Catch interface problems between components

### End-to-End Testing

End-to-end (E2E) tests simulate real user workflows. They test the complete system from start to finish.

**Examples:**
- User signs up, logs in, and makes a purchase
- Customer submits a form and receives a confirmation email
- Admin creates a product that appears on the website

**Characteristics:**
- Test entire user journeys
- Slowest to run
- Most expensive to maintain
- Catch problems in complete workflows

### Other Testing Types

::illustration-checklist
---
title: Additional Testing Types
items:
  - text: Performance testing - System speed under load
    icon: "\U000023F1"
  - text: Security testing - Vulnerability detection
    icon: "\U0001F512"
  - text: Usability testing - User experience quality
    icon: "\U0001F465"
  - text: Regression testing - Ensuring old features still work
    icon: "\U0001F504"
  - text: Smoke testing - Basic functionality check
    icon: "\U0001F4A8"
note: Different tests catch different types of problems
color: amber
size: 2xl
---
::

## Manual vs Automated Testing

### Manual Testing

Humans execute tests by following test scripts and exploring the application.

**Best for:**
- Exploratory testing (finding unexpected issues)
- Usability evaluation
- Visual verification
- Complex scenarios hard to automate

### Automated Testing

Code runs tests automatically without human intervention.

**Best for:**
- Repetitive tests that run often
- Regression testing
- Performance testing
- Tests in CI/CD pipelines

Most teams use both. Automate what runs frequently. Keep manual testing for exploration and judgment.

## The QA Role

Quality Assurance professionals focus on software quality throughout development.

**QA responsibilities include:**
- Creating test plans and strategies
- Writing and executing test cases
- Reporting and tracking bugs
- Verifying bug fixes
- Improving testing processes

In DevOps teams, QA often shifts left - getting involved earlier in development rather than waiting until code is "complete."

## Test Environments

Testing happens in controlled environments that mimic production:

- **Development environment**: Developers test their own code
- **QA/Test environment**: Testers verify features
- **Staging environment**: Final check before production
- **Production**: Live system with real users

Each environment should be as similar to production as possible to catch environment-specific bugs.

## Bug Lifecycle

When testers find bugs, they follow a process:

1. **Report**: Document the bug with steps to reproduce
2. **Triage**: Prioritize based on severity and impact
3. **Assign**: Developer takes responsibility
4. **Fix**: Developer writes the fix
5. **Verify**: Tester confirms the fix works
6. **Close**: Bug is resolved

## Testing in DevOps

DevOps transforms testing practices:

- **Automated tests** run in CI/CD pipelines for every code change
- **Shift left** means testing earlier in development
- **Test in production** uses feature flags and canary releases
- **Monitoring** catches issues that testing missed

## Key Takeaways

- Testing finds defects before they reach users, saving time and money
- The testing pyramid recommends many unit tests, fewer integration tests, and fewest E2E tests
- Automated tests catch regressions; manual tests explore and evaluate
- QA ensures quality throughout development, not just at the end
- DevOps integrates testing into continuous delivery pipelines

In the next lesson, you will learn about Deployment, where tested software is released to users.
