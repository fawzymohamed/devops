---
title: "Testing & QA"
description: "Learn the testing phase of SDLC - how teams verify software works correctly, meets requirements, and is ready for users."
estimatedMinutes: 14
difficulty: beginner
learningObjectives:
  - "Understand the purpose of testing in the software development lifecycle"
  - "Identify different types of testing and when to use each"
  - "Explain the testing pyramid and its importance"
  - "Recognize how testing connects to DevOps and continuous delivery"
quiz:
  passingScore: 70
  questions:
    - question: "What is the main purpose of software testing?"
      type: single
      options:
        - "To prove that software has no bugs"
        - "To find defects and verify software meets requirements"
        - "To slow down the development process"
        - "To replace the need for code reviews"
      correctAnswer: "To find defects and verify software meets requirements"
      explanation: "Testing finds bugs and verifies requirements are met. It cannot prove software is bug-free - it can only find bugs that exist. Finding bugs early saves time and money."

    - question: "Which type of test runs fastest and should be most numerous?"
      type: single
      options:
        - "End-to-end tests"
        - "Integration tests"
        - "Unit tests"
        - "Manual tests"
      correctAnswer: "Unit tests"
      explanation: "Unit tests are fastest because they test small pieces of code in isolation. The testing pyramid shows we should have many unit tests, fewer integration tests, and even fewer end-to-end tests."

    - question: "Select all types of testing that verify non-functional requirements."
      type: multiple
      options:
        - "Performance testing"
        - "Unit testing"
        - "Security testing"
        - "Load testing"
      correctAnswers:
        - "Performance testing"
        - "Security testing"
        - "Load testing"
      explanation: "Performance, security, and load testing verify non-functional requirements (how well the system performs). Unit testing verifies functional requirements (what the system does)."

    - question: "Manual testing is no longer needed when you have automated tests."
      type: true-false
      correctAnswer: false
      explanation: "This is false. Automated tests are great for repetitive checks, but manual testing is still valuable for exploratory testing, usability evaluation, and finding issues automation might miss."

    - question: "What is regression testing?"
      type: single
      options:
        - "Testing new features before they are built"
        - "Testing to make sure old features still work after changes"
        - "Testing performed only by users"
        - "Testing that runs only in production"
      correctAnswer: "Testing to make sure old features still work after changes"
      explanation: "Regression testing verifies that new changes have not broken existing functionality. It catches bugs where fixing one thing accidentally breaks another."
---

# Testing & QA

Testing is where you find out if your software actually works. It answers critical questions: Does the code do what it should? Does it meet user needs? Will it survive real-world use?

Quality Assurance (QA) is broader than testing. QA includes all activities that ensure quality: testing, code reviews, process improvements, and standards. But testing is the most visible QA activity.

## Why Testing Matters

Bugs found late cost more than bugs found early. A bug caught during coding might take an hour to fix. The same bug found in production might need emergency fixes, customer apologies, and lost revenue.

::illustration-linear-flow
---
steps:
  - label: Requirements
    sublabel: $1 to fix
    icon: "\U0001F4CB"
    color: emerald
  - label: Design
    sublabel: $10 to fix
    icon: "\U0001F3D7️"
    color: cyan
  - label: Development
    sublabel: $100 to fix
    icon: "\U0001F4BB"
    color: blue
  - label: Testing
    sublabel: $1,000 to fix
    icon: "\U0001F50D"
    color: amber
  - label: Production
    sublabel: $10,000 to fix
    icon: "\U0001F680"
    color: rose
size: full
---
::

The earlier you catch a bug, the cheaper it is to fix. Testing throughout the lifecycle - not just at the end - saves money and time.

## Types of Testing

### Unit Testing

Unit tests check individual pieces of code in isolation. They test single functions or methods without dependencies on databases, networks, or other systems.

**Example:**
```javascript
// Function to test
function calculateDiscount(price, percentage) {
  return price * (percentage / 100);
}

// Unit test
test('calculates 20% discount correctly', () => {
  expect(calculateDiscount(100, 20)).toBe(20);
});
```

**Characteristics:**
- Very fast to run (milliseconds)
- Written by developers
- Run automatically on every code change
- Catch logic errors early

### Integration Testing

Integration tests check how different parts work together. They test the connections between components: does the API talk to the database correctly? Does the frontend call the backend properly?

**Example scenarios:**
- User service stores data in the database correctly
- Payment gateway integration processes cards successfully
- Message queue delivers messages between services

### End-to-End (E2E) Testing

E2E tests verify complete user workflows from start to finish. They simulate real user actions in a real browser or application.

**Example scenarios:**
- User can sign up, log in, and make a purchase
- Admin can create a product and it appears on the website
- User can search, filter, and sort results correctly

**Characteristics:**
- Slowest to run (seconds to minutes)
- Most realistic - test what users actually experience
- Most fragile - break when UI changes
- Most expensive to maintain

### The Testing Pyramid

The testing pyramid guides how many of each test type to write:

```
        /\
       /  \      E2E Tests (few)
      /____\
     /      \    Integration Tests (some)
    /________\
   /          \  Unit Tests (many)
  /______________\
```

**Why this shape?**
- Unit tests are fast and cheap - have many
- Integration tests are slower - have some
- E2E tests are slowest and most fragile - have few

Teams that invert this pyramid (many E2E, few unit tests) have slow, unreliable test suites.

## Functional vs Non-Functional Testing

### Functional Testing

Functional testing verifies **what** the system does:

::illustration-checklist
---
title: Functional Testing Types
items:
  - text: Unit testing - Individual code pieces
    icon: "\U0001F9E9"
  - text: Integration testing - Components together
    icon: "\U0001F517"
  - text: System testing - Complete system
    icon: "\U0001F4BB"
  - text: Acceptance testing - Meets user needs
    icon: "\U0001F44D"
  - text: Regression testing - Old features still work
    icon: "\U0001F504"
note: These tests verify the system does what requirements specify
color: blue
size: 2xl
---
::

### Non-Functional Testing

Non-functional testing verifies **how well** the system performs:

**Performance Testing:** Is it fast enough?
- Response times under normal load
- Throughput (requests per second)

**Load Testing:** Can it handle expected traffic?
- System behavior under peak load
- Point where performance degrades

**Stress Testing:** What happens under extreme conditions?
- Behavior when overloaded
- Recovery when load decreases

**Security Testing:** Is it secure?
- Vulnerability scanning
- Penetration testing
- Authentication and authorization checks

**Usability Testing:** Is it easy to use?
- User interface evaluation
- Accessibility compliance

## Manual vs Automated Testing

### Manual Testing

Humans execute tests by hand. Testers click buttons, fill forms, and verify results manually.

**When to use:**
- Exploratory testing (finding unexpected bugs)
- Usability evaluation
- Testing new features for the first time
- Complex scenarios hard to automate

**Limitations:**
- Slow and expensive
- Humans make mistakes
- Boring repetition leads to missed bugs

### Automated Testing

Computers execute tests automatically. Code verifies that other code works correctly.

**When to use:**
- Regression testing (same tests run repeatedly)
- Performance testing (precise timing needed)
- Continuous integration (tests run on every commit)
- Any test that runs more than a few times

**Benefits:**
- Fast and consistent
- Runs anytime, including nights and weekends
- Scales to thousands of tests
- Catches regressions immediately

## Testing in DevOps

DevOps transforms how testing works:

### Shift Left

Move testing earlier in the lifecycle. Do not wait until the end to test. Test from the first line of code.

::illustration-comparison-map
---
leftTitle: Traditional Testing
rightTitle: DevOps Testing
leftColor: gray
rightColor: emerald
connections:
  - left: Test at the end
    right: Test continuously
    icon: "\U0001F504"
  - left: QA team tests
    right: Everyone tests
    icon: "\U0001F465"
  - left: Manual testing focus
    right: Automation focus
    icon: "\U0001F916"
  - left: Long test cycles
    right: Fast feedback loops
    icon: "\U000023F1️"
footnote: DevOps makes testing faster, earlier, and more automated
size: full
---
::

### Continuous Testing

Tests run automatically whenever code changes:
1. Developer commits code
2. CI system detects the change
3. Automated tests run immediately
4. Developer gets feedback in minutes

### Test Automation in CI/CD

In a CI/CD pipeline, tests are gates. Code cannot proceed to the next stage until tests pass:

```
Code Commit → Unit Tests → Integration Tests → E2E Tests → Deploy
                  ↓              ↓                ↓
               Pass?          Pass?            Pass?
```

### Test Environments

DevOps teams maintain multiple environments:
- **Development:** Where developers build and test locally
- **Testing/QA:** Dedicated environment for QA team
- **Staging:** Production-like environment for final verification
- **Production:** Live environment where users interact

## Common Mistakes to Avoid

1. **Testing only the happy path** - Test what happens when things go wrong. Error cases often have more bugs.

2. **Too many E2E tests** - They are slow and fragile. Prefer unit and integration tests.

3. **Ignoring flaky tests** - Tests that sometimes pass and sometimes fail destroy trust in the test suite. Fix or remove them.

4. **Testing implementation, not behavior** - Tests should verify what code does, not how it does it internally.

5. **No test data strategy** - Tests need consistent data. Random or shared data causes random failures.

## Key Takeaways

- Testing finds bugs and verifies requirements - earlier is cheaper than later
- The testing pyramid: many unit tests, some integration, few E2E
- Functional tests verify what the system does; non-functional tests verify how well
- Automated tests enable fast feedback and continuous delivery
- DevOps shifts testing left, making it continuous and automated
- Both manual and automated testing have their place

In the next lesson, you will learn about Deployment, where tested software is released to production for users.
