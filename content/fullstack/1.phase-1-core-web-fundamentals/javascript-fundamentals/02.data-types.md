---
title: "Data Types (primitives, objects, type coercion)"
description: "Master JavaScript's primitive and reference types, understand type coercion, and learn best practices for type handling"
estimatedMinutes: 18
phase: 1
topic: "JavaScript Fundamentals"
subtopic: "data-types"
priority: essential
difficulty: beginner
learningObjectives:
  - "Identify and use JavaScript's seven primitive data types"
  - "Understand the difference between primitive and reference types"
  - "Explain how type coercion works and when it happens"
  - "Use the typeof operator to check data types"
quiz:
  passingScore: 70
  questions:
    - question: "How many primitive data types does JavaScript have?"
      type: single
      options:
        - "7"
        - "5"
        - "6"
        - "8"
      correctAnswer: "7"
      explanation: "JavaScript has 7 primitive types: string, number, boolean, null, undefined, symbol, and bigint. These are the fundamental building blocks of JavaScript data."

    - question: "What is the difference between primitive and reference types?"
      type: single
      options:
        - "Primitives store values directly, references store memory addresses"
        - "Primitives are slower, references are faster"
        - "Primitives use more memory than references"
        - "There is no difference"
      correctAnswer: "Primitives store values directly, references store memory addresses"
      explanation: "Primitive types store the actual value. Reference types (objects, arrays, functions) store a memory address pointing to where the data lives. This affects how they behave when copied or compared."

    - question: "What does typeof null return?"
      type: single
      options:
        - "\"object\""
        - "\"null\""
        - "\"undefined\""
        - "null"
      correctAnswer: "\"object\""
      explanation: "typeof null returns \"object\", which is a famous JavaScript bug that cannot be fixed without breaking existing code. This has existed since JavaScript's creation."

    - question: "Select all statements that are TRUE about type coercion."
      type: multiple
      options:
        - "Type coercion happens automatically in JavaScript"
        - "The == operator performs type coercion"
        - "The === operator performs type coercion"
        - "String concatenation with + triggers coercion"
      correctAnswers:
        - "Type coercion happens automatically in JavaScript"
        - "The == operator performs type coercion"
        - "String concatenation with + triggers coercion"
      explanation: "JavaScript automatically converts types in certain situations. The == operator coerces types before comparing, while === does not. The + operator with a string coerces other values to strings."

    - question: "What is the result of 5 + \"5\" in JavaScript?"
      type: single
      options:
        - "\"55\""
        - "10"
        - "\"10\""
        - "NaN"
      correctAnswer: "\"55\""
      explanation: "When you use + with a number and a string, JavaScript coerces the number to a string and concatenates them. So 5 + \"5\" becomes \"5\" + \"5\" which equals \"55\"."

    - question: "NaN (Not a Number) is a value of type number."
      type: true-false
      correctAnswer: true
      explanation: "True! Although its name says \"Not a Number\", NaN is actually of type number. It represents the result of invalid numeric operations. You can check with typeof NaN which returns \"number\"."
---

# Data Types (primitives, objects, type coercion)

JavaScript variables can store different kinds of data. Some store simple values like numbers or text. Others store complex structures like lists or objects. Understanding data types helps you write code that works correctly and avoids bugs.

In this lesson, you will learn about primitive types (the basic building blocks), reference types (complex data structures), and type coercion (how JavaScript automatically converts between types).

## What Are Data Types?

Data types define what kind of value a variable can hold. JavaScript needs to know whether you are working with a number, text, true/false, or something else.

```javascript
let age = 25              // Number
let name = 'Alice'        // String
let isActive = true       // Boolean
let user = { id: 1 }      // Object
let colors = ['red']      // Array (also an object)
```

JavaScript has two categories of types: **primitives** and **reference types**.

## Primitive Types

Primitive types are the most basic data types. JavaScript has **seven primitive types**:

::illustration-linear-flow
---
steps:
  - label: string
    sublabel: Text data
    icon: üìù
    color: violet
  - label: number
    sublabel: Integers & decimals
    icon: üî¢
    color: blue
  - label: boolean
    sublabel: true or false
    icon: ‚úì
    color: cyan
  - label: null
    sublabel: Intentional empty
    icon: ‚≠ï
    color: gray
  - label: undefined
    sublabel: Not yet set
    icon: ‚ùì
    color: gray
  - label: symbol
    sublabel: Unique identifier
    icon: üîë
    color: amber
  - label: bigint
    sublabel: Large integers
    icon: üîü
    color: emerald
direction: horizontal
size: full
---
::

### 1. String

Strings store text. Use single quotes, double quotes, or backticks:

```javascript
let firstName = 'Alice'
let lastName = "Smith"
let greeting = `Hello, ${firstName}!`  // Template literal

// Strings are immutable
let message = 'Hello'
message[0] = 'h'  // This does nothing
console.log(message)  // Still 'Hello'
```

### 2. Number

Numbers can be integers or decimals. JavaScript uses one type for all numbers:

```javascript
let age = 25           // Integer
let price = 19.99      // Decimal
let negative = -10     // Negative number
let billion = 1e9      // Scientific notation (1,000,000,000)

// Special numeric values
let infinity = Infinity
let notANumber = NaN   // Result of invalid math
```

**Important:** JavaScript has precision limits. Very large or very small numbers may not be exact.

### 3. Boolean

Booleans store true or false. They are used for conditions and logic:

```javascript
let isLoggedIn = true
let hasAccess = false

// Common in conditions
if (isLoggedIn) {
  console.log('Welcome back!')
}
```

### 4. null

`null` means "intentionally empty" or "no value". You set it on purpose:

```javascript
let selectedUser = null  // No user selected yet
let result = null        // Reset a value

// Check for null
if (selectedUser === null) {
  console.log('No user selected')
}
```

### 5. undefined

`undefined` means a variable exists but has no value yet:

```javascript
let userName           // Declared but not assigned
console.log(userName)  // undefined

function greet(name) {
  console.log(name)    // undefined if not provided
}
greet()  // Called without argument
```

**null vs undefined:**
- `null`: You set this intentionally
- `undefined`: JavaScript sets this automatically

### 6. Symbol

Symbols create unique identifiers. Two symbols are never equal:

```javascript
let id1 = Symbol('id')
let id2 = Symbol('id')

console.log(id1 === id2)  // false - always unique

// Used as object keys for unique properties
const user = {
  [id1]: 'User-123',
  name: 'Alice'
}
```

**Note:** Symbols are advanced. You will not use them often as a beginner.

### 7. BigInt

BigInt stores very large integers that exceed the normal number limit:

```javascript
// Normal number limit
let maxNumber = 9007199254740991  // Largest safe integer

// BigInt can go bigger
let bigNumber = 9007199254740991n  // Add 'n' at the end
let anotherBig = BigInt('12345678901234567890')

console.log(typeof bigNumber)  // 'bigint'
```

**Note:** You cannot mix BigInt with regular numbers in math operations.

## Reference Types (Objects)

Reference types store collections of data or more complex entities. The main reference type is **Object**.

### Objects

Objects store key-value pairs:

```javascript
const user = {
  name: 'Alice',
  age: 25,
  isActive: true
}

console.log(user.name)  // 'Alice'
console.log(user['age'])  // 25
```

### Arrays

Arrays are special objects that store lists:

```javascript
const colors = ['red', 'green', 'blue']
console.log(colors[0])  // 'red'
console.log(colors.length)  // 3

// Arrays are objects
console.log(typeof colors)  // 'object'
```

### Functions

Functions are also objects:

```javascript
function greet(name) {
  return `Hello, ${name}!`
}

console.log(typeof greet)  // 'function'
```

## Primitives vs References: Key Differences

The biggest difference is how they are stored and copied:

::illustration-comparison-map
---
leftTitle: Primitive Types
rightTitle: Reference Types
leftColor: violet
rightColor: cyan
connections:
  - left: Store actual value
    right: Store memory address
    icon: üíæ
  - left: Copy creates new value
    right: Copy shares same object
    icon: üìã
  - left: Compare by value
    right: Compare by reference
    icon: ‚öñÔ∏è
footnote: Understanding this difference prevents common bugs
---
::

### Copying Primitives

When you copy a primitive, you get a new independent value:

```javascript
let a = 10
let b = a       // Copy the value
b = 20          // Change b

console.log(a)  // 10 - unchanged
console.log(b)  // 20
```

### Copying References

When you copy an object, both variables point to the same data:

```javascript
let user1 = { name: 'Alice' }
let user2 = user1  // Copy the reference, not the object

user2.name = 'Bob'  // Change through user2

console.log(user1.name)  // 'Bob' - user1 also changed!
console.log(user2.name)  // 'Bob'
```

This happens because `user1` and `user2` both point to the same object in memory.

## The typeof Operator

Use `typeof` to check what type a value is:

```javascript
console.log(typeof 'Hello')      // 'string'
console.log(typeof 42)           // 'number'
console.log(typeof true)         // 'boolean'
console.log(typeof undefined)    // 'undefined'
console.log(typeof Symbol('id')) // 'symbol'
console.log(typeof 123n)         // 'bigint'
console.log(typeof {})           // 'object'
console.log(typeof [])           // 'object' (arrays are objects)
console.log(typeof null)         // 'object' (famous bug!)
console.log(typeof function(){}) // 'function'
```

**Watch out for these quirks:**
- `typeof null` returns `'object'` (this is a bug that cannot be fixed)
- `typeof []` returns `'object'` (arrays are objects)
- `typeof NaN` returns `'number'` (even though NaN means "Not a Number")

## Type Coercion

Type coercion is when JavaScript automatically converts one type to another. This can be helpful or confusing.

### Implicit Coercion

JavaScript converts types automatically in certain situations:

```javascript
// Number to string
let result = 5 + '5'
console.log(result)  // '55' (number 5 becomes string '5')

// String to number
let sum = '10' - 5
console.log(sum)  // 5 (string '10' becomes number 10)

// Boolean to number
let value = true + 1
console.log(value)  // 2 (true becomes 1)
```

**Why does + behave differently?**
- With strings, `+` means concatenation (joining text)
- With numbers, `+` means addition
- If one operand is a string, JavaScript converts the other to a string too

### Comparison Coercion

The `==` operator coerces types before comparing:

```javascript
console.log(5 == '5')    // true (string '5' becomes number 5)
console.log(1 == true)   // true (true becomes 1)
console.log(0 == false)  // true (false becomes 0)
console.log(null == undefined)  // true (special case)

// Use === to avoid coercion
console.log(5 === '5')   // false (different types)
console.log(1 === true)  // false (different types)
```

### Explicit Coercion

You can convert types manually:

```javascript
// To string
String(123)       // '123'
(123).toString()  // '123'

// To number
Number('123')     // 123
parseInt('123')   // 123
parseFloat('12.5')  // 12.5

// To boolean
Boolean(1)        // true
Boolean(0)        // false
Boolean('')       // false
Boolean('hello')  // true
```

## Truthy and Falsy Values

In conditions, JavaScript treats some values as true and others as false:

**Falsy values** (treated as false):
- `false`
- `0`
- `''` (empty string)
- `null`
- `undefined`
- `NaN`

**Everything else is truthy** (treated as true):

```javascript
if ('hello') {
  console.log('This runs')  // Strings are truthy
}

if (0) {
  console.log('This does NOT run')  // 0 is falsy
}

if ([]) {
  console.log('This runs')  // Empty arrays are truthy
}
```

## Practical Examples

### Example 1: Type Checking

```javascript
function processData(input) {
  if (typeof input === 'string') {
    return input.toUpperCase()
  } else if (typeof input === 'number') {
    return input * 2
  } else {
    return 'Unknown type'
  }
}

console.log(processData('hello'))  // 'HELLO'
console.log(processData(10))       // 20
console.log(processData(true))     // 'Unknown type'
```

### Example 2: Avoiding Coercion Bugs

```javascript
// Bug: Using == with mixed types
let userInput = '0'

if (userInput == false) {
  console.log('This runs unexpectedly!')  // '0' coerces to false
}

// Fix: Use === for strict comparison
if (userInput === false) {
  console.log('This does NOT run')  // Correct behavior
}

// Better: Check the actual value
if (userInput === '0') {
  console.log('Input is string zero')
}
```

### Example 3: Default Values

```javascript
function greet(name) {
  // Use || for default values (be careful with falsy values)
  name = name || 'Guest'
  console.log(`Hello, ${name}!`)
}

greet('Alice')  // 'Hello, Alice!'
greet()         // 'Hello, Guest!'

// Modern way: Use default parameters
function greetModern(name = 'Guest') {
  console.log(`Hello, ${name}!`)
}
```

## Best Practices

::illustration-checklist
---
title: Data Type Best Practices
items:
  - text: Use === instead of == for comparisons
    icon: ‚öñÔ∏è
  - text: Check types with typeof before operations
    icon: üîç
  - text: Convert types explicitly, not implicitly
    icon: üîÑ
  - text: Understand truthy and falsy values
    icon: ‚úì
  - text: Be careful with null and undefined
    icon: ‚ö†Ô∏è
  - text: Use const for values that should not change type
    icon: üîí
note: These practices prevent common type-related bugs
color: emerald
---
::

### Rule 1: Prefer Strict Equality

Always use `===` and `!==` instead of `==` and `!=`:

```javascript
// Bad
if (x == 10) { }
if (y != null) { }

// Good
if (x === 10) { }
if (y !== null) { }
```

### Rule 2: Validate Types

Check types before performing operations:

```javascript
function calculateDiscount(price, discount) {
  if (typeof price !== 'number' || typeof discount !== 'number') {
    throw new Error('Both arguments must be numbers')
  }
  return price - (price * discount)
}
```

### Rule 3: Convert Explicitly

Make type conversions obvious in your code:

```javascript
// Bad - implicit coercion
let total = price + ''  // Converts to string

// Good - explicit conversion
let total = String(price)
```

## Common Mistakes to Avoid

### Mistake 1: Confusing null and undefined

```javascript
// Unclear intent
let data = undefined

// Better - use null for intentional absence
let data = null
```

### Mistake 2: Using typeof for null

```javascript
// Wrong - typeof null is 'object'
if (typeof value === 'null') { }  // This never works!

// Correct
if (value === null) { }
```

### Mistake 3: Trusting Automatic Coercion

```javascript
// Unexpected result
console.log('10' + 20)   // '1020' (not 30)
console.log('10' - 20)   // -10 (works, but inconsistent)

// Explicit and clear
console.log(Number('10') + 20)  // 30
```

### Mistake 4: Not Checking Array Types

```javascript
// Wrong - arrays return 'object'
if (typeof value === 'array') { }  // This never works!

// Correct
if (Array.isArray(value)) { }
```

## Interview Tips

Data type questions are very common in JavaScript interviews. Be ready to explain:

1. **Seven primitive types**: List them all (string, number, boolean, null, undefined, symbol, bigint)
2. **typeof quirks**: Know that `typeof null` returns `'object'` and why
3. **Coercion rules**: Explain how `==` differs from `===`
4. **Reference vs primitive**: Show you understand how copying works differently

**Sample interview question:** "What's the difference between null and undefined?"

**Strong answer:** "Both represent absence of value, but they mean different things. undefined means a variable has been declared but not assigned a value yet - JavaScript sets this automatically. null means we intentionally set a variable to 'no value' - it's an explicit assignment. For example, if a function doesn't return anything, it returns undefined. But if I want to reset an object reference, I'd set it to null."

## Key Takeaways

- JavaScript has **seven primitive types**: string, number, boolean, null, undefined, symbol, and bigint
- **Primitives** store values directly, **references** store memory addresses
- Use `typeof` to check types, but watch for quirks (null, arrays)
- **Type coercion** happens automatically with operators like `+` and `==`
- Use `===` for comparisons to avoid unexpected coercion
- **Truthy values** include everything except false, 0, '', null, undefined, and NaN
- Understand the difference between null (intentional) and undefined (automatic)
- Always validate and convert types explicitly for safer code

In the next lesson, you'll learn about functions - how to declare them, call them, and use them to organize your code.
