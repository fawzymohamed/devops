---
title: "ES6+ Features - Modern JavaScript"
description: "Master essential ES6+ features: template literals, default parameters, rest operator, and more modern JavaScript syntax"
difficulty: beginner
estimatedMinutes: 20
priority: essential
tags: ["javascript", "es6", "template-literals", "default-parameters", "rest-operator", "fundamentals"]
roadmap: fullstack
phase: 1
topic: javascript-fundamentals
learningObjectives:
  - "Use template literals for clean string interpolation"
  - "Apply default parameters to make functions more flexible"
  - "Leverage the rest operator to handle variable numbers of arguments"
  - "Write modern JavaScript code using ES6+ syntax"
quiz:
  passingScore: 70
  questions:
    - question: "What is the main advantage of template literals over string concatenation?"
      type: single
      options:
        - "Cleaner syntax with embedded expressions and multi-line support"
        - "Faster execution speed"
        - "Smaller file size"
        - "Works in older browsers"
      correctAnswer: "Cleaner syntax with embedded expressions and multi-line support"
      explanation: "Template literals use backticks and ${} for cleaner string interpolation and support multi-line strings without escape characters."

    - question: "Which ES6+ features help with function parameters? Select all that apply."
      type: multiple
      options:
        - "Default parameters (provide fallback values)"
        - "Rest operator (collect remaining arguments)"
        - "Template literals (for string arguments)"
        - "Destructuring (extract from objects/arrays)"
      correctAnswers:
        - "Default parameters (provide fallback values)"
        - "Rest operator (collect remaining arguments)"
        - "Destructuring (extract from objects/arrays)"
      explanation: "Default parameters, rest operator, and destructuring all improve function parameter handling. Template literals are for strings, not parameters."

    - question: "What does the rest operator (...) do in function parameters?"
      type: single
      options:
        - "Collects remaining arguments into an array"
        - "Spreads an array into individual arguments"
        - "Creates a copy of an object"
        - "Provides default values"
      correctAnswer: "Collects remaining arguments into an array"
      explanation: "In function parameters, ...rest collects all remaining arguments into an array. This is different from spread, which expands arrays/objects."

    - question: "Can you use expressions inside template literal placeholders ${...}?"
      type: true-false
      correctAnswer: true
      explanation: "True! You can use any JavaScript expression inside ${}: variables, calculations, function calls, ternary operators, etc."

    - question: "What will this code output? `const greet = (name = 'Guest') => Hello, ${name}!; console.log(greet());`"
      type: single
      options:
        - "Hello, Guest!"
        - "Hello, undefined!"
        - "Hello, name!"
        - "Error"
      correctAnswer: "Hello, Guest!"
      explanation: "The function uses a default parameter (name = 'Guest'). When called without arguments, name defaults to 'Guest'. The template literal then outputs 'Hello, Guest!'."

    - question: "How do you create a multi-line string with template literals?"
      type: single
      options:
        - "Just press Enter inside backticks - no escape needed"
        - "Use \\n for each new line"
        - "Use + to concatenate lines"
        - "You cannot create multi-line strings"
      correctAnswer: "Just press Enter inside backticks - no escape needed"
      explanation: "Template literals (backticks) support multi-line strings natively. Just press Enter to create a new line - no \\n or concatenation needed."

    - question: "What is the difference between rest and spread operators?"
      type: single
      options:
        - "Rest collects into array, spread expands from array/object"
        - "They are exactly the same"
        - "Rest is for objects, spread is for arrays"
        - "Rest is older, spread is ES6+"
      correctAnswer: "Rest collects into array, spread expands from array/object"
      explanation: "Both use ... syntax but opposite purposes: rest collects multiple items into an array (function params), spread expands an array/object into individual items."
---

# ES6+ Features - Modern JavaScript

ES6 (ECMAScript 2015) brought the biggest update to JavaScript in years. It introduced modern syntax that makes code cleaner, shorter, and easier to read. Features like template literals, default parameters, and the rest operator are now standard in professional JavaScript.

This lesson covers essential ES6+ features you'll use every day. These aren't just nice-to-have - they're the modern way to write JavaScript, and you'll see them in every framework, library, and codebase.

## What is ES6+?

ES6 (also called ES2015) is a version of JavaScript released in 2015. The "+" means all improvements since then (ES2016, ES2017, etc.). Modern browsers support ES6+ features, and build tools transpile them for older browsers if needed.

**Key ES6+ Features:**
- Template literals (`` ` ``)
- Arrow functions (`=>`)
- Default parameters
- Rest and spread operators (`...`)
- Destructuring
- `let` and `const`
- Classes
- Promises

This lesson focuses on template literals, default parameters, and the rest operator. You've already learned arrow functions, destructuring, and spread in earlier lessons.

## Template Literals - Better Strings

Template literals replace old string concatenation with a cleaner syntax using backticks (`` ` ``).

### Old Way - String Concatenation

```javascript
const name = "Alice";
const age = 25;

const message = "Hello, my name is " + name + " and I'm " + age + " years old.";
console.log(message);
// Output: Hello, my name is Alice and I'm 25 years old.
```

**Problems:**
- Hard to read with many `+` signs
- Easy to miss spaces
- Messy with quotes and escapes

### New Way - Template Literals

Use backticks (`` ` ``) and `${}` for embedded expressions:

```javascript
const name = "Alice";
const age = 25;

const message = `Hello, my name is ${name} and I'm ${age} years old.`;
console.log(message);
// Output: Hello, my name is Alice and I'm 25 years old.
```

**Benefits:**
- Clean, readable syntax
- No `+` signs
- Easy to see embedded values

### Expressions in Template Literals

You can use any JavaScript expression inside `${}`:

```javascript
const price = 100;
const tax = 0.15;

console.log(`Total: $${price * (1 + tax)}`);
// Output: Total: $115

const a = 5;
const b = 10;

console.log(`The sum of ${a} and ${b} is ${a + b}`);
// Output: The sum of 5 and 10 is 15
```

**Common Uses:**

```javascript
// Function calls
const user = { name: "Bob" };
console.log(`Welcome, ${user.name.toUpperCase()}!`);
// Output: Welcome, BOB!

// Ternary operators
const age = 20;
console.log(`Status: ${age >= 18 ? "Adult" : "Minor"}`);
// Output: Status: Adult

// Math operations
const width = 5;
const height = 10;
console.log(`Area: ${width * height} square units`);
// Output: Area: 50 square units
```

### Multi-line Strings

Template literals support multi-line strings without escape characters:

**Old Way:**

```javascript
const html = "<div>\n" +
             "  <h1>Title</h1>\n" +
             "  <p>Content</p>\n" +
             "</div>";
```

**New Way:**

```javascript
const html = `
<div>
  <h1>Title</h1>
  <p>Content</p>
</div>
`;
```

**Practical Example - HTML Templates:**

```javascript
const createCard = (title, content) => `
  <div class="card">
    <h2>${title}</h2>
    <p>${content}</p>
  </div>
`;

console.log(createCard("Welcome", "This is a card"));
// Output:
//   <div class="card">
//     <h2>Welcome</h2>
//     <p>This is a card</p>
//   </div>
```

## Default Parameters - Fallback Values

Default parameters let you specify fallback values for function parameters. If the caller doesn't provide a value, the default is used.

### Old Way - Manual Defaults

```javascript
function greet(name) {
  name = name || "Guest"; // Fallback to "Guest"
  return "Hello, " + name + "!";
}

console.log(greet("Alice")); // Output: Hello, Alice!
console.log(greet());        // Output: Hello, Guest!
```

**Problem:** The `||` operator treats falsy values (0, "", false) as missing, which can cause bugs.

### New Way - Default Parameters

```javascript
const greet = (name = "Guest") => `Hello, ${name}!`;

console.log(greet("Alice")); // Output: Hello, Alice!
console.log(greet());        // Output: Hello, Guest!
```

**Benefits:**
- Cleaner syntax
- Works correctly with falsy values
- Self-documenting (shows expected defaults)

### Multiple Default Parameters

```javascript
const createUser = (name = "Anonymous", age = 18, role = "user") => {
  return {
    name,
    age,
    role
  };
};

console.log(createUser("Alice", 25, "admin"));
// Output: { name: "Alice", age: 25, role: "admin" }

console.log(createUser("Bob"));
// Output: { name: "Bob", age: 18, role: "user" }

console.log(createUser());
// Output: { name: "Anonymous", age: 18, role: "user" }
```

### Using Expressions as Defaults

Default values can be expressions, not just static values:

```javascript
const getTimestamp = () => new Date().toISOString();

const logEvent = (event, timestamp = getTimestamp()) => {
  console.log(`[${timestamp}] ${event}`);
};

logEvent("User logged in");
// Output: [2024-01-14T10:30:00.000Z] User logged in

logEvent("Error occurred", "2024-01-01T00:00:00.000Z");
// Output: [2024-01-01T00:00:00.000Z] Error occurred
```

### Default Parameters with Destructuring

Combine defaults with destructuring for powerful configuration objects:

```javascript
const createButton = ({
  text = "Click me",
  color = "blue",
  size = "medium"
} = {}) => {
  return `<button class="${color} ${size}">${text}</button>`;
};

console.log(createButton({ text: "Submit", color: "green" }));
// Output: <button class="green medium">Submit</button>

console.log(createButton({}));
// Output: <button class="blue medium">Click me</button>

console.log(createButton());
// Output: <button class="blue medium">Click me</button>
```

**Note:** The `= {}` at the end prevents errors when called with no arguments.

## Rest Operator - Collect Arguments

The rest operator (`...`) collects remaining function arguments into an array. It's perfect for functions that accept a variable number of arguments.

### Basic Rest Operator

```javascript
const sum = (...numbers) => {
  let total = 0;
  for (const num of numbers) {
    total += num;
  }
  return total;
};

console.log(sum(1, 2, 3));       // Output: 6
console.log(sum(5, 10, 15, 20)); // Output: 50
console.log(sum());              // Output: 0
```

**How it Works:**
- `...numbers` collects all arguments into an array called `numbers`
- You can pass any number of arguments
- If no arguments, `numbers` is an empty array `[]`

### Rest with Named Parameters

Combine regular parameters with rest to collect "the rest":

```javascript
const introduce = (firstName, lastName, ...hobbies) => {
  const hobbiesList = hobbies.join(", ");
  return `I'm ${firstName} ${lastName}. I like ${hobbiesList}.`;
};

console.log(introduce("Alice", "Smith", "reading", "coding", "gaming"));
// Output: I'm Alice Smith. I like reading, coding, gaming.

console.log(introduce("Bob", "Jones", "music"));
// Output: I'm Bob Jones. I like music.
```

**Rules:**
- Rest parameter must be the **last** parameter
- You can only have **one** rest parameter
- `function(a, ...rest, b)` ‚ùå (rest must be last)
- `function(...rest1, ...rest2)` ‚ùå (only one rest)

### Rest vs Arguments Object

**Old Way - arguments object:**

```javascript
function oldSum() {
  let total = 0;
  for (let i = 0; i < arguments.length; i++) {
    total += arguments[i];
  }
  return total;
}
```

**Problems:**
- `arguments` is not a real array (no array methods)
- Doesn't work with arrow functions
- Not clear from function signature

**New Way - rest operator:**

```javascript
const newSum = (...numbers) => {
  return numbers.reduce((total, n) => total + n, 0);
};
```

**Benefits:**
- Real array with all array methods
- Works with arrow functions
- Clear from function signature

### Practical Example - Logger Function

```javascript
const log = (level, message, ...details) => {
  const timestamp = new Date().toISOString();
  console.log(`[${timestamp}] ${level}: ${message}`);

  if (details.length > 0) {
    console.log("Details:", details);
  }
};

log("INFO", "User logged in");
// Output: [2024-01-14T10:30:00.000Z] INFO: User logged in

log("ERROR", "Database connection failed", "localhost", 5432, "Connection timeout");
// Output:
// [2024-01-14T10:30:00.000Z] ERROR: Database connection failed
// Details: ["localhost", 5432, "Connection timeout"]
```

## Rest vs Spread - The Difference

Both use `...` syntax, but they work in opposite directions:

| Operator | Purpose | Context | Example |
|----------|---------|---------|---------|
| **Rest** | Collect into array | Function parameters | `function(...args)` |
| **Spread** | Expand from array/object | Function calls, arrays, objects | `myFunc(...arr)` |

**Rest - Collect:**

```javascript
const collectArgs = (...args) => {
  console.log(args); // Array of all arguments
};

collectArgs(1, 2, 3); // Output: [1, 2, 3]
```

**Spread - Expand:**

```javascript
const numbers = [1, 2, 3];
console.log(...numbers); // Output: 1 2 3 (separate values)

const arr1 = [1, 2];
const arr2 = [3, 4];
const merged = [...arr1, ...arr2]; // Output: [1, 2, 3, 4]
```

## Practical Examples

### Example 1: Building URLs

```javascript
const buildUrl = (base, path, params = {}) => {
  const queryString = Object.entries(params)
    .map(([key, value]) => `${key}=${value}`)
    .join("&");

  return queryString
    ? `${base}${path}?${queryString}`
    : `${base}${path}`;
};

console.log(buildUrl("https://api.example.com", "/users", { page: 1, limit: 10 }));
// Output: https://api.example.com/users?page=1&limit=10

console.log(buildUrl("https://api.example.com", "/users"));
// Output: https://api.example.com/users
```

### Example 2: Formatting Messages

```javascript
const formatMessage = (template, ...values) => {
  let result = template;
  values.forEach((value, index) => {
    result = result.replace(`{${index}}`, value);
  });
  return result;
};

console.log(formatMessage("Hello, {0}! You have {1} messages.", "Alice", 5));
// Output: Hello, Alice! You have 5 messages.
```

### Example 3: Math Utilities

```javascript
const max = (...numbers) => Math.max(...numbers);
const min = (...numbers) => Math.min(...numbers);
const average = (...numbers) => {
  if (numbers.length === 0) return 0;
  return numbers.reduce((sum, n) => sum + n, 0) / numbers.length;
};

console.log(max(5, 2, 9, 1, 7));     // Output: 9
console.log(min(5, 2, 9, 1, 7));     // Output: 1
console.log(average(5, 2, 9, 1, 7)); // Output: 4.8
```

## Try It Yourself

**Exercise 1: Template Literals**

Create a function that generates a product card using template literals:

```javascript
const createProductCard = (name, price, inStock) => `
  <div class="product">
    <h3>${name}</h3>
    <p class="price">$${price}</p>
    <p class="status">${inStock ? "In Stock" : "Out of Stock"}</p>
  </div>
`;

console.log(createProductCard("Laptop", 999, true));
```

**Exercise 2: Default Parameters**

Create a function that calculates discounted price with optional discount:

```javascript
const calculatePrice = (price, discount = 0) => {
  return price * (1 - discount);
};

console.log(calculatePrice(100, 0.2)); // Should output: 80
console.log(calculatePrice(100));      // Should output: 100
```

**Exercise 3: Rest Operator**

Create a function that finds the maximum value from any number of arguments:

```javascript
const findMax = (...numbers) => {
  if (numbers.length === 0) return null;
  return Math.max(...numbers);
};

console.log(findMax(3, 7, 2, 9, 1)); // Should output: 9
console.log(findMax());              // Should output: null
```

## Best Practices

::illustration-checklist
---
title: ES6+ Best Practices
items:
  - text: Use template literals for any string with variables
    icon: üìù
  - text: Provide sensible defaults for optional parameters
    icon: üéØ
  - text: Use rest operator for variable-length arguments
    icon: üì¶
  - text: Combine features (template literals + default params)
    icon: üîó
  - text: Prefer ES6+ syntax over old patterns
    icon: ‚ú®
note: Modern syntax makes code cleaner and easier to maintain
color: emerald
---
::

## Common Mistakes to Avoid

1. **Mixing quotes and backticks**
   - Use backticks `` ` `` for template literals, not quotes `'` or `"`
   - `"Hello, ${name}"` won't interpolate ‚ùå
   - `` `Hello, ${name}` `` works ‚úÖ

2. **Forgetting the $ in template literals**
   - `` `Hello, {name}` `` outputs "Hello, {name}" literally ‚ùå
   - `` `Hello, ${name}` `` interpolates the variable ‚úÖ

3. **Using rest in the wrong position**
   - `function(a, ...rest, b)` ‚ùå (rest must be last)
   - `function(a, b, ...rest)` ‚úÖ

4. **Confusing rest and spread**
   - Rest: function parameters `(...args)`
   - Spread: function calls, arrays, objects `func(...arr)`

5. **Not handling edge cases with rest**
   - Always check if rest array is empty before using it
   - `...args` could be `[]` if no arguments passed

## Key Takeaways

- **Template literals** (`` ` ``) make string interpolation clean with `${}` syntax
- **Default parameters** provide fallback values when arguments are missing
- **Rest operator** (`...args`) collects variable arguments into an array
- Template literals support multi-line strings without escape characters
- Default parameters can be expressions, not just static values
- Rest must be the last parameter and you can only have one per function
- Rest collects (function params), spread expands (function calls, arrays, objects)
- ES6+ syntax is the modern standard - use it over old patterns

These ES6+ features are essential for modern JavaScript development. You'll use them constantly in frameworks like Vue, React, and Node.js. Practice combining them - template literals with default parameters, rest with array methods, etc. - to write clean, professional code.
