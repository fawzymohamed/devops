---
title: "CSS Specificity & Cascade"
description: "Master how CSS determines which styles apply through specificity calculations, the cascade algorithm, and inheritance"
difficulty: beginner
estimatedMinutes: 15
priority: essential
tags: ["css3", "specificity", "cascade", "inheritance", "web-fundamentals"]
roadmap: fullstack
phase: 1
topic: css3-mastery
learningObjectives:
  - "Calculate specificity values for CSS selectors"
  - "Understand how the cascade algorithm resolves style conflicts"
  - "Use inheritance to write more efficient stylesheets"
  - "Know when and when not to use !important"
quiz:
  passingScore: 70
  questions:
    - question: "What is the specificity of an ID selector (#header)?"
      type: single
      options:
        - "1-0-0 (100 points)"
        - "0-1-0 (10 points)"
        - "0-0-1 (1 point)"
        - "1-1-1 (111 points)"
      correctAnswer: "1-0-0 (100 points)"
      explanation: "ID selectors have specificity 1-0-0 (commonly visualized as 100 points). They're more specific than class selectors (0-1-0) and element selectors (0-0-1)."

    - question: "Which selector has the highest specificity?"
      type: single
      options:
        - "#nav .menu li"
        - ".nav .menu .item"
        - "nav ul li a"
        - "div#nav"
      correctAnswer: "#nav .menu li"
      explanation: "#nav .menu li has specificity 1-1-1 (ID + class + element). div#nav is 1-0-1, .nav .menu .item is 0-3-0, and nav ul li a is 0-0-4. The ID selector wins."

    - question: "Select all TRUE statements about CSS inheritance."
      type: multiple
      options:
        - "Font properties (font-family, font-size) are inherited"
        - "Width and height are inherited"
        - "Color is inherited"
        - "Margin and padding are inherited"
      correctAnswers:
        - "Font properties (font-family, font-size) are inherited"
        - "Color is inherited"
      explanation: "Text-related properties like font-family, font-size, color, and line-height are inherited. Box model properties like width, height, margin, and padding are NOT inherited."

    - question: "!important should be used frequently to override styles."
      type: true-false
      correctAnswer: false
      explanation: "False! !important should be used sparingly as a last resort. It breaks the natural cascade and makes CSS harder to maintain. Better approaches: increase specificity, use more specific selectors, or restructure your CSS."

    - question: "If two rules have the same specificity, which one wins?"
      type: single
      options:
        - "The one that appears last in the stylesheet"
        - "The one that appears first in the stylesheet"
        - "Neither - both are applied"
        - "The browser chooses randomly"
      correctAnswer: "The one that appears last in the stylesheet"
      explanation: "When specificity is equal, the cascade uses source order - the rule that comes last wins. This is why order matters in CSS."

    - question: "What is the specificity of an inline style (style attribute)?"
      type: single
      options:
        - "1-0-0-0 (higher than any selector)"
        - "1-0-0 (same as ID)"
        - "0-0-1 (same as element)"
        - "0 (no specificity)"
      correctAnswer: "1-0-0-0 (higher than any selector)"
      explanation: "Inline styles have the highest specificity (1-0-0-0) and override any selector-based styles. Only !important can beat inline styles."

    - question: "How do you force a child element to inherit a non-inherited property?"
      type: single
      options:
        - "Use the 'inherit' keyword as the value"
        - "Use the 'force-inherit' property"
        - "Use !important"
        - "Non-inherited properties cannot be inherited"
      correctAnswer: "Use the 'inherit' keyword as the value"
      explanation: "Any property can be set to 'inherit' to force it to use the parent's computed value. For example: border: inherit; will inherit the parent's border even though border isn't normally inherited."
---

# CSS Specificity & Cascade

Why do some CSS styles override others? Why doesn't your style apply even though you wrote it? Understanding specificity and the cascade is essential for debugging CSS and writing maintainable stylesheets.

In this lesson, you'll learn how CSS decides which styles to apply when multiple rules target the same element.

## The Cascade Algorithm

**Cascade** is the algorithm CSS uses to resolve conflicts when multiple rules apply to an element. It considers:

1. **Origin & Importance** - Where the style comes from
2. **Specificity** - How specific the selector is
3. **Source Order** - Which rule comes last

### Origin & Importance (Priority Order)

From lowest to highest priority:

1. Browser default styles (user agent)
2. User styles (browser settings)
3. Author styles (your CSS)
4. Author `!important`
5. User `!important`
6. Animations
7. Transitions

For day-to-day work, you mainly deal with author styles and occasionally `!important`.

## Specificity Explained

**Specificity** determines which rule wins when multiple selectors target the same element. Think of it as a "weight" assigned to selectors.

### Specificity Calculation

Specificity is calculated as a three-part value: **A-B-C**

| Part | Counts | Example |
|------|--------|---------|
| **A** | ID selectors | `#header`, `#nav` |
| **B** | Class, attribute, pseudo-class | `.menu`, `[type]`, `:hover` |
| **C** | Element, pseudo-element | `div`, `p`, `::before` |

**Calculate by counting each type:**

```css
/* Specificity: 0-0-1 (one element) */
p { color: black; }

/* Specificity: 0-1-0 (one class) */
.text { color: blue; }

/* Specificity: 1-0-0 (one ID) */
#intro { color: red; }

/* Specificity: 0-1-1 (one class + one element) */
p.text { color: green; }

/* Specificity: 1-1-1 (one ID + one class + one element) */
#intro .text p { color: purple; }
```

### Comparing Specificity

Compare from left to right. Higher A wins. If A is equal, compare B. If B is equal, compare C.

```css
/* 1-0-0 beats 0-10-10 */
#header { }              /* 1-0-0 - WINS */
.a.b.c.d.e.f.g.h.i.j { } /* 0-10-0 */

/* 0-2-0 beats 0-1-5 */
.menu.active { }         /* 0-2-0 - WINS */
ul li a span strong { }  /* 0-0-5 */
```

### Specificity Examples

```css
/* 0-0-1 */
div { }

/* 0-0-2 */
div p { }

/* 0-1-0 */
.card { }

/* 0-1-1 */
div.card { }

/* 0-2-0 */
.card.featured { }

/* 0-2-1 */
div.card.featured { }

/* 1-0-0 */
#header { }

/* 1-0-1 */
#header nav { }

/* 1-1-0 */
#header .menu { }

/* 1-1-2 */
#header .menu li a { }

/* 1-2-2 */
#header .menu.main li a { }
```

### Pseudo-classes and Pseudo-elements

```css
/* Pseudo-classes count as classes (B) */
a:hover { }           /* 0-1-1 */
.btn:focus { }        /* 0-2-0 */
li:nth-child(2) { }   /* 0-1-1 */

/* Pseudo-elements count as elements (C) */
p::before { }         /* 0-0-2 */
.card::after { }      /* 0-1-1 */
```

### Attribute Selectors

```css
/* Attribute selectors count as classes (B) */
[type="text"] { }          /* 0-1-0 */
input[type="text"] { }     /* 0-1-1 */
.form [required] { }       /* 0-2-0 */
```

## Source Order

When specificity is equal, the **last rule wins**:

```css
.button { color: blue; }
.button { color: red; }   /* This wins - comes last */
```

This is why the order of your CSS files and rules matters:

```html
<link rel="stylesheet" href="base.css">
<link rel="stylesheet" href="components.css">
<link rel="stylesheet" href="overrides.css">  <!-- Loaded last, can override -->
```

## Inline Styles

Inline styles (the `style` attribute) have higher specificity than any selector:

```html
<p id="intro" class="text" style="color: orange;">
  This is orange, not the colors from CSS
</p>
```

```css
#intro { color: red; }    /* 1-0-0 */
.text { color: blue; }    /* 0-1-0 */
/* Inline style wins over both */
```

**Specificity hierarchy:**
1. Inline styles (highest)
2. ID selectors
3. Class/attribute/pseudo-class selectors
4. Element/pseudo-element selectors

## The !important Rule

`!important` overrides normal specificity rules:

```css
p { color: blue !important; }  /* Wins over higher specificity */
#intro { color: red; }         /* Loses to !important */
```

### When to Use !important

**Rarely!** It's a last resort:

```css
/* OK: Utility classes that must always apply */
.visually-hidden {
  position: absolute !important;
  clip: rect(0, 0, 0, 0) !important;
}

/* OK: Overriding third-party library styles */
.third-party-widget {
  margin: 0 !important;  /* Override inline styles from library */
}
```

### When NOT to Use !important

```css
/* BAD: Lazy fix for specificity issues */
.button {
  background: blue !important;  /* Don't do this */
}

/* BETTER: Increase specificity properly */
.card .button {
  background: blue;
}
```

### !important Specificity

When multiple rules use `!important`, normal specificity rules apply among them:

```css
p { color: blue !important; }      /* 0-0-1 with !important */
.text { color: red !important; }   /* 0-1-0 with !important - WINS */
```

## Inheritance

Some CSS properties are **inherited** from parent to child elements automatically.

### Inherited Properties

Text and font properties are inherited:
- `color`
- `font-family`, `font-size`, `font-weight`, `font-style`
- `line-height`
- `letter-spacing`, `word-spacing`
- `text-align`, `text-indent`, `text-transform`
- `visibility`
- `cursor`

### Non-Inherited Properties

Box model and layout properties are NOT inherited:
- `width`, `height`
- `margin`, `padding`
- `border`
- `background`
- `display`, `position`
- `top`, `right`, `bottom`, `left`
- `overflow`

### Inheritance Example

```html
<div class="parent">
  <p>This text inherits font and color</p>
</div>
```

```css
.parent {
  color: blue;           /* Inherited by <p> */
  font-family: Arial;    /* Inherited by <p> */
  border: 1px solid red; /* NOT inherited */
  padding: 20px;         /* NOT inherited */
}
```

### Forcing Inheritance

Use `inherit` to force any property to inherit:

```css
.child {
  border: inherit;        /* Inherit parent's border */
  background: inherit;    /* Inherit parent's background */
}
```

### Special Values

```css
.element {
  color: inherit;   /* Use parent's value */
  color: initial;   /* Use CSS default (usually black for color) */
  color: unset;     /* Acts like inherit if inherited, initial if not */
  color: revert;    /* Use browser default stylesheet value */
}
```

## Practical Tips

### 1. Keep Specificity Low

Start with low specificity and increase only when needed:

```css
/* Good - low specificity, easy to override */
.button { }
.button--primary { }

/* Avoid - high specificity, hard to override */
div#container .wrapper .button { }
```

### 2. Use BEM or Similar Methodology

BEM keeps specificity flat and predictable:

```css
/* All have same specificity: 0-1-0 */
.card { }
.card__title { }
.card__title--large { }
.card--featured { }
```

### 3. Avoid ID Selectors for Styling

IDs have high specificity. Reserve them for JavaScript hooks:

```css
/* Avoid for styling */
#header { }

/* Better */
.header { }
```

### 4. Layer Your CSS

Organize from general to specific:

```css
/* 1. Reset/Base - lowest specificity */
* { box-sizing: border-box; }
body { font-family: system-ui; }

/* 2. Layout */
.container { max-width: 1200px; }

/* 3. Components */
.card { padding: 1rem; }
.button { cursor: pointer; }

/* 4. Utilities - may use !important */
.hidden { display: none !important; }
```

### 5. Debug Specificity Issues

In browser DevTools, styles are shown in specificity order. Crossed-out styles are overridden.

```css
/* DevTools shows why this doesn't apply */
.button { color: blue; }        /* Overridden by below */
#nav .button { color: red; }    /* Higher specificity wins */
```

## Common Pitfalls

### 1. Over-qualifying Selectors

```css
/* Bad - unnecessarily high specificity */
div.card { }
button.btn { }

/* Good - unless you need element specificity */
.card { }
.btn { }
```

### 2. !important Chains

```css
/* This leads to unmaintainable CSS */
.button { background: blue !important; }
.button.special { background: red !important; }
.button.special.active { background: green !important; }
/* ... and it spirals out of control */
```

### 3. Location-Dependent Styles

```css
/* Bad - tightly coupled to HTML structure */
.sidebar .card .title { }

/* Good - component-based */
.card__title { }
.card__title--sidebar { }
```

## Key Takeaways

- The **cascade** resolves style conflicts using origin, specificity, and source order
- **Specificity** is calculated as A-B-C (IDs - Classes - Elements)
- Higher specificity wins; IDs beat classes beat elements
- When specificity is equal, **last rule wins** (source order)
- **Inline styles** override any selector-based styles
- **!important** should be used sparingly - it breaks the cascade
- **Inheritance** passes text/font properties from parent to child
- Keep specificity low and consistent for maintainable CSS
- Use methodologies like BEM to avoid specificity conflicts
- Debug with browser DevTools to see which styles win

Understanding specificity and the cascade eliminates the "why isn't my CSS working?" frustration. Write clean, low-specificity selectors, and your stylesheets will be predictable and maintainable.
