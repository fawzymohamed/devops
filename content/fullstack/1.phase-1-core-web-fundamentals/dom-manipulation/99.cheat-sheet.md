---
title: "DOM Manipulation Cheat Sheet"
description: "Quick reference for selecting elements, modifying content, event handling, creating elements, DOM traversal, and performance optimization"
difficulty: beginner
estimatedMinutes: 5
priority: essential
tags: ["javascript", "dom", "cheat-sheet", "reference", "web-fundamentals"]
roadmap: fullstack
phase: 1
topic: dom-manipulation
isCheatSheet: true
cheatSheetTopic: "DOM Manipulation"
---

# DOM Manipulation Cheat Sheet

Quick reference for DOM element selection, content modification, event handling, element creation, traversal, and performance optimization.

---

## Selecting Elements

### Modern Methods (Recommended)

| Method | Returns | Example |
|--------|---------|---------|
| `querySelector(sel)` | First match or `null` | `document.querySelector('.card')` |
| `querySelectorAll(sel)` | Static NodeList | `document.querySelectorAll('p')` |
| `getElementById(id)` | Element or `null` | `document.getElementById('header')` |

### Selector Syntax

```javascript
// By tag
document.querySelector('div')

// By class (dot prefix)
document.querySelector('.card')

// By ID (hash prefix)
document.querySelector('#header')

// By attribute
document.querySelector('input[type="email"]')

// Nested/complex
document.querySelector('nav a.active')
document.querySelector('ul > li:first-child')
```

### Working with Results

```javascript
// Single element - always check for null
const el = document.querySelector('.card')
if (el) {
  el.textContent = 'Found!'
}

// Multiple elements - iterate
const items = document.querySelectorAll('.item')
items.forEach(item => {
  item.classList.add('processed')
})

// Convert NodeList to array
const arr = Array.from(items)
const filtered = arr.filter(item => item.dataset.active)
```

### Scoped Selection

```javascript
// Search within a parent
const form = document.getElementById('login-form')
const email = form.querySelector('input[type="email"]')
const submit = form.querySelector('button[type="submit"]')
```

### Legacy Methods

| Method | Returns | Note |
|--------|---------|------|
| `getElementsByClassName(class)` | Live HTMLCollection | No dot prefix |
| `getElementsByTagName(tag)` | Live HTMLCollection | Tag name only |

> **Live vs Static:** Live collections auto-update when DOM changes; static NodeLists don't.

---

## Modifying Content

### Text Content

| Property | Description | Use Case |
|----------|-------------|----------|
| `textContent` | All text (fast, safe) | User input, most cases |
| `innerText` | Visible text only | When you need rendered text |
| `innerHTML` | HTML content | Static HTML (never user input!) |

```javascript
// Safe - treats as text
element.textContent = userInput

// Dangerous - parses HTML (XSS risk!)
element.innerHTML = '<p>Static HTML only</p>'

// Get content
const text = element.textContent
const html = element.innerHTML
```

### classList Methods

| Method | Description | Returns |
|--------|-------------|---------|
| `add(cls)` | Add class(es) | void |
| `remove(cls)` | Remove class(es) | void |
| `toggle(cls)` | Add if missing, remove if present | Boolean |
| `toggle(cls, force)` | Add if force=true, remove if false | Boolean |
| `contains(cls)` | Check if has class | Boolean |
| `replace(old, new)` | Replace class | Boolean |

```javascript
el.classList.add('active', 'highlighted')
el.classList.remove('hidden')
el.classList.toggle('open')
el.classList.toggle('dark', isDarkMode)

if (el.classList.contains('active')) {
  // ...
}
```

### Attributes

```javascript
// Get/Set/Remove
el.getAttribute('href')
el.setAttribute('href', '/new-page')
el.removeAttribute('disabled')
el.hasAttribute('required')

// Direct property access (common attributes)
input.value = 'new value'
input.disabled = true
input.checked = false
img.src = 'image.jpg'
link.href = '/page'
```

### Data Attributes

```html
<div data-user-id="123" data-role="admin"></div>
```

```javascript
// Access via dataset (camelCase)
el.dataset.userId     // "123"
el.dataset.role       // "admin"

// Set data attribute
el.dataset.status = 'active'  // Creates data-status="active"

// Note: values are always strings
const id = parseInt(el.dataset.userId)
```

---

## Event Handling

### Adding Listeners

```javascript
// Basic
element.addEventListener('click', handler)

// With options
element.addEventListener('click', handler, {
  once: true,      // Remove after first call
  capture: true,   // Use capture phase
  passive: true    // Won't call preventDefault
})

// Remove listener (needs function reference)
element.removeEventListener('click', handler)
```

### Common Events

| Event | Triggered When |
|-------|----------------|
| `click` | Element clicked |
| `dblclick` | Element double-clicked |
| `submit` | Form submitted |
| `input` | Input value changes |
| `change` | Input loses focus after change |
| `keydown` | Key pressed |
| `keyup` | Key released |
| `focus` | Element receives focus |
| `blur` | Element loses focus |
| `scroll` | Element scrolled |
| `load` | Resource loaded |
| `DOMContentLoaded` | HTML parsed (before images) |

### Event Object

```javascript
element.addEventListener('click', (event) => {
  event.target        // Element that triggered event
  event.currentTarget // Element with the listener
  event.type          // Event type ("click")

  // Mouse events
  event.clientX       // X position in viewport
  event.clientY       // Y position in viewport
  event.button        // Mouse button (0=left, 2=right)

  // Keyboard events
  event.key           // Key value ("Enter", "a")
  event.code          // Physical key ("Enter", "KeyA")
  event.shiftKey      // Shift held?
  event.ctrlKey       // Ctrl held?
  event.metaKey       // Cmd/Win held?

  // Control
  event.preventDefault()   // Stop default action
  event.stopPropagation()  // Stop bubbling
})
```

### Event Delegation

```javascript
// One listener on parent handles all children
document.querySelector('.list').addEventListener('click', (e) => {
  // Check what was clicked
  if (e.target.matches('.delete-btn')) {
    const item = e.target.closest('.list-item')
    item.remove()
  }

  if (e.target.matches('.edit-btn')) {
    // Handle edit
  }
})
```

### Common Patterns

```javascript
// Prevent form submission
form.addEventListener('submit', (e) => {
  e.preventDefault()
  // Handle form data manually
})

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
  if (e.ctrlKey && e.key === 's') {
    e.preventDefault()
    save()
  }
})

// Click outside to close
modal.addEventListener('click', (e) => {
  if (e.target === modal) {
    modal.classList.add('hidden')
  }
})
```

---

## Creating & Inserting Elements

### Creating Elements

```javascript
const div = document.createElement('div')
div.className = 'card'
div.id = 'card-1'
div.textContent = 'Content'
div.dataset.id = '123'
```

### Insertion Methods

| Method | Position | Example |
|--------|----------|---------|
| `appendChild(el)` | Last child | `parent.appendChild(child)` |
| `insertBefore(el, ref)` | Before reference | `parent.insertBefore(new, ref)` |
| `append(...nodes)` | Last child(ren) | `parent.append(el1, el2, 'text')` |
| `prepend(...nodes)` | First child(ren) | `parent.prepend(el)` |
| `before(...nodes)` | Before element | `el.before(newEl)` |
| `after(...nodes)` | After element | `el.after(newEl)` |

### insertAdjacentHTML/Element

```javascript
// Positions: 'beforebegin', 'afterbegin', 'beforeend', 'afterend'

// <!-- beforebegin -->
// <div>
//   <!-- afterbegin -->
//   content
//   <!-- beforeend -->
// </div>
// <!-- afterend -->

el.insertAdjacentHTML('beforeend', '<p>New paragraph</p>')
el.insertAdjacentElement('afterbegin', newElement)
```

### Removing Elements

```javascript
// Modern (recommended)
element.remove()

// Legacy (via parent)
parent.removeChild(child)

// Clear all children
container.innerHTML = ''
container.replaceChildren()
```

### Cloning Elements

```javascript
// Shallow clone (element only)
const clone = element.cloneNode(false)

// Deep clone (with children)
const deepClone = element.cloneNode(true)

// Note: cloneNode doesn't copy event listeners
```

---

## DOM Traversal

### Parent Navigation

| Property/Method | Returns |
|-----------------|---------|
| `parentElement` | Parent element or null |
| `parentNode` | Parent node (can be document) |
| `closest(sel)` | Nearest ancestor matching selector |

```javascript
const parent = el.parentElement
const card = button.closest('.card')
const form = input.closest('form')
```

### Child Navigation

| Property | Returns |
|----------|---------|
| `children` | HTMLCollection of element children |
| `childNodes` | NodeList of all nodes (incl. text) |
| `firstElementChild` | First element child |
| `lastElementChild` | Last element child |

```javascript
const items = list.children           // Element children only
const first = list.firstElementChild
const last = list.lastElementChild
const count = list.children.length
```

### Sibling Navigation

| Property | Returns |
|----------|---------|
| `nextElementSibling` | Next element sibling |
| `previousElementSibling` | Previous element sibling |

```javascript
const next = el.nextElementSibling
const prev = el.previousElementSibling

// Iterate siblings
let current = list.firstElementChild
while (current) {
  console.log(current)
  current = current.nextElementSibling
}
```

### Checking Elements

```javascript
// Check if matches selector
el.matches('.active')
el.matches('[data-role="admin"]')

// Check if contains another element
parent.contains(child)  // true/false
```

> **Tip:** Use properties with "Element" in the name to skip text nodes: `firstElementChild` not `firstChild`.

---

## Performance Optimization

### The Problem

- **Reflow** (layout): Expensive - calculates element positions
- **Repaint**: Cheaper - redraws visual properties
- **Layout thrashing**: Alternating reads/writes forces multiple reflows

### DocumentFragment (Batch Insertions)

```javascript
const fragment = document.createDocumentFragment()

// Build in memory (no reflows)
for (let i = 0; i < 100; i++) {
  const item = document.createElement('li')
  item.textContent = `Item ${i}`
  fragment.appendChild(item)
}

// One reflow when inserted
list.appendChild(fragment)
```

### Batch Reads, Then Writes

```javascript
// Bad - layout thrashing
boxes.forEach(box => {
  const h = box.offsetHeight  // Read
  box.style.height = h + 10   // Write (invalidates)
  // Next read forces reflow!
})

// Good - batch reads, then writes
const heights = Array.from(boxes).map(b => b.offsetHeight)
boxes.forEach((box, i) => {
  box.style.height = heights[i] + 10 + 'px'
})
```

### requestAnimationFrame

```javascript
// Schedule visual updates for next repaint
function animate() {
  element.style.transform = `translateX(${x}px)`
  x += 2

  if (x < 500) {
    requestAnimationFrame(animate)
  }
}
requestAnimationFrame(animate)
```

### Debouncing (Wait for Pause)

```javascript
function debounce(fn, delay) {
  let timeout
  return (...args) => {
    clearTimeout(timeout)
    timeout = setTimeout(() => fn(...args), delay)
  }
}

// Use for search input
const search = debounce(query => {
  // Runs 300ms after typing stops
  fetchResults(query)
}, 300)

input.addEventListener('input', e => search(e.target.value))
```

### Throttling (Limit Frequency)

```javascript
function throttle(fn, limit) {
  let inThrottle
  return (...args) => {
    if (!inThrottle) {
      fn(...args)
      inThrottle = true
      setTimeout(() => inThrottle = false, limit)
    }
  }
}

// Use for scroll events
const handleScroll = throttle(() => {
  // Runs at most once per 100ms
  updatePosition()
}, 100)

window.addEventListener('scroll', handleScroll)
```

### Performance Best Practices

| Do | Don't |
|----|----|
| Cache DOM references | Re-query repeatedly |
| Use DocumentFragment for bulk inserts | appendChild in a loop |
| Batch reads, then batch writes | Alternate reads and writes |
| Use event delegation | Add listeners to many elements |
| Debounce/throttle frequent events | Handle every scroll/resize |
| Animate `transform`, `opacity` | Animate `width`, `height`, `top` |

---

## Quick Reference

### Selection Cheat Sheet

```javascript
document.querySelector('.class')      // First match
document.querySelectorAll('.class')   // All matches
document.getElementById('id')         // By ID (fastest)
parent.querySelector('.child')        // Scoped search
```

### Modification Cheat Sheet

```javascript
el.textContent = 'Safe text'          // Set text (safe)
el.innerHTML = '<p>HTML</p>'          // Set HTML (careful!)
el.classList.add('active')            // Add class
el.classList.toggle('open')           // Toggle class
el.setAttribute('href', '/page')      // Set attribute
el.dataset.userId = '123'             // Set data attribute
```

### Event Cheat Sheet

```javascript
el.addEventListener('click', fn)      // Add listener
e.preventDefault()                    // Stop default
e.stopPropagation()                   // Stop bubbling
e.target                              // What was clicked
e.target.closest('.card')             // Find parent
e.target.matches('.btn')              // Check selector
```

### Traversal Cheat Sheet

```javascript
el.parentElement                      // Parent
el.children                           // Child elements
el.firstElementChild                  // First child
el.nextElementSibling                 // Next sibling
el.closest('.ancestor')               // Find ancestor
el.contains(other)                    // Contains check
```

## Interview Quick Hits

| Question | Answer |
|----------|--------|
| What's the difference between `textContent` and `innerHTML`? | `textContent` sets plain text safely; `innerHTML` parses HTML which can cause XSS if used with user input |
| What is event delegation? | Attaching one listener to a parent element to handle events from all children, using `e.target` to identify the source |
| What is event bubbling? | Events propagate up from the target element through ancestors; use `stopPropagation()` to prevent it |
| What's the difference between `e.target` and `e.currentTarget`? | `target` is the element that triggered the event; `currentTarget` is the element with the listener |
| What is layout thrashing? | Performance issue caused by alternating DOM reads and writes, forcing multiple reflows |
| What is a DocumentFragment? | A lightweight container for building DOM in memory before inserting, avoiding multiple reflows |

### Common Mistakes to Avoid

- Using `getElementById('#id')` - no hash needed
- Using `querySelector('class')` - needs dot for class
- Not checking for `null` after querySelector
- Using `innerHTML` with user input (XSS risk)
- Adding listeners in loops (use delegation)
- Forgetting `preventDefault()` on forms
- Reading/writing DOM alternately (layout thrashing)
