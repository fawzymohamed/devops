---
title: "Modifying Content"
description: "Learn to modify DOM elements using innerHTML, textContent, classList, and attributes for dynamic web pages"
difficulty: beginner
estimatedMinutes: 14
priority: essential
tags: ["javascript", "dom", "content-manipulation", "web-fundamentals"]
roadmap: fullstack
phase: 1
topic: dom-manipulation
learningObjectives:
  - "Modify text content safely using textContent and innerText"
  - "Understand the security risks of innerHTML and when to use it"
  - "Manage CSS classes dynamically with classList methods"
  - "Read and write element attributes and data attributes"
quiz:
  passingScore: 70
  questions:
    - question: "What is the main security risk of using innerHTML?"
      type: single
      options:
        - "Cross-site scripting (XSS) attacks if user input is inserted"
        - "It's slower than textContent"
        - "It doesn't work in all browsers"
        - "It removes event listeners"
      correctAnswer: "Cross-site scripting (XSS) attacks if user input is inserted"
      explanation: "innerHTML parses content as HTML, so malicious scripts in user input could be executed. Always sanitize user input or use textContent for plain text."

    - question: "Which classList method adds a class only if it doesn't already exist?"
      type: single
      options:
        - "add()"
        - "toggle()"
        - "replace()"
        - "contains()"
      correctAnswer: "add()"
      explanation: "classList.add() is safe to call multiple times - it adds the class only if it's not already present. It doesn't duplicate classes."

    - question: "Select all TRUE statements about textContent vs innerHTML."
      type: multiple
      options:
        - "textContent is safer for user input"
        - "innerHTML can render HTML tags"
        - "textContent is faster than innerHTML"
        - "innerHTML is always preferred"
      correctAnswers:
        - "textContent is safer for user input"
        - "innerHTML can render HTML tags"
        - "textContent is faster than innerHTML"
      explanation: "textContent is safer (treats content as text), faster (no HTML parsing), but cannot render HTML. innerHTML can render HTML but is risky with user input."

    - question: "How do you access a data attribute called 'user-id' on an element?"
      type: single
      options:
        - "element.dataset.userId"
        - "element.data.userId"
        - "element.getAttribute('userId')"
        - "element.dataset['user-id']"
      correctAnswer: "element.dataset.userId"
      explanation: "Data attributes like data-user-id are accessed via dataset with camelCase conversion: dataset.userId. The hyphen is removed and the next letter is capitalized."

    - question: "classList.toggle() returns a boolean indicating whether the class is now present."
      type: true-false
      correctAnswer: true
      explanation: "True! toggle() returns true if the class was added, false if it was removed. This is useful for conditional logic based on the toggle state."
---

# Modifying Content

Once you've selected an element, you can change its content, styling, and attributes. JavaScript gives you full control over what users see on the page. You can update text, add HTML, change classes, and modify attributes.

In this lesson, you'll learn the different ways to modify element content and when to use each approach.

## Changing Text Content

The most common modification is changing text. JavaScript offers two main properties for this.

### textContent - Safe and Fast

`textContent` sets or gets the text content of an element. It's the safest and fastest way to work with text.

```javascript
const heading = document.querySelector('h1')

// Get the current text
console.log(heading.textContent) // "Hello World"

// Set new text
heading.textContent = 'Welcome!'

// HTML tags are treated as text, not rendered
heading.textContent = '<em>Hello</em>' // Shows: <em>Hello</em>
```

**Key Points:**
- Returns all text, including hidden elements
- Does NOT parse HTML (safer for user input)
- Faster than innerHTML

### innerText - Visual Text Only

`innerText` is similar but only returns text that's visually rendered.

```javascript
const element = document.querySelector('.content')

// innerText respects CSS styling
// Hidden elements are not included
console.log(element.innerText)
```

**Difference from textContent:**

```html
<div class="content">
  Visible text
  <span style="display: none">Hidden text</span>
</div>
```

```javascript
const element = document.querySelector('.content')

// textContent includes hidden text
console.log(element.textContent) // "Visible text Hidden text"

// innerText only includes visible text
console.log(element.innerText) // "Visible text"
```

**When to use:**
- Use **textContent** for most cases (faster, includes all text)
- Use **innerText** when you only want visible text

## Changing HTML Content

### innerHTML - Render HTML

`innerHTML` sets or gets the HTML content of an element. It parses HTML and renders it.

```javascript
const container = document.querySelector('.container')

// Get current HTML
console.log(container.innerHTML)

// Set new HTML content
container.innerHTML = '<p>New paragraph</p>'

// Add HTML with formatting
container.innerHTML = `
  <h2>Title</h2>
  <p>This is <strong>bold</strong> text.</p>
  <ul>
    <li>Item 1</li>
    <li>Item 2</li>
  </ul>
`
```

### Security Warning - XSS Attacks

**Never use innerHTML with user input!** It can execute malicious scripts.

```javascript
// DANGEROUS - Never do this!
const userInput = '<script>alert("Hacked!")</script>'
element.innerHTML = userInput // Script could execute!

// Also dangerous
const username = '<img src="x" onerror="stealData()">'
element.innerHTML = `Welcome, ${username}` // Executes the onerror
```

::illustration-checklist
---
title: innerHTML Safety Rules
items:
  - text: Never insert user input directly
    icon: X
  - text: Sanitize HTML before inserting
    icon: S
  - text: Use textContent for plain text
    icon: T
  - text: Consider template literals for static HTML
    icon: L
note: XSS attacks can steal user data and session cookies
color: rose
---
::

**Safe Alternative:**

```javascript
// Safe - user input treated as text
const username = '<script>bad code</script>'
element.textContent = `Welcome, ${username}`
// Shows: Welcome, <script>bad code</script>
```

### outerHTML - Replace the Element Itself

`outerHTML` replaces the entire element, including its tag.

```javascript
const item = document.querySelector('.old-item')

// Replace the element completely
item.outerHTML = '<div class="new-item">New content</div>'
```

## Working with Classes

CSS classes control styling. The `classList` property provides methods to manage classes.

### Adding Classes

```javascript
const button = document.querySelector('button')

// Add one class
button.classList.add('active')

// Add multiple classes
button.classList.add('primary', 'large', 'rounded')
```

### Removing Classes

```javascript
const card = document.querySelector('.card')

// Remove one class
card.classList.remove('hidden')

// Remove multiple classes
card.classList.remove('old', 'deprecated', 'unused')
```

### Toggling Classes

`toggle` adds the class if missing, removes it if present.

```javascript
const menu = document.querySelector('.menu')

// Toggle visibility
menu.classList.toggle('open')

// toggle returns true if class was added
const isNowOpen = menu.classList.toggle('open')
console.log(isNowOpen) // true or false

// Conditional toggle - add only if condition is true
menu.classList.toggle('dark-mode', isDarkMode)
```

### Checking for Classes

```javascript
const element = document.querySelector('.element')

// Check if class exists
if (element.classList.contains('active')) {
  console.log('Element is active')
}
```

### Replacing Classes

```javascript
const button = document.querySelector('button')

// Replace one class with another
button.classList.replace('loading', 'complete')
```

### Practical Class Examples

**Toggle Dark Mode:**

```javascript
const toggleButton = document.getElementById('theme-toggle')
const body = document.body

toggleButton.addEventListener('click', () => {
  body.classList.toggle('dark-mode')

  // Update button text based on state
  const isDark = body.classList.contains('dark-mode')
  toggleButton.textContent = isDark ? 'Light Mode' : 'Dark Mode'
})
```

**Active Navigation Link:**

```javascript
const navLinks = document.querySelectorAll('nav a')

navLinks.forEach(link => {
  link.addEventListener('click', (e) => {
    // Remove active from all links
    navLinks.forEach(l => l.classList.remove('active'))

    // Add active to clicked link
    e.target.classList.add('active')
  })
})
```

**Loading State:**

```javascript
const form = document.querySelector('form')
const submitBtn = form.querySelector('button[type="submit"]')

form.addEventListener('submit', async (e) => {
  e.preventDefault()

  // Show loading state
  submitBtn.classList.add('loading')
  submitBtn.disabled = true

  await submitFormData(form)

  // Remove loading state
  submitBtn.classList.remove('loading')
  submitBtn.disabled = false
})
```

## Working with Attributes

Elements have attributes like `src`, `href`, `disabled`, etc. JavaScript can read and modify these.

### Getting Attributes

```javascript
const link = document.querySelector('a')
const image = document.querySelector('img')

// Get attribute values
const href = link.getAttribute('href')
const src = image.getAttribute('src')
const alt = image.getAttribute('alt')

console.log(href)  // "/about"
console.log(src)   // "photo.jpg"
```

### Setting Attributes

```javascript
const link = document.querySelector('a')
const image = document.querySelector('img')

// Set attribute values
link.setAttribute('href', '/new-page')
link.setAttribute('target', '_blank')

image.setAttribute('src', 'new-image.jpg')
image.setAttribute('alt', 'New description')
```

### Removing Attributes

```javascript
const button = document.querySelector('button')

// Remove an attribute
button.removeAttribute('disabled')
```

### Checking Attributes

```javascript
const input = document.querySelector('input')

// Check if attribute exists
if (input.hasAttribute('required')) {
  console.log('This field is required')
}
```

### Direct Property Access

Some attributes can be accessed directly as properties:

```javascript
const input = document.querySelector('input')
const checkbox = document.querySelector('input[type="checkbox"]')
const link = document.querySelector('a')

// These work as properties
input.value = 'New value'
input.disabled = true
input.placeholder = 'Enter text...'

checkbox.checked = true

link.href = '/about'

// Boolean attributes
const button = document.querySelector('button')
button.disabled = true  // Adds disabled attribute
button.disabled = false // Removes disabled attribute
```

## Data Attributes

Custom data attributes store extra information on elements. They start with `data-`.

```html
<div class="user-card"
     data-user-id="123"
     data-role="admin"
     data-last-login="2024-01-15">
  <h3>John Doe</h3>
</div>
```

### Reading Data Attributes

Use the `dataset` property. Attribute names are converted to camelCase.

```javascript
const card = document.querySelector('.user-card')

// data-user-id becomes dataset.userId
console.log(card.dataset.userId)    // "123"
console.log(card.dataset.role)      // "admin"
console.log(card.dataset.lastLogin) // "2024-01-15"
```

### Setting Data Attributes

```javascript
const card = document.querySelector('.user-card')

// Set data attributes
card.dataset.userId = '456'
card.dataset.status = 'active'
// Creates: data-status="active"
```

### Practical Data Attribute Example

**Product Cards with Details:**

```html
<div class="product"
     data-product-id="prod-001"
     data-price="29.99"
     data-stock="15">
  <h3>Product Name</h3>
  <button class="add-to-cart">Add to Cart</button>
</div>
```

```javascript
const products = document.querySelectorAll('.product')

products.forEach(product => {
  const button = product.querySelector('.add-to-cart')

  button.addEventListener('click', () => {
    const productId = product.dataset.productId
    const price = parseFloat(product.dataset.price)
    const stock = parseInt(product.dataset.stock)

    if (stock > 0) {
      addToCart(productId, price)
      product.dataset.stock = stock - 1
    }
  })
})
```

## Practical Examples

### Example 1: Update Counter Display

```javascript
let count = 0
const display = document.querySelector('.count-display')
const incrementBtn = document.getElementById('increment')
const decrementBtn = document.getElementById('decrement')

incrementBtn.addEventListener('click', () => {
  count++
  display.textContent = count
})

decrementBtn.addEventListener('click', () => {
  count--
  display.textContent = count
})
```

### Example 2: Form Error Messages

```javascript
function showError(inputId, message) {
  const input = document.getElementById(inputId)
  const errorSpan = input.nextElementSibling

  input.classList.add('error')
  errorSpan.textContent = message
  errorSpan.classList.remove('hidden')
}

function clearError(inputId) {
  const input = document.getElementById(inputId)
  const errorSpan = input.nextElementSibling

  input.classList.remove('error')
  errorSpan.textContent = ''
  errorSpan.classList.add('hidden')
}
```

### Example 3: Dynamic Image Gallery

```javascript
const thumbnails = document.querySelectorAll('.thumbnail')
const mainImage = document.getElementById('main-image')
const caption = document.getElementById('caption')

thumbnails.forEach(thumb => {
  thumb.addEventListener('click', () => {
    // Update main image
    mainImage.src = thumb.dataset.fullsize
    mainImage.alt = thumb.alt

    // Update caption
    caption.textContent = thumb.dataset.caption

    // Update active state
    thumbnails.forEach(t => t.classList.remove('active'))
    thumb.classList.add('active')
  })
})
```

## Best Practices

1. **Use textContent for user-generated content**
   - Prevents XSS attacks
   - Faster than innerHTML

2. **Cache element references**
   - Don't re-select elements repeatedly
   - Store in variables for reuse

3. **Use classList methods**
   - Cleaner than manipulating className directly
   - add/remove/toggle are easier to read

4. **Prefer data attributes over hidden inputs**
   - Cleaner HTML
   - Easier to access in JavaScript

5. **Validate before modifying**
   - Check if element exists
   - Verify data types

## Common Mistakes to Avoid

1. **Using innerHTML with user input**

```javascript
// Dangerous!
element.innerHTML = userInput

// Safe
element.textContent = userInput
```

2. **Overwriting entire classList**

```javascript
// Bad - removes all existing classes
element.className = 'new-class'

// Good - only adds the new class
element.classList.add('new-class')
```

3. **Forgetting to parse data attribute values**

```javascript
const price = element.dataset.price // "29.99" (string)

// Remember to convert
const priceNum = parseFloat(element.dataset.price) // 29.99 (number)
```

## Key Takeaways

- **textContent** sets plain text safely and quickly
- **innerHTML** can render HTML but is dangerous with user input
- **classList** provides add, remove, toggle, contains, and replace methods
- **getAttribute/setAttribute** work with any attribute
- **dataset** accesses data-* attributes in camelCase
- Always **sanitize user input** before using innerHTML
- **Cache** element references for better performance

In the next lesson, you'll learn about event handling - how to respond to user actions like clicks, typing, and form submissions.
