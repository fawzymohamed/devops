---
title: "Event Handling"
description: "Master event handling with addEventListener, event delegation, and bubbling for interactive web applications"
difficulty: beginner
estimatedMinutes: 18
priority: essential
tags: ["javascript", "dom", "events", "event-delegation", "web-fundamentals"]
roadmap: fullstack
phase: 1
topic: dom-manipulation
learningObjectives:
  - "Attach event listeners using addEventListener"
  - "Work with the event object to access event details"
  - "Understand event bubbling and capturing phases"
  - "Implement event delegation for efficient handling"
quiz:
  passingScore: 70
  questions:
    - question: "What does event.preventDefault() do?"
      type: single
      options:
        - "Stops the default browser action (like form submission)"
        - "Stops the event from bubbling up"
        - "Removes all event listeners"
        - "Prevents the event from being created"
      correctAnswer: "Stops the default browser action (like form submission)"
      explanation: "preventDefault() stops the browser's default action for an event. For example, it prevents form submission, link navigation, or checkbox toggling."

    - question: "In which direction does event bubbling propagate?"
      type: single
      options:
        - "From the target element up to the document"
        - "From the document down to the target element"
        - "Only within the target element"
        - "In both directions simultaneously"
      correctAnswer: "From the target element up to the document"
      explanation: "Bubbling propagates from the target (innermost element) up through its ancestors to the document. This is why parent elements can catch events from their children."

    - question: "Select all TRUE statements about event delegation."
      type: multiple
      options:
        - "It uses one event listener on a parent element"
        - "It works because of event bubbling"
        - "It handles dynamically added elements automatically"
        - "It requires more event listeners than direct binding"
      correctAnswers:
        - "It uses one event listener on a parent element"
        - "It works because of event bubbling"
        - "It handles dynamically added elements automatically"
      explanation: "Event delegation uses a single listener on a parent to handle events from children via bubbling. It's efficient and works with dynamically added elements."

    - question: "What does event.stopPropagation() do?"
      type: single
      options:
        - "Prevents the event from bubbling to parent elements"
        - "Prevents the default browser action"
        - "Removes the event listener"
        - "Stops all events on the page"
      correctAnswer: "Prevents the event from bubbling to parent elements"
      explanation: "stopPropagation() stops the event from continuing to bubble up (or capture down). Parent elements won't receive the event."

    - question: "You can add multiple event listeners to the same element for the same event type."
      type: true-false
      correctAnswer: true
      explanation: "True! addEventListener allows multiple listeners for the same event. Each listener runs independently, unlike the older onclick property which could only hold one handler."

    - question: "How do you identify the clicked element when using event delegation?"
      type: single
      options:
        - "event.target"
        - "event.currentTarget"
        - "this"
        - "event.element"
      correctAnswer: "event.target"
      explanation: "event.target refers to the actual element that was clicked (the origin of the event). event.currentTarget refers to the element the listener is attached to."
---

# Event Handling

Events are how JavaScript responds to user actions. When users click, type, scroll, or interact with your page, the browser fires events. Event handling lets you run code in response to these actions, making your pages interactive.

In this lesson, you'll learn how to listen for events, work with event data, and use event delegation for efficient handling.

## What Are Events?

Events are signals that something happened in the browser. They can come from:
- User actions (clicks, key presses, mouse movements)
- Browser actions (page load, resize, scroll)
- API responses (fetch complete, WebSocket message)

Common events include:

| Event | Triggered When |
|-------|----------------|
| `click` | Element is clicked |
| `submit` | Form is submitted |
| `keydown` | Key is pressed |
| `input` | Input value changes |
| `focus` | Element receives focus |
| `blur` | Element loses focus |
| `load` | Resource finishes loading |
| `scroll` | Element is scrolled |

## Adding Event Listeners

The `addEventListener` method attaches a function to run when an event occurs.

**Syntax:**

```javascript
element.addEventListener('eventType', handlerFunction)
```

**Basic Examples:**

```javascript
const button = document.querySelector('button')

// Click event
button.addEventListener('click', () => {
  console.log('Button clicked!')
})

// With a named function
function handleClick() {
  console.log('Button clicked!')
}

button.addEventListener('click', handleClick)
```

### Multiple Listeners

You can add multiple listeners to the same element:

```javascript
const button = document.querySelector('button')

button.addEventListener('click', () => {
  console.log('First listener')
})

button.addEventListener('click', () => {
  console.log('Second listener')
})

// Both run when button is clicked
```

### Removing Event Listeners

To remove a listener, you need a reference to the original function:

```javascript
function handleClick() {
  console.log('Clicked!')
}

// Add listener
button.addEventListener('click', handleClick)

// Remove listener
button.removeEventListener('click', handleClick)
```

**Note:** Anonymous functions cannot be removed because you don't have a reference to them.

```javascript
// Cannot remove this later!
button.addEventListener('click', () => {
  console.log('Anonymous function')
})
```

## The Event Object

Event handlers receive an event object with information about the event.

```javascript
button.addEventListener('click', (event) => {
  console.log(event.type)        // "click"
  console.log(event.target)      // The clicked element
  console.log(event.currentTarget) // Element with the listener
})
```

### Important Event Properties

| Property | Description |
|----------|-------------|
| `event.target` | Element that triggered the event |
| `event.currentTarget` | Element the listener is attached to |
| `event.type` | Type of event ("click", "submit", etc.) |
| `event.timeStamp` | When the event occurred |

### Mouse Event Properties

```javascript
element.addEventListener('click', (event) => {
  console.log(event.clientX)  // X position in viewport
  console.log(event.clientY)  // Y position in viewport
  console.log(event.button)   // Which mouse button (0=left, 2=right)
})
```

### Keyboard Event Properties

```javascript
input.addEventListener('keydown', (event) => {
  console.log(event.key)      // The key pressed ("a", "Enter", "Escape")
  console.log(event.code)     // Physical key ("KeyA", "Enter")
  console.log(event.shiftKey) // true if Shift was held
  console.log(event.ctrlKey)  // true if Ctrl was held
})
```

## Preventing Default Behavior

Some events have default browser behavior. `preventDefault()` stops it.

::illustration-linear-flow
---
steps:
  - label: Event Fires
    sublabel: "User clicks link"
    icon: "!"
    color: violet
  - label: Handler Runs
    sublabel: "Your code executes"
    icon: ">"
    color: blue
  - label: preventDefault()
    sublabel: "Stop navigation"
    icon: X
    color: rose
  - label: Custom Action
    sublabel: "Your behavior"
    icon: V
    color: emerald
---
::

**Common Use Cases:**

```javascript
// Prevent form submission (handle with JavaScript instead)
form.addEventListener('submit', (event) => {
  event.preventDefault()

  // Validate and submit via fetch
  const formData = new FormData(form)
  submitForm(formData)
})

// Prevent link navigation
link.addEventListener('click', (event) => {
  event.preventDefault()

  // Handle navigation yourself
  loadPage(link.href)
})

// Prevent default key behavior
input.addEventListener('keydown', (event) => {
  if (event.key === 'Enter') {
    event.preventDefault()
    // Custom Enter key behavior
    searchItems(input.value)
  }
})
```

## Event Bubbling

When an event occurs on an element, it first runs handlers on that element, then on its parent, then up through all ancestors. This is called **bubbling**.

```html
<div class="outer">
  <div class="inner">
    <button>Click me</button>
  </div>
</div>
```

```javascript
document.querySelector('.outer').addEventListener('click', () => {
  console.log('Outer clicked')
})

document.querySelector('.inner').addEventListener('click', () => {
  console.log('Inner clicked')
})

document.querySelector('button').addEventListener('click', () => {
  console.log('Button clicked')
})

// Clicking the button logs:
// "Button clicked"
// "Inner clicked"
// "Outer clicked"
```

### Stopping Propagation

Use `stopPropagation()` to prevent the event from bubbling:

```javascript
button.addEventListener('click', (event) => {
  event.stopPropagation()
  console.log('Button clicked')
  // Parent handlers won't run
})
```

### target vs currentTarget

When events bubble, these properties differ:

```javascript
document.querySelector('.outer').addEventListener('click', (event) => {
  console.log('target:', event.target)       // The actual clicked element
  console.log('currentTarget:', event.currentTarget) // .outer
})
```

If you click the button:
- `event.target` = the button (what was clicked)
- `event.currentTarget` = .outer (where the listener is)

## Event Delegation

Event delegation uses bubbling to handle events efficiently. Instead of adding listeners to many elements, add one listener to their parent.

**Without Delegation (Inefficient):**

```javascript
// Bad - adds listener to every item
const items = document.querySelectorAll('.list-item')

items.forEach(item => {
  item.addEventListener('click', () => {
    item.classList.toggle('selected')
  })
})
```

**With Delegation (Efficient):**

```javascript
// Good - one listener on the parent
const list = document.querySelector('.list')

list.addEventListener('click', (event) => {
  // Check if a list item was clicked
  if (event.target.classList.contains('list-item')) {
    event.target.classList.toggle('selected')
  }
})
```

### Benefits of Delegation

::illustration-checklist
---
title: Event Delegation Benefits
items:
  - text: Uses less memory (fewer listeners)
    icon: 1
  - text: Works with dynamically added elements
    icon: 2
  - text: Less code to write and maintain
    icon: 3
  - text: Faster initial page load
    icon: 4
note: Use delegation when handling events on many similar elements
color: emerald
---
::

### Handling Dynamic Elements

Delegation works automatically for elements added later:

```javascript
const todoList = document.querySelector('.todo-list')

// This handles all items, even ones added later
todoList.addEventListener('click', (event) => {
  if (event.target.classList.contains('delete-btn')) {
    const todoItem = event.target.closest('.todo-item')
    todoItem.remove()
  }
})

// Add new items - they work automatically!
function addTodo(text) {
  const item = document.createElement('li')
  item.className = 'todo-item'
  item.innerHTML = `
    <span>${text}</span>
    <button class="delete-btn">Delete</button>
  `
  todoList.appendChild(item)
}
```

### Using closest() for Better Targeting

The `closest()` method finds the nearest ancestor matching a selector:

```javascript
document.querySelector('.card-container').addEventListener('click', (event) => {
  // Find the clicked card, even if user clicked a child element
  const card = event.target.closest('.card')

  if (card) {
    // Do something with the card
    card.classList.add('selected')
  }
})
```

## Common Event Patterns

### Form Handling

```javascript
const form = document.getElementById('login-form')

form.addEventListener('submit', async (event) => {
  event.preventDefault()

  const email = form.querySelector('#email').value
  const password = form.querySelector('#password').value

  try {
    const response = await login(email, password)
    showSuccess('Logged in!')
  } catch (error) {
    showError(error.message)
  }
})
```

### Real-time Input Validation

```javascript
const emailInput = document.getElementById('email')
const errorMessage = document.querySelector('.error-message')

emailInput.addEventListener('input', (event) => {
  const email = event.target.value
  const isValid = email.includes('@') && email.includes('.')

  if (!isValid && email.length > 0) {
    errorMessage.textContent = 'Please enter a valid email'
    emailInput.classList.add('invalid')
  } else {
    errorMessage.textContent = ''
    emailInput.classList.remove('invalid')
  }
})
```

### Keyboard Shortcuts

```javascript
document.addEventListener('keydown', (event) => {
  // Ctrl+S to save
  if (event.ctrlKey && event.key === 's') {
    event.preventDefault()
    saveDocument()
  }

  // Escape to close modal
  if (event.key === 'Escape') {
    closeModal()
  }
})
```

### Click Outside to Close

```javascript
const modal = document.querySelector('.modal')
const modalContent = document.querySelector('.modal-content')

modal.addEventListener('click', (event) => {
  // Only close if clicking the overlay, not the content
  if (event.target === modal) {
    modal.classList.add('hidden')
  }
})
```

## Practical Examples

### Example 1: Tab System

```html
<div class="tabs">
  <button class="tab active" data-tab="tab1">Tab 1</button>
  <button class="tab" data-tab="tab2">Tab 2</button>
  <button class="tab" data-tab="tab3">Tab 3</button>
</div>
<div class="tab-content">
  <div id="tab1" class="panel active">Content 1</div>
  <div id="tab2" class="panel">Content 2</div>
  <div id="tab3" class="panel">Content 3</div>
</div>
```

```javascript
const tabContainer = document.querySelector('.tabs')
const panels = document.querySelectorAll('.panel')

tabContainer.addEventListener('click', (event) => {
  if (!event.target.classList.contains('tab')) return

  // Update active tab
  tabContainer.querySelectorAll('.tab').forEach(tab => {
    tab.classList.remove('active')
  })
  event.target.classList.add('active')

  // Show corresponding panel
  const tabId = event.target.dataset.tab
  panels.forEach(panel => {
    panel.classList.toggle('active', panel.id === tabId)
  })
})
```

### Example 2: Dropdown Menu

```javascript
const dropdown = document.querySelector('.dropdown')
const dropdownToggle = dropdown.querySelector('.dropdown-toggle')
const dropdownMenu = dropdown.querySelector('.dropdown-menu')

dropdownToggle.addEventListener('click', (event) => {
  event.stopPropagation()
  dropdownMenu.classList.toggle('open')
})

// Close when clicking outside
document.addEventListener('click', () => {
  dropdownMenu.classList.remove('open')
})
```

### Example 3: Infinite Scroll

```javascript
window.addEventListener('scroll', () => {
  const { scrollTop, scrollHeight, clientHeight } = document.documentElement

  // When user scrolls to bottom
  if (scrollTop + clientHeight >= scrollHeight - 100) {
    loadMoreContent()
  }
})
```

## Best Practices

1. **Use event delegation for lists**
   - One listener instead of many
   - Handles dynamic elements

2. **Remove listeners when done**
   - Prevents memory leaks
   - Use named functions so you can remove them

3. **Use preventDefault() and stopPropagation() carefully**
   - Only when needed
   - Can break expected behavior

4. **Debounce frequent events**
   - scroll, resize, input events fire rapidly
   - Use debouncing to limit handler calls

5. **Check event.target before acting**
   - Especially with delegation
   - Use closest() to find parent elements

## Common Mistakes to Avoid

1. **Adding listeners in loops without delegation**

```javascript
// Bad
items.forEach(item => item.addEventListener('click', handler))

// Good - use delegation
container.addEventListener('click', (e) => {
  if (e.target.matches('.item')) handler(e)
})
```

2. **Forgetting to prevent default on forms**

```javascript
// Form submits and page reloads!
form.addEventListener('submit', () => {
  validateForm()
})

// Correct
form.addEventListener('submit', (event) => {
  event.preventDefault()
  validateForm()
})
```

3. **Using anonymous functions when you need to remove them**

```javascript
// Cannot remove later
element.addEventListener('click', () => {})

// Can remove
const handler = () => {}
element.addEventListener('click', handler)
element.removeEventListener('click', handler)
```

## Key Takeaways

- **addEventListener** attaches event handlers to elements
- The **event object** contains information about the event (target, type, etc.)
- **preventDefault()** stops default browser actions
- **stopPropagation()** prevents event bubbling
- Events **bubble up** from target to ancestors
- **event.target** is what was clicked; **event.currentTarget** is where the listener is
- **Event delegation** uses one listener on a parent to handle many children
- Use **closest()** to find ancestor elements when delegating

In the next lesson, you'll learn how to create new elements and add them to the DOM dynamically.
