---
title: "DOM Performance"
description: "Optimize DOM operations with DocumentFragment, requestAnimationFrame, and batch updates for smooth, fast web applications"
difficulty: intermediate
estimatedMinutes: 16
priority: essential
tags: ["javascript", "dom", "performance", "optimization", "web-fundamentals"]
roadmap: fullstack
phase: 1
topic: dom-manipulation
learningObjectives:
  - "Understand reflow and repaint and how they impact performance"
  - "Use DocumentFragment to batch DOM insertions efficiently"
  - "Schedule visual updates with requestAnimationFrame"
  - "Apply optimization techniques to minimize layout thrashing"
quiz:
  passingScore: 70
  questions:
    - question: "What is 'layout thrashing' in DOM manipulation?"
      type: single
      options:
        - "Reading and writing layout properties alternately, causing multiple reflows"
        - "Adding too many elements to the page"
        - "Using innerHTML instead of textContent"
        - "Removing elements too quickly"
      correctAnswer: "Reading and writing layout properties alternately, causing multiple reflows"
      explanation: "Layout thrashing occurs when you read a layout property (like offsetHeight), then write to the DOM, then read again. Each read after a write forces a synchronous reflow."

    - question: "When should you use requestAnimationFrame?"
      type: single
      options:
        - "For visual updates that should sync with the browser's refresh rate"
        - "For making API calls"
        - "For handling form submissions"
        - "For all JavaScript operations"
      correctAnswer: "For visual updates that should sync with the browser's refresh rate"
      explanation: "requestAnimationFrame schedules code to run before the next repaint, typically 60 times per second. It's ideal for animations and visual updates."

    - question: "Select all techniques that reduce reflows."
      type: multiple
      options:
        - "Using DocumentFragment for batch insertions"
        - "Caching DOM references in variables"
        - "Reading layout properties before making changes"
        - "Adding elements one at a time"
      correctAnswers:
        - "Using DocumentFragment for batch insertions"
        - "Caching DOM references in variables"
        - "Reading layout properties before making changes"
      explanation: "DocumentFragment batches insertions into one reflow. Caching prevents repeated queries. Reading all values first, then writing, prevents layout thrashing."

    - question: "What does 'debouncing' an event handler do?"
      type: single
      options:
        - "Delays execution until the event stops firing for a specified time"
        - "Runs the handler immediately every time"
        - "Prevents the event from bubbling"
        - "Caches the event object"
      correctAnswer: "Delays execution until the event stops firing for a specified time"
      explanation: "Debouncing waits until events stop firing for a delay period before executing. This is useful for search inputs, resize handlers, and other frequently-firing events."

    - question: "classList.toggle() is faster than setting className directly because it doesn't cause reflow."
      type: true-false
      correctAnswer: false
      explanation: "False! Both can cause reflow depending on what styles the class affects. However, classList methods are safer because they don't accidentally remove other classes."

    - question: "Which property does NOT cause a reflow when read?"
      type: single
      options:
        - "element.classList"
        - "element.offsetHeight"
        - "element.getBoundingClientRect()"
        - "element.scrollTop"
      correctAnswer: "element.classList"
      explanation: "classList doesn't require layout calculation. offsetHeight, getBoundingClientRect(), and scrollTop all force the browser to calculate layout to return accurate values."
---

# DOM Performance

Every time you modify the DOM, the browser may need to recalculate styles, layout, and repaint the screen. These operations are expensive. Too many DOM changes can make your application feel slow and janky.

In this lesson, you'll learn what causes poor DOM performance and how to optimize your code for smooth, fast applications.

## Understanding Reflow and Repaint

When you modify the DOM, the browser goes through several steps:

::illustration-linear-flow
---
steps:
  - label: DOM Change
    sublabel: "JavaScript modifies"
    icon: 1
    color: violet
  - label: Style Calc
    sublabel: "CSS recalculated"
    icon: 2
    color: blue
  - label: Layout/Reflow
    sublabel: "Positions calculated"
    icon: 3
    color: amber
  - label: Paint
    sublabel: "Pixels drawn"
    icon: 4
    color: rose
  - label: Composite
    sublabel: "Layers merged"
    icon: 5
    color: emerald
---
::

### Reflow (Layout)

Reflow calculates the size and position of elements. It's the most expensive operation because changing one element can affect others.

**Operations that trigger reflow:**
- Adding or removing elements
- Changing element dimensions (width, height, padding, margin)
- Changing font size or font family
- Changing content that affects size
- Reading layout properties (offsetHeight, getBoundingClientRect)

### Repaint

Repaint redraws elements when visual properties change without affecting layout.

**Operations that trigger repaint (but not reflow):**
- Changing colors
- Changing background-image
- Changing visibility
- Changing box-shadow

**Rule:** Reflows are more expensive than repaints. Minimize both, but especially reflows.

## Layout Thrashing

Layout thrashing happens when you alternate between reading and writing layout properties. Each read after a write forces a synchronous reflow.

**Bad - Layout Thrashing:**

```javascript
const boxes = document.querySelectorAll('.box')

boxes.forEach(box => {
  const height = box.offsetHeight  // Read - may trigger reflow
  box.style.height = height + 10 + 'px' // Write - invalidates layout
  // Next iteration's read will trigger another reflow!
})
```

**Good - Batch Reads, Then Writes:**

```javascript
const boxes = document.querySelectorAll('.box')

// Read all values first
const heights = Array.from(boxes).map(box => box.offsetHeight)

// Then write all values
boxes.forEach((box, i) => {
  box.style.height = heights[i] + 10 + 'px'
})
```

This pattern is called "read, then write" or "measure, then mutate."

## Batching DOM Updates

### DocumentFragment

A DocumentFragment is a lightweight container for building DOM structures without triggering reflows.

**Without Fragment (Multiple Reflows):**

```javascript
const list = document.querySelector('ul')

// Each appendChild triggers a reflow
for (let i = 0; i < 100; i++) {
  const item = document.createElement('li')
  item.textContent = `Item ${i}`
  list.appendChild(item) // Reflow!
}
```

**With Fragment (One Reflow):**

```javascript
const list = document.querySelector('ul')
const fragment = document.createDocumentFragment()

// Build in the fragment (no reflows)
for (let i = 0; i < 100; i++) {
  const item = document.createElement('li')
  item.textContent = `Item ${i}`
  fragment.appendChild(item) // No reflow
}

// One reflow when inserting
list.appendChild(fragment)
```

### Temporarily Hide Elements

Another technique: hide the element, make changes, then show it again.

```javascript
const container = document.querySelector('.container')

// Hide the container
container.style.display = 'none'

// Make many changes (no reflows while hidden)
for (let i = 0; i < 100; i++) {
  const item = document.createElement('div')
  container.appendChild(item)
}

// Show the container (one reflow)
container.style.display = 'block'
```

### Clone, Modify, Replace

Clone an element, modify the clone, then replace the original.

```javascript
const list = document.querySelector('ul')

// Clone the list
const clone = list.cloneNode(true)

// Modify the clone (no reflows)
for (let i = 0; i < 100; i++) {
  const item = document.createElement('li')
  item.textContent = `New Item ${i}`
  clone.appendChild(item)
}

// Replace original with clone (one reflow)
list.replaceWith(clone)
```

## requestAnimationFrame

`requestAnimationFrame` schedules code to run before the next browser repaint. It's optimized for visual updates and runs at the screen's refresh rate (usually 60fps).

**Basic Usage:**

```javascript
function animate() {
  // Update visual properties
  element.style.transform = `translateX(${x}px)`
  x += 2

  // Schedule next frame
  if (x < 500) {
    requestAnimationFrame(animate)
  }
}

// Start the animation
requestAnimationFrame(animate)
```

### Why Use requestAnimationFrame?

::illustration-checklist
---
title: requestAnimationFrame Benefits
items:
  - text: Syncs with browser refresh rate
    icon: 1
  - text: Pauses when tab is inactive (saves CPU)
    icon: 2
  - text: Batches DOM updates efficiently
    icon: 3
  - text: Smoother animations than setTimeout
    icon: 4
note: Always use rAF for animations instead of setInterval
color: emerald
---
::

### Batching Updates with rAF

Use requestAnimationFrame to batch multiple DOM updates into a single frame.

```javascript
let scheduledUpdate = false

function scheduleUpdate() {
  if (scheduledUpdate) return

  scheduledUpdate = true

  requestAnimationFrame(() => {
    // All pending updates happen here
    performUpdates()
    scheduledUpdate = false
  })
}

// Multiple calls schedule only one update
handleEvent1() { scheduleUpdate() }
handleEvent2() { scheduleUpdate() }
handleEvent3() { scheduleUpdate() }
```

### Smooth Scrolling Example

```javascript
function smoothScrollTo(targetY, duration = 500) {
  const startY = window.scrollY
  const distance = targetY - startY
  const startTime = performance.now()

  function scroll(currentTime) {
    const elapsed = currentTime - startTime
    const progress = Math.min(elapsed / duration, 1)

    // Easing function for smooth motion
    const easeProgress = 1 - Math.pow(1 - progress, 3)

    window.scrollTo(0, startY + distance * easeProgress)

    if (progress < 1) {
      requestAnimationFrame(scroll)
    }
  }

  requestAnimationFrame(scroll)
}

// Usage
button.addEventListener('click', () => {
  smoothScrollTo(document.querySelector('#section').offsetTop)
})
```

## Debouncing and Throttling

Some events fire rapidly (scroll, resize, input). Processing every event can hurt performance.

### Debouncing

Debouncing delays execution until events stop firing for a specified time.

```javascript
function debounce(func, delay) {
  let timeoutId

  return function (...args) {
    clearTimeout(timeoutId)
    timeoutId = setTimeout(() => {
      func.apply(this, args)
    }, delay)
  }
}

// Usage
const searchInput = document.querySelector('#search')

const handleSearch = debounce((event) => {
  // This runs 300ms after typing stops
  performSearch(event.target.value)
}, 300)

searchInput.addEventListener('input', handleSearch)
```

### Throttling

Throttling limits execution to once per time period.

```javascript
function throttle(func, limit) {
  let inThrottle

  return function (...args) {
    if (!inThrottle) {
      func.apply(this, args)
      inThrottle = true
      setTimeout(() => inThrottle = false, limit)
    }
  }
}

// Usage
const handleScroll = throttle(() => {
  // This runs at most once every 100ms
  updateScrollIndicator()
}, 100)

window.addEventListener('scroll', handleScroll)
```

## Caching and Optimization

### Cache DOM References

Selecting elements is relatively slow. Cache references for repeated use.

```javascript
// Bad - selects element every call
function updateCounter() {
  document.querySelector('.counter').textContent = count
}

// Good - cache the reference
const counterElement = document.querySelector('.counter')

function updateCounter() {
  counterElement.textContent = count
}
```

### Cache Computed Styles

Reading computed styles forces style recalculation. Cache when possible.

```javascript
// Bad - reads computed style each iteration
elements.forEach(el => {
  const style = getComputedStyle(el)
  if (style.display !== 'none') {
    // process element
  }
})

// Good - cache if style won't change
const styles = Array.from(elements).map(el => getComputedStyle(el))

elements.forEach((el, i) => {
  if (styles[i].display !== 'none') {
    // process element
  }
})
```

### Use CSS Classes Instead of Inline Styles

Changing classes is often more efficient than changing multiple inline styles.

```javascript
// Less efficient - multiple style changes
element.style.width = '100px'
element.style.height = '100px'
element.style.backgroundColor = 'red'
element.style.border = '1px solid black'

// More efficient - one class change
element.classList.add('highlighted')
```

## Virtual DOM Concepts

Modern frameworks (React, Vue) use a Virtual DOM to optimize updates. Understanding the concept helps you write better vanilla JavaScript.

**Key Ideas:**
1. Maintain a lightweight copy of the DOM structure
2. Calculate the minimum changes needed
3. Apply all changes in a batch

**Simple Example:**

```javascript
function updateList(newItems) {
  const list = document.querySelector('.list')
  const fragment = document.createDocumentFragment()
  const existingItems = list.children

  // Create new items
  newItems.forEach((item, index) => {
    let li

    // Reuse existing element if possible
    if (existingItems[index]) {
      li = existingItems[index]
      if (li.textContent !== item) {
        li.textContent = item
      }
    } else {
      // Create new element only when needed
      li = document.createElement('li')
      li.textContent = item
      fragment.appendChild(li)
    }
  })

  // Add new items
  list.appendChild(fragment)

  // Remove extra items
  while (list.children.length > newItems.length) {
    list.lastElementChild.remove()
  }
}
```

## Performance Monitoring

### Using Performance APIs

```javascript
// Measure operation time
const start = performance.now()

// ... do operations ...

const end = performance.now()
console.log(`Operation took ${end - start} milliseconds`)
```

### DevTools Performance Panel

Use Chrome DevTools to:
1. Record performance profiles
2. Identify slow operations
3. Find layout thrashing
4. Analyze paint events

**To record:**
1. Open DevTools (F12)
2. Go to Performance tab
3. Click Record
4. Perform actions
5. Click Stop
6. Analyze the results

## Practical Examples

### Example 1: Efficient List Rendering

```javascript
function renderProducts(products) {
  const container = document.getElementById('products')
  const fragment = document.createDocumentFragment()

  // Clear container once
  container.innerHTML = ''

  // Build all items in fragment
  products.forEach(product => {
    const card = document.createElement('div')
    card.className = 'product-card'
    card.dataset.id = product.id

    card.innerHTML = `
      <img src="${product.image}" alt="${product.name}" loading="lazy">
      <h3>${product.name}</h3>
      <p>$${product.price}</p>
    `

    fragment.appendChild(card)
  })

  // One DOM update
  container.appendChild(fragment)
}
```

### Example 2: Infinite Scroll

```javascript
const loadMoreThreshold = 200
let isLoading = false

const handleScroll = throttle(() => {
  if (isLoading) return

  const { scrollTop, scrollHeight, clientHeight } = document.documentElement
  const distanceFromBottom = scrollHeight - scrollTop - clientHeight

  if (distanceFromBottom < loadMoreThreshold) {
    isLoading = true
    loadMoreContent().then(() => {
      isLoading = false
    })
  }
}, 100)

window.addEventListener('scroll', handleScroll)
```

### Example 3: Smooth Animation

```javascript
function animateProgress(element, targetPercent, duration = 500) {
  const startPercent = parseFloat(element.style.width) || 0
  const startTime = performance.now()

  function update(currentTime) {
    const elapsed = currentTime - startTime
    const progress = Math.min(elapsed / duration, 1)

    // Ease out
    const eased = 1 - Math.pow(1 - progress, 3)
    const currentPercent = startPercent + (targetPercent - startPercent) * eased

    element.style.width = `${currentPercent}%`

    if (progress < 1) {
      requestAnimationFrame(update)
    }
  }

  requestAnimationFrame(update)
}
```

## Best Practices Summary

::illustration-checklist
---
title: DOM Performance Best Practices
items:
  - text: Batch DOM reads, then batch writes
    icon: 1
  - text: Use DocumentFragment for multiple insertions
    icon: 2
  - text: Cache DOM references in variables
    icon: 3
  - text: Use requestAnimationFrame for visual updates
    icon: 4
  - text: Debounce/throttle frequent events
    icon: 5
  - text: Prefer class changes over inline styles
    icon: 6
note: Measure before optimizing - use DevTools
color: emerald
---
::

## Key Takeaways

- **Reflow** (layout) is expensive; **repaint** is cheaper but still costs
- **Layout thrashing** happens when alternating reads and writes
- **DocumentFragment** batches insertions into one reflow
- **requestAnimationFrame** schedules visual updates efficiently
- **Debouncing** delays execution until events stop
- **Throttling** limits execution frequency
- **Cache** DOM references and computed values
- Use **CSS classes** instead of multiple inline style changes
- **Measure** performance before and after optimization

These performance techniques become critical in large applications with complex UIs. Master them now, and your applications will feel smooth and responsive.
