---
title: "Closures & Scope - Quick Reference"
description: "Essential patterns, syntax, and best practices for JavaScript closures, scope, memory management, and module patterns"
estimatedMinutes: 5
difficulty: intermediate
priority: essential
roadmap: fullstack
phase: 2
topic: closures-and-scope
learningObjectives:
  - "Quick reference for closure patterns and scope rules"
  - "Memory management best practices for closures"
  - "Module Pattern and IIFE syntax variations"
isCheatSheet: true
cheatSheetTopic: "Closures & Scope"
---

# Closures & Scope - Quick Reference

## Key Terminology

| Term | Definition |
|------|------------|
| **Lexical Scope** | Scope determined at compile time by where code is written, not where it runs |
| **Scope Chain** | JavaScript's lookup mechanism that searches outward through nested scopes |
| **Closure** | A function that retains access to variables from its outer scope even after the outer function completes |
| **IIFE** | Immediately Invoked Function Expression - a function that executes immediately upon definition |
| **Module Pattern** | Design pattern using IIFE and closures to create private/public members |
| **Garbage Collection** | Automatic memory cleanup using mark-and-sweep algorithm |

## Scope Rules Quick Guide

| Scenario | Can Access? | Reason |
|----------|-------------|--------|
| Inner → Outer variables | ✓ Yes | Scope chain flows outward |
| Outer → Inner variables | ✗ No | Scope doesn't flow inward |
| Variable not in current scope | Searches up | Follows scope chain to global |
| Variable not found anywhere | ReferenceError | Reached global, still not found |
| Same variable name nested | Uses closest | Shadowing - inner takes precedence |

## Closure Patterns

### Private Variables
```javascript
function createCounter() {
  let count = 0  // Private
  return {
    increment: () => ++count,
    get: () => count
  }
}
```

### Factory Function
```javascript
function createUser(name) {
  let score = 0  // Private
  return {
    getName: () => name,
    addPoints: (pts) => score += pts,
    getScore: () => score
  }
}
```

### Function Generator
```javascript
function createMultiplier(multiplier) {
  return (number) => number * multiplier
}
const double = createMultiplier(2)
```

### Event Handler Pattern
```javascript
function setupButton(buttonName) {
  let clickCount = 0
  return function handleClick() {
    clickCount++
    console.log(`${buttonName}: ${clickCount}`)
  }
}
```

## Common Closure Mistakes

| Problem | Wrong Code | Fix |
|---------|------------|-----|
| **Loop closure issue** | `for (var i=0; i<3; i++) { handlers.push(() => console.log(i)) }` | Use `let` instead of `var` OR create new scope with IIFE |
| **Keeping large objects** | `return () => user.name` keeps entire `user` | Extract: `const name = user.name; return () => name` |
| **Circular reference** | `obj1.ref = obj2; obj2.ref = obj1` in closure | Avoid or nullify references when done |
| **Event listener leak** | Add listener with closure, never remove | `removeEventListener` or extract only needed values |

## Memory Management

### Best Practices

| Practice | Example | Benefit |
|----------|---------|---------|
| **Capture only what you need** | `const id = user.id; return () => id` | Allows rest of object to be GC'd |
| **Nullify references** | `fileBuffer = null` after processing | Frees memory immediately |
| **Remove event listeners** | `element.removeEventListener('click', handler)` | Prevents closure from staying in memory |
| **Clear timers** | `clearInterval(id)` when done | Releases closure reference |
| **Use WeakMap** | `const cache = new WeakMap()` | Allows objects to be GC'd |

### Memory Leak Patterns to Avoid

```javascript
// BAD: Keeps entire large object
function createGreeting(user) {
  return () => `Hello, ${user.name}`  // Entire user kept!
}

// GOOD: Extract only what you need
function createGreeting(user) {
  const name = user.name  // Only name kept
  return () => `Hello, ${name}`
}

// BAD: Timer never cleared
function startMonitoring() {
  const data = new Array(1000000)
  setInterval(() => console.log(data.length), 1000)  // Runs forever!
}

// GOOD: Return cleanup function
function startMonitoring() {
  const dataLength = new Array(1000000).length  // Extract value
  const id = setInterval(() => console.log(dataLength), 1000)
  return () => clearInterval(id)  // Cleanup
}
```

## Module Pattern

### Standard Module Pattern
```javascript
const Module = (function() {
  // Private
  let privateVar = 0

  function privateFunction() {
    return "private"
  }

  // Public API
  return {
    publicMethod: function() {
      return privateFunction()
    },
    publicVar: "public"
  }
})()
```

### Revealing Module Pattern
```javascript
const Module = (function() {
  // All defined as private
  let data = []

  function add(item) {
    data.push(item)
  }

  function get() {
    return [...data]
  }

  function clear() {
    data = []
  }

  // Reveal public API
  return { add, get }  // clear stays private
})()
```

### Module with Dependencies
```javascript
const MyModule = (function($, _) {
  // Use jQuery and Lodash
  function init() {
    $('.item').click(handler)
  }

  return { init }
})(jQuery, lodash)
```

## IIFE Syntax Variations

| Style | Syntax | Notes |
|-------|--------|-------|
| **Standard (most common)** | `(function() { })()` | Invoke outside parentheses |
| **Alternative** | `(function() { }())` | Invoke inside parentheses |
| **Arrow function** | `(() => { })()` | ES6 syntax |
| **With parameters** | `(function(x) { })(5)` | Pass arguments |
| **Named (recursive)** | `(function fact(n) { return n <= 1 ? 1 : n * fact(n-1) })(5)` | Name only accessible inside |
| **Unary operators** | `!function() { }()` | Also: `+`, `-`, `~`, `void` |

### IIFE Use Cases

| Use Case | Example |
|----------|---------|
| **Private scope** | `(function() { let temp = "private"; /* use temp */ })()` |
| **Avoid global pollution** | `(function() { var x = 1; window.api = { get: () => x } })()` |
| **Async IIFE** | `(async () => { const data = await fetch(url); })()` |
| **Loop closure fix** | `for (var i=0; i<3; i++) { ((index) => { /* use index */ })(i) }` |
| **Initialization** | `(function() { console.log('App initialized'); setupConfig(); })()` |

## Pattern Comparison

| Pattern | Privacy | Singleton | Use Case | Modern Alternative |
|---------|---------|-----------|----------|-------------------|
| **Closure** | Yes | No | Encapsulation, state | Classes with private fields (`#field`) |
| **Module Pattern** | Yes | Yes | Organize code, API design | ES6 modules (`import`/`export`) |
| **IIFE** | Yes | Per-invocation | Immediate scope, initialization | Block scope (`{ let x; }`) |
| **Factory Function** | Yes | No | Create multiple instances | Classes or object literals |

## Interview Quick Hits

### Common Questions & Answers

**Q: What is a closure?**
A: A function that retains access to variables from its outer scope even after the outer function has finished executing.

**Q: When does JavaScript determine scope?**
A: At compile time (lexical scope) based on where code is written, not where it runs.

**Q: How does garbage collection work with closures?**
A: Variables stay in memory as long as any function references them. When all references are gone, GC removes them.

**Q: What's the loop closure problem?**
A: When using `var` in loops, all closures share the same variable. Fix: use `let` or create new scope with IIFE.

**Q: Module Pattern vs ES6 modules?**
A: Module Pattern uses IIFE/closures for privacy, runs immediately, works everywhere. ES6 modules use `import`/`export`, load async, support tree-shaking. Use ES6 for new projects.

**Q: Why wrap IIFE in parentheses?**
A: JavaScript function declarations can't be immediately invoked. Parentheses convert it to an expression, which can be invoked.

## Debugging & Tools

### Chrome DevTools Memory Checks

1. **Heap Snapshot**: Take before/after snapshots to compare memory
2. **Allocation Timeline**: Track memory allocations over time
3. **Memory Profiler**: See what closures keep objects alive

### Node.js Memory Check
```javascript
const before = process.memoryUsage().heapUsed
// Create closures
if (global.gc) global.gc()  // Run with --expose-gc
const after = process.memoryUsage().heapUsed
console.log(`Increase: ${(after - before) / 1024 / 1024} MB`)
```

## When to Use What

| Need | Use This | Example |
|------|----------|---------|
| Private variables | Closure with factory function | Counter, bank account |
| Maintain state | Closure | Event handler with click count |
| One-time initialization | IIFE | App setup, config |
| Organize large codebase | Module Pattern or ES6 modules | Library, application modules |
| Multiple instances with privacy | Factory function | User objects, game players |
| Async top-level code | Async IIFE | Fetch data on script load |
| Avoid global pollution | IIFE or Module Pattern | jQuery plugins, libraries |

## Syntax Gotchas

### Semicolon Before IIFE
```javascript
// WRONG - causes error
const x = 10
(function() { console.log('IIFE') })()
// JavaScript sees: 10(function()...)

// RIGHT
const x = 10;
(function() { console.log('IIFE') })()

// Or defensive semicolon
const x = 10
;(function() { console.log('IIFE') })()
```

### Function Declaration vs Expression
```javascript
// Declaration - can't invoke immediately
function() { }()  // SyntaxError!

// Expression - can invoke
(function() { })()  // Works
```

### Return Copies, Not References
```javascript
// WRONG - exposes private data
return {
  getData: () => data  // Returns reference!
}

// RIGHT - return copy
return {
  getData: () => [...data]  // Returns copy
}
```

## ES6 Modern Alternatives

| Old Pattern | Modern Alternative |
|-------------|-------------------|
| `(function() { let x; })()` | `{ let x; }` (block scope) |
| `var self = this` | Arrow functions (lexical `this`) |
| Module Pattern | ES6 modules (`import`/`export`) |
| IIFE for top-level await | Top-level `await` (ES2022) |
| Closure for private | Class private fields (`#field`) |

---

**Remember:** Closures are powerful but can cause memory leaks if misused. Always capture only what you need, clean up event listeners, and clear timers when done.
