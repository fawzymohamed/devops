---
title: "Lexical Scope & Scope Chain"
description: "Master how JavaScript determines variable access at compile time through lexical scope and the scope chain lookup mechanism"
difficulty: intermediate
estimatedMinutes: 10
priority: essential
roadmap: fullstack
phase: 2
topic: closures-and-scope
learningObjectives:
  - "Understand what lexical scope means and how JavaScript uses it"
  - "Explain how the scope chain works during variable lookup"
  - "Trace how nested functions access variables from outer scopes"
  - "Identify scope-related issues in code and fix them"
quiz:
  passingScore: 70
  questions:
    - question: "When does JavaScript determine the scope of a variable?"
      type: single
      options:
        - "At compile time, based on where the code is written"
        - "At runtime, based on how the function is called"
        - "When the variable is first accessed"
        - "When the function returns"
      correctAnswer: "At compile time, based on where the code is written"
      explanation: "JavaScript uses lexical (static) scope, meaning scope is determined at compile time based on where the code is physically written, not where or how it's called."

    - question: "What happens when JavaScript cannot find a variable in the current scope?"
      type: single
      options:
        - "It looks in the outer scope, continuing until it reaches the global scope"
        - "It immediately throws a ReferenceError"
        - "It creates a new variable with undefined"
        - "It stops searching after the immediate parent scope"
      correctAnswer: "It looks in the outer scope, continuing until it reaches the global scope"
      explanation: "The scope chain causes JavaScript to search outward through each enclosing scope until it finds the variable or reaches the global scope. Only then, if not found, does it throw a ReferenceError."

    - question: "Select all TRUE statements about lexical scope."
      type: multiple
      options:
        - "Inner functions can access variables from outer functions"
        - "Outer functions can access variables from inner functions"
        - "Scope is determined by where code is written, not where it runs"
        - "Each function creates a new scope"
      correctAnswers:
        - "Inner functions can access variables from outer functions"
        - "Scope is determined by where code is written, not where it runs"
        - "Each function creates a new scope"
      explanation: "Inner functions access outer variables (scope chain), scope is static (determined at write time), and each function creates new scope. However, outer functions cannot access inner function variables - scope only flows inward."

    - question: "A function defined inside another function can access the outer function's variables even after the outer function has finished running."
      type: true-false
      correctAnswer: true
      explanation: "True! This is the foundation of closures. The inner function maintains a reference to its outer scope through the scope chain, keeping those variables alive even after the outer function completes."

    - question: "In the code `function outer() { let x = 1; function inner() { console.log(x); } }`, where is variable `x` in the scope chain when `inner` runs?"
      type: single
      options:
        - "In the outer function's scope (one level up from inner)"
        - "In the global scope"
        - "In the inner function's local scope"
        - "x is not accessible from inner"
      correctAnswer: "In the outer function's scope (one level up from inner)"
      explanation: "Variable x is declared in outer's scope. When inner runs and looks for x, it doesn't find it locally, so it follows the scope chain one level up to outer's scope where x exists."
---

# Lexical Scope & Scope Chain

Before you can master closures, you need to understand how JavaScript finds variables. This happens through **lexical scope** and the **scope chain**. These concepts explain why inner functions can use variables from outer functions, and how JavaScript decides which variable to use when the same name exists in multiple places.

In this lesson, you will learn how JavaScript determines scope when your code is compiled, and how the scope chain works when your code runs.

## What Is Lexical Scope?

**Lexical scope** (also called static scope) means that the scope of a variable is determined by where you write it in your code, not by where or how the code runs.

The word "lexical" refers to the text of your code. When JavaScript compiles your code, it looks at the physical structure - which functions are inside which other functions - and uses this to determine scope.

```javascript
// Global scope
let globalVar = "I'm global"

function outer() {
  // outer's scope
  let outerVar = "I'm in outer"

  function inner() {
    // inner's scope
    let innerVar = "I'm in inner"
    console.log(innerVar)   // Found in inner's scope
    console.log(outerVar)   // Found in outer's scope
    console.log(globalVar)  // Found in global scope
  }

  inner()
}

outer()
```

The key point: JavaScript knows at compile time that `inner` can access `outerVar` because `inner` is written inside `outer`. This doesn't change based on how you call the functions.

## How Lexical Scope Differs from Dynamic Scope

Some languages use **dynamic scope**, where scope depends on how functions are called at runtime. JavaScript does not work this way.

```javascript
let name = "Global"

function showName() {
  console.log(name)  // Which 'name' does this use?
}

function wrapper() {
  let name = "Wrapper"
  showName()  // Calls showName from inside wrapper
}

wrapper()  // Output: "Global"
```

With lexical scope, `showName` always uses the `name` from where it was defined (global scope), not from where it was called (`wrapper`). If JavaScript used dynamic scope, the output would be "Wrapper".

## The Scope Chain

When you use a variable, JavaScript needs to find where that variable is defined. It does this through the **scope chain**.

::illustration-linear-flow
---
steps:
  - label: Current Scope
    sublabel: Check local variables
    icon: 1
    color: violet
  - label: Outer Scope
    sublabel: Check parent function
    icon: 2
    color: blue
  - label: More Outer Scopes
    sublabel: Keep going up
    icon: 3
    color: cyan
  - label: Global Scope
    sublabel: Final check
    icon: 4
    color: emerald
  - label: Not Found
    sublabel: ReferenceError
    icon: X
    color: rose
---
::

### How the Scope Chain Works

1. JavaScript looks for the variable in the current scope
2. If not found, it looks in the immediate outer scope
3. This continues through each outer scope
4. If it reaches the global scope and still doesn't find it, JavaScript throws a ReferenceError

```javascript
let a = "global a"

function first() {
  let b = "first's b"

  function second() {
    let c = "second's c"

    function third() {
      // Looking for variables from inside third()
      console.log(c)  // Found in second's scope (1 level up)
      console.log(b)  // Found in first's scope (2 levels up)
      console.log(a)  // Found in global scope (3 levels up)
    }

    third()
  }

  second()
}

first()
```

Each function has a reference to its outer scope. This chain of references is the scope chain.

## Variable Shadowing

When a variable in an inner scope has the same name as one in an outer scope, the inner variable "shadows" the outer one.

```javascript
let value = "global"

function outer() {
  let value = "outer"  // Shadows global 'value'

  function inner() {
    let value = "inner"  // Shadows outer's 'value'
    console.log(value)   // Output: "inner"
  }

  inner()
  console.log(value)  // Output: "outer"
}

outer()
console.log(value)  // Output: "global"
```

JavaScript finds the first match in the scope chain and stops looking. The outer variables still exist but are hidden by the inner ones.

## Practical Example: Counter Factory

Here's a practical example showing how the scope chain enables useful patterns.

```javascript
function createCounter(start) {
  let count = start  // Stored in createCounter's scope

  return {
    increment() {
      count++       // Accesses 'count' through scope chain
      return count
    },
    decrement() {
      count--       // Same 'count' variable
      return count
    },
    getCount() {
      return count  // Same 'count' variable
    }
  }
}

const counter = createCounter(0)
console.log(counter.increment())  // 1
console.log(counter.increment())  // 2
console.log(counter.decrement())  // 1
console.log(counter.getCount())   // 1
```

All three methods access the same `count` variable through the scope chain. Even after `createCounter` finishes running, the returned object's methods still have access to `count`.

## Scope Chain in Block Scope

Block scope (`let` and `const` in curly braces) also creates entries in the scope chain.

```javascript
function process() {
  let outer = "function scope"

  if (true) {
    let blockVar = "block scope"

    {
      let nestedBlock = "nested block"
      console.log(nestedBlock)  // Found locally
      console.log(blockVar)     // Found 1 level up
      console.log(outer)        // Found 2 levels up
    }
  }

  // blockVar is not accessible here
}
```

Each block with `let` or `const` creates a new scope level in the chain.

## Common Mistakes

### Mistake 1: Assuming Dynamic Scope

```javascript
function logger() {
  console.log(message)  // Uses lexical scope, not where it's called
}

function caller() {
  let message = "Hello"
  logger()  // ReferenceError: message is not defined
}

caller()
```

The fix: pass the value as a parameter or define `message` where `logger` can access it.

### Mistake 2: Accidental Global Variables

```javascript
function broken() {
  // Forgot 'let' - creates global variable!
  counter = 0
}

broken()
console.log(counter)  // 0 - oops, it's global now
```

Always declare variables with `let` or `const`.

### Mistake 3: Loop Variable Confusion

```javascript
// Problem with var
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100)
}
// Output: 3, 3, 3 (all reference the same i)

// Solution with let
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100)
}
// Output: 0, 1, 2 (each iteration has its own i)
```

Each loop iteration with `let` creates a new scope with its own copy of `i`.

## Interview Tips

Interviewers often ask about scope to test your understanding of JavaScript fundamentals. Be ready to:

1. **Explain lexical scope** - Scope is determined by where code is written, not where it runs
2. **Trace the scope chain** - Show how JavaScript looks up variables from inner to outer scopes
3. **Identify shadowing** - Explain what happens when inner and outer variables share names
4. **Connect to closures** - Lexical scope is why closures work (covered in the next lesson)

**Common interview question:** "What will this code output and why?"

```javascript
let x = 10
function foo() {
  console.log(x)
  let x = 20
}
foo()
```

**Answer:** ReferenceError. The local `x` is hoisted but stays in the Temporal Dead Zone until the `let x = 20` line. The function doesn't use the global `x` because the local `x` shadows it throughout the entire function scope.

## Key Takeaways

- **Lexical scope** means JavaScript determines scope at compile time based on where code is written
- The **scope chain** is how JavaScript looks up variables from inner to outer scopes
- Inner functions can access outer function variables, but not the reverse
- **Variable shadowing** occurs when an inner scope variable has the same name as an outer one
- Each function and block (with `let`/`const`) creates a new level in the scope chain
- Understanding scope is essential for understanding closures (next lesson)

In the next lesson, you'll learn how closures use the scope chain to create powerful patterns like private variables and factory functions.
