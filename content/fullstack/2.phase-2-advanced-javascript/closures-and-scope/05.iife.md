---
title: "IIFE (Immediately Invoked Function Expression)"
description: "Master IIFE syntax, understand its use cases including variable scoping, avoiding global pollution, and creating private scope"
difficulty: intermediate
estimatedMinutes: 11
priority: essential
roadmap: fullstack
phase: 2
topic: closures-and-scope
learningObjectives:
  - "Write IIFE syntax correctly with proper parentheses placement"
  - "Explain when and why to use IIFE in modern JavaScript"
  - "Use IIFE for variable scoping and global namespace protection"
  - "Identify IIFE patterns in legacy code and libraries"
quiz:
  passingScore: 70
  questions:
    - question: "What does IIFE stand for?"
      type: single
      options:
        - "Immediately Invoked Function Expression"
        - "Instant Inline Function Execution"
        - "Internal Isolated Function Environment"
        - "Imported Invoked Function Export"
      correctAnswer: "Immediately Invoked Function Expression"
      explanation: "IIFE stands for Immediately Invoked Function Expression - a function that is defined and executed immediately in one statement."

    - question: "Why do we wrap an IIFE in parentheses?"
      type: single
      options:
        - "To tell JavaScript to treat the function as an expression, not a declaration"
        - "To make the code run faster"
        - "To create a loop"
        - "Parentheses are optional decoration"
      correctAnswer: "To tell JavaScript to treat the function as an expression, not a declaration"
      explanation: "JavaScript function declarations cannot be immediately invoked. Wrapping in parentheses converts it to a function expression, which can be invoked immediately. Without parentheses, you get a syntax error."

    - question: "Select all valid IIFE syntax variations."
      type: multiple
      options:
        - "(function() { })();"
        - "(function() { }());"
        - "!function() { }();"
        - "+function() { }();"
      correctAnswers:
        - "(function() { })();"
        - "(function() { }());"
        - "!function() { }();"
        - "+function() { }();"
      explanation: "All of these are valid IIFE syntax. The first two are the most common (grouping operator), while !, +, -, ~, void are unary operators that also convert a function to an expression. However, the parentheses styles are preferred for readability."

    - question: "IIFE is still useful in modern JavaScript with ES6 modules and let/const."
      type: true-false
      correctAnswer: true
      explanation: "True! While ES6 reduced the need for IIFE, it's still useful for: creating isolated scope in inline scripts, executing async code immediately, initializing code that runs once, and working with legacy code or libraries that don't use modules."

    - question: "What is the main purpose of using an IIFE?"
      type: single
      options:
        - "To create a private scope and avoid polluting the global namespace"
        - "To make functions run asynchronously"
        - "To improve performance"
        - "To create loops"
      correctAnswer: "To create a private scope and avoid polluting the global namespace"
      explanation: "IIFE's primary purpose is to create a new scope immediately. Variables inside an IIFE are isolated from the global scope, preventing naming conflicts and global namespace pollution."
---

# IIFE (Immediately Invoked Function Expression)

An **IIFE** (Immediately Invoked Function Expression) is a function that runs as soon as it is defined. It's a common JavaScript pattern used to create private scope and avoid global namespace pollution.

Understanding IIFE is essential for reading legacy code, working with older libraries, and mastering JavaScript's scoping rules. Even in modern ES6+ code, IIFE has its place.

## What Is an IIFE?

An IIFE is a function expression that is defined and executed immediately.

```javascript
// Regular function - defined but NOT executed
function greet() {
  console.log("Hello!")
}

// IIFE - defined AND executed immediately
(function() {
  console.log("Hello!")
})()
// Output: "Hello!"
```

The function runs immediately without being called separately.

## IIFE Syntax

The basic syntax has two parts:

1. **Function expression** wrapped in parentheses
2. **Invocation** with `()`

```javascript
(function() {
  // Code here
})()
```

### Why the Parentheses?

JavaScript function declarations cannot be immediately invoked. The parentheses convert it to an expression.

```javascript
// ERROR - Function declaration can't be invoked
function() {
  console.log("Hello")
}()  // SyntaxError!

// WORKS - Parentheses make it an expression
(function() {
  console.log("Hello")
})()  // "Hello"
```

The parentheses tell JavaScript: "This is an expression, not a declaration."

## IIFE Variations

### Style 1: Invoke Outside (Most Common)

```javascript
(function() {
  console.log("Style 1")
})()
```

### Style 2: Invoke Inside

```javascript
(function() {
  console.log("Style 2")
}())
```

Both work identically. Style 1 is more common, but you'll see both in the wild.

### With Parameters

```javascript
(function(name, age) {
  console.log(`${name} is ${age} years old`)
})("Alice", 30)
// Output: "Alice is 30 years old"
```

### With Return Value

```javascript
const result = (function(a, b) {
  return a + b
})(5, 10)

console.log(result)  // 15
```

### Arrow Function IIFE

```javascript
(() => {
  console.log("Arrow IIFE")
})()

// With parameters
((name) => {
  console.log(`Hello, ${name}`)
})("Alice")
```

### Named IIFE (for recursion)

```javascript
(function factorial(n) {
  return n <= 1 ? 1 : n * factorial(n - 1)
})(5)  // 120
```

The name is only accessible inside the function, not outside.

## Use Case 1: Creating Private Scope

Before `let` and `const`, `var` was function-scoped. IIFE created block-like scope.

```javascript
// Problem with var
var items = []
for (var i = 0; i < 3; i++) {
  items.push(function() {
    console.log(i)  // All reference the same i
  })
}

items[0]()  // 3 (not 0!)
items[1]()  // 3 (not 1!)
items[2]()  // 3 (not 2!)

// Solution with IIFE
var items = []
for (var i = 0; i < 3; i++) {
  items.push((function(index) {
    return function() {
      console.log(index)  // Each has its own index
    }
  })(i))
}

items[0]()  // 0
items[1]()  // 1
items[2]()  // 2
```

Each IIFE creates a new scope with its own `index` variable.

**Modern solution:** Use `let` instead of `var`.

```javascript
const items = []
for (let i = 0; i < 3; i++) {  // 'let' creates block scope
  items.push(function() {
    console.log(i)
  })
}
```

## Use Case 2: Avoiding Global Namespace Pollution

IIFE prevents variables from leaking into the global scope.

```javascript
// Problem: Global pollution
var counter = 0

function increment() {
  counter++
}

function getCount() {
  return counter
}

// counter, increment, and getCount are global!

// Solution: IIFE
(function() {
  var counter = 0  // Private to this IIFE

  window.increment = function() {
    counter++
  }

  window.getCount = function() {
    return counter
  }
})()

// Only increment and getCount are global
// counter is private
```

This was the foundation of the Module Pattern.

## Use Case 3: Async IIFE

You can't use `await` at the top level in older JavaScript. IIFE solves this.

```javascript
// Problem: Can't await at top level (pre-ES2022)
// await fetchData()  // Error!

// Solution: Async IIFE
(async function() {
  const data = await fetchData()
  console.log(data)
})()

// Or with arrow syntax
(async () => {
  const data = await fetchData()
  console.log(data)
})()
```

This is still useful in browser console, Node.js REPL, and script tags.

## Use Case 4: Initialization Code

Run setup code immediately without polluting the global scope.

```javascript
(function() {
  // Initialize
  const config = {
    apiUrl: "https://api.example.com",
    timeout: 5000
  }

  // Setup
  console.log("App initialized with config:", config)

  // Attach only what's needed globally
  window.appConfig = config
})()

// config variable doesn't exist globally
// Only appConfig is accessible
```

## Use Case 5: Unary Operator IIFEs

You can use unary operators instead of parentheses.

```javascript
// With !
!function() {
  console.log("Using !")
}()

// With +
+function() {
  console.log("Using +")
}()

// With -
-function() {
  console.log("Using -")
}()

// With ~
~function() {
  console.log("Using ~")
}()

// With void
void function() {
  console.log("Using void")
}()
```

These convert the function to an expression. You might see them in minified code, but parentheses are clearer.

## IIFE with Dependencies

Pass global objects as parameters to make dependencies explicit.

```javascript
(function($, _) {
  // Use jQuery and Lodash
  $(".item").each(function() {
    console.log($(this).text())
  })

  const items = _.chunk([1, 2, 3, 4], 2)
  console.log(items)
})(jQuery, lodash)
```

Benefits:
- Clear dependencies
- Can rename parameters
- Easier to test (inject mocks)
- Minification-friendly

## IIFE vs ES6 Modules

| Feature | IIFE | ES6 Modules |
|---------|------|-------------|
| Syntax | `(function(){})()` | `import`/`export` |
| Scope | Function scope | File scope |
| Browser Support | All | Modern + transpilers |
| Use Case | Legacy, quick scripts | Modern projects |
| Async | Needs async IIFE | Top-level await (ES2022) |

### When to Use IIFE Today

1. **Browser console**: Quick experiments with async/await
2. **Inline scripts**: `<script>` tags without modules
3. **Legacy code**: Maintaining older codebases
4. **Library wrappers**: Wrapping code for UMD modules
5. **Quick isolation**: Need scope without creating a file

### Migration Example

```javascript
// Old: IIFE
(function() {
  const API_URL = "https://api.example.com"

  function fetchUsers() {
    return fetch(`${API_URL}/users`)
  }

  window.api = { fetchUsers }
})()

// New: ES6 Module (api.js)
const API_URL = "https://api.example.com"

export function fetchUsers() {
  return fetch(`${API_URL}/users`)
}
```

## Common Patterns

### Pattern 1: Module Pattern

```javascript
const MyModule = (function() {
  let privateVar = 0

  return {
    increment() {
      privateVar++
    },
    get() {
      return privateVar
    }
  }
})()
```

### Pattern 2: Singleton

```javascript
const Singleton = (function() {
  let instance

  function createInstance() {
    return { id: Math.random() }
  }

  return {
    getInstance() {
      if (!instance) {
        instance = createInstance()
      }
      return instance
    }
  }
})()

const i1 = Singleton.getInstance()
const i2 = Singleton.getInstance()
console.log(i1 === i2)  // true - same instance
```

### Pattern 3: Conditional Execution

```javascript
const utils = (function() {
  // Check environment
  const isNode = typeof window === "undefined"

  if (isNode) {
    // Node.js specific code
    return {
      log: console.log
    }
  } else {
    // Browser specific code
    return {
      log: function(msg) {
        document.body.innerHTML += `<p>${msg}</p>`
      }
    }
  }
})()
```

## Common Mistakes

### Mistake 1: Forgetting Parentheses

```javascript
// WRONG
function() {
  console.log("Hello")
}()  // SyntaxError

// RIGHT
(function() {
  console.log("Hello")
})()
```

### Mistake 2: Missing Semicolon Before IIFE

```javascript
// WRONG - Causes weird errors
const x = 10
(function() {
  console.log("IIFE")
})()
// JavaScript sees: const x = 10(function(){...})()
// Error: 10 is not a function

// RIGHT
const x = 10;
(function() {
  console.log("IIFE")
})()

// Or use semicolon before IIFE
const x = 10
;(function() {
  console.log("IIFE")
})()
```

This is why some developers start IIFEs with `;`.

### Mistake 3: Overusing IIFE in Modern Code

```javascript
// OVERKILL - Use block scope instead
(function() {
  let temp = "data"
  console.log(temp)
})()

// BETTER - Block scope with let/const
{
  let temp = "data"
  console.log(temp)
}

// BEST - ES6 module
// In separate file
const temp = "data"
console.log(temp)
```

Use IIFE when it makes sense, not everywhere.

## Interview Tips

### Common Interview Questions

**Q1: "What is an IIFE and why use it?"**

A: An IIFE is a function that executes immediately upon definition. We use it to create private scope, avoid global namespace pollution, and run initialization code. It was especially important before ES6 modules and block-scoped variables.

**Q2: "Why do you need parentheses around an IIFE?"**

A: Function declarations cannot be immediately invoked in JavaScript. The parentheses convert the function into an expression. Function expressions can be invoked immediately, so we add `()` at the end to execute it.

**Q3: "Fix this code:"**

```javascript
// Question
function() {
  console.log("Hello")
}()
```

**Answer:**
```javascript
// Fixed
(function() {
  console.log("Hello")
})()

// Or
(function() {
  console.log("Hello")
}())
```

**Q4: "Is IIFE still relevant with ES6?"**

A: Yes, but less common. Still useful for:
- Async/await in browser console or scripts
- Legacy code maintenance
- Quick scope isolation without creating files
- Initializing libraries
- Understanding older codebases

## Practical Example: jQuery Plugin

```javascript
// Protect $ from conflicts
(function($) {
  $.fn.highlight = function() {
    return this.css("background-color", "yellow")
  }
})(jQuery)

// Usage
$(".important").highlight()
```

The IIFE ensures `$` always refers to jQuery, even if another library uses `$`.

## Key Takeaways

- **IIFE** stands for Immediately Invoked Function Expression
- **Syntax**: `(function(){ })()`  or  `(function(){ }())`
- **Parentheses** convert function declaration to expression
- Creates **immediate private scope**
- Prevents **global namespace pollution**
- Useful for **initialization** and **async code**
- **Less common** in modern ES6+ code but still relevant
- Essential for understanding **Module Pattern** and legacy code
- Can use **unary operators** (!, +, -, ~, void) instead of parentheses

With this lesson, you've completed the Closures & Scope topic! You now understand lexical scope, closures, memory considerations, the Module Pattern, and IIFE. These concepts form the foundation of advanced JavaScript and prepare you for real-world development and interviews.
