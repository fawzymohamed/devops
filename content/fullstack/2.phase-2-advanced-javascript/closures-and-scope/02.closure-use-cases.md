---
title: "Closure Use Cases"
description: "Learn practical patterns using closures including private variables, factory functions, and data encapsulation techniques"
difficulty: intermediate
estimatedMinutes: 12
priority: essential
roadmap: fullstack
phase: 2
topic: closures-and-scope
learningObjectives:
  - "Create private variables using closures"
  - "Build factory functions that return objects with methods"
  - "Use closures to maintain state in functional programming"
  - "Implement practical design patterns with closures"
quiz:
  passingScore: 70
  questions:
    - question: "How do closures enable private variables in JavaScript?"
      type: single
      options:
        - "Inner functions access outer variables through the scope chain, but outer variables aren't directly accessible from outside"
        - "JavaScript has a 'private' keyword that works with closures"
        - "Closures create a copy of the variable that is hidden"
        - "Variables in closures are automatically encrypted"
      correctAnswer: "Inner functions access outer variables through the scope chain, but outer variables aren't directly accessible from outside"
      explanation: "Closures allow inner functions to access outer scope variables, but those variables remain inaccessible from outside the function. This creates 'privacy' - only the returned functions can access the variable."

    - question: "What is the main advantage of factory functions over constructor functions?"
      type: single
      options:
        - "Factory functions can create objects with private variables and don't require 'new'"
        - "Factory functions run faster than constructors"
        - "Factory functions use less memory"
        - "Factory functions are the only way to create objects"
      correctAnswer: "Factory functions can create objects with private variables and don't require 'new'"
      explanation: "Factory functions return objects directly without needing 'new', and can use closures to create true private variables. Constructors expose all properties on the instance."

    - question: "Select all TRUE statements about closures for data privacy."
      type: multiple
      options:
        - "Variables in the outer function remain accessible to inner functions"
        - "Variables in the outer function are not directly accessible from outside"
        - "Each call to the factory function creates a new independent closure"
        - "All instances share the same private variables"
      correctAnswers:
        - "Variables in the outer function remain accessible to inner functions"
        - "Variables in the outer function are not directly accessible from outside"
        - "Each call to the factory function creates a new independent closure"
      explanation: "Closures maintain access through the scope chain, prevent direct external access, and each function call creates a new scope. However, each instance has its own private variables - they don't share."

    - question: "In the code `function counter() { let count = 0; return () => ++count; }`, the variable 'count' is accessible after counter() finishes running."
      type: true-false
      correctAnswer: true
      explanation: "True! The returned function maintains a reference to count through closure. Even though counter() completes, count stays alive because the returned function still references it."

    - question: "What happens when you call a factory function multiple times?"
      type: single
      options:
        - "Each call creates a new closure with its own independent variables"
        - "All calls share the same closure variables"
        - "Only the first call creates a closure, subsequent calls reuse it"
        - "Factory functions can only be called once"
      correctAnswer: "Each call creates a new closure with its own independent variables"
      explanation: "Every function call creates a new execution context with its own scope. When you call a factory function multiple times, each call creates an independent closure with separate variable instances."
---

# Closure Use Cases

Closures are one of JavaScript's most powerful features. They let you create private variables, build factory functions, and maintain state without using classes. In this lesson, you will learn the most common and useful patterns that use closures.

These patterns appear in real-world code, libraries, and job interviews. Mastering them shows you understand JavaScript at a deep level.

## What Is a Closure?

A **closure** is a function that has access to variables from an outer function, even after the outer function has finished running.

This happens because of the scope chain - the inner function maintains a reference to its outer scope.

```javascript
function outer() {
  let message = "Hello"

  function inner() {
    console.log(message)  // Accesses 'message' through closure
  }

  return inner
}

const myFunction = outer()  // outer() finishes running
myFunction()  // Output: "Hello" - message still exists!
```

The key: `inner` keeps `message` alive because it references it. JavaScript doesn't garbage collect `message` until no function references it.

## Use Case 1: Private Variables

JavaScript doesn't have true private variables like other languages (until recently with `#privateField`). Closures give you the same result.

```javascript
function createBankAccount(initialBalance) {
  // Private variable - only accessible to inner functions
  let balance = initialBalance

  return {
    deposit(amount) {
      if (amount > 0) {
        balance += amount
        return balance
      }
    },
    withdraw(amount) {
      if (amount > 0 && amount <= balance) {
        balance -= amount
        return balance
      }
      return "Insufficient funds"
    },
    getBalance() {
      return balance
    }
  }
}

const account = createBankAccount(100)
console.log(account.getBalance())  // 100
account.deposit(50)
console.log(account.getBalance())  // 150
account.withdraw(30)
console.log(account.getBalance())  // 120

// Cannot access balance directly
console.log(account.balance)  // undefined
```

The `balance` variable is truly private. The only way to interact with it is through the methods we provide.

### Why This Matters in Interviews

Interviewers ask about private variables to test:
- Your understanding of closures
- Your knowledge of data encapsulation
- Your ability to create secure, controlled APIs

**Common question:** "How do you create private variables in JavaScript without ES2022 private fields?"

**Answer:** Use closures. Define variables in an outer function and return methods that access them. The variables remain in scope for the methods but are inaccessible from outside.

## Use Case 2: Factory Functions

A **factory function** is a function that returns a new object. When combined with closures, it creates objects with private state.

```javascript
function createPlayer(name) {
  // Private variables
  let score = 0
  let level = 1

  // Public interface
  return {
    getName() {
      return name
    },
    addPoints(points) {
      score += points
      if (score >= 100) {
        level++
        score = 0
      }
    },
    getStats() {
      return {
        name: name,
        level: level,
        score: score
      }
    }
  }
}

const player1 = createPlayer("Alice")
const player2 = createPlayer("Bob")

player1.addPoints(50)
player2.addPoints(120)

console.log(player1.getStats())  // { name: 'Alice', level: 1, score: 50 }
console.log(player2.getStats())  // { name: 'Bob', level: 2, score: 20 }
```

Each player has its own independent closure. Changing `player1`'s score doesn't affect `player2`.

### Factory Functions vs Classes

```javascript
// Class approach - properties are public
class PlayerClass {
  constructor(name) {
    this.name = name
    this.score = 0  // Anyone can modify this
  }
}

const p = new PlayerClass("Alice")
p.score = 9999  // Oops! Direct access

// Factory approach - true privacy
function createPlayer(name) {
  let score = 0  // No direct access
  return {
    addPoints(points) { score += points },
    getScore() { return score }
  }
}

const player = createPlayer("Alice")
player.score = 9999  // Does nothing - score is private
```

Factory functions with closures provide better encapsulation before ES2022 private fields.

## Use Case 3: Function Generators

Closures let you create functions that "remember" configuration.

```javascript
function createGreeting(greeting) {
  // 'greeting' is captured by closure
  return function(name) {
    return `${greeting}, ${name}!`
  }
}

const sayHello = createGreeting("Hello")
const sayHi = createGreeting("Hi")
const sayHey = createGreeting("Hey")

console.log(sayHello("Alice"))  // "Hello, Alice!"
console.log(sayHi("Bob"))       // "Hi, Bob!"
console.log(sayHey("Charlie"))  // "Hey, Charlie!"
```

Each function remembers its own `greeting` value through closure.

### Practical Example: Multiplier Factory

```javascript
function createMultiplier(multiplier) {
  return function(number) {
    return number * multiplier
  }
}

const double = createMultiplier(2)
const triple = createMultiplier(3)
const quadruple = createMultiplier(4)

console.log(double(5))      // 10
console.log(triple(5))      // 15
console.log(quadruple(5))   // 20
```

This pattern is common in functional programming and configuration.

## Use Case 4: Maintaining State

Closures are perfect for maintaining state without global variables.

```javascript
function createCounter() {
  let count = 0

  return {
    increment() {
      return ++count
    },
    decrement() {
      return --count
    },
    reset() {
      count = 0
      return count
    },
    get() {
      return count
    }
  }
}

const counter = createCounter()
console.log(counter.increment())  // 1
console.log(counter.increment())  // 2
console.log(counter.increment())  // 3
console.log(counter.decrement())  // 2
console.log(counter.reset())      // 0
```

The `count` variable persists between function calls but remains private.

### Advanced: Multiple Counters

```javascript
function createCounterManager() {
  const counters = {}

  return {
    create(name) {
      counters[name] = 0
    },
    increment(name) {
      if (counters[name] !== undefined) {
        counters[name]++
      }
    },
    get(name) {
      return counters[name] || 0
    }
  }
}

const manager = createCounterManager()
manager.create("clicks")
manager.create("views")

manager.increment("clicks")
manager.increment("clicks")
manager.increment("views")

console.log(manager.get("clicks"))  // 2
console.log(manager.get("views"))   // 1
```

The `counters` object is completely private and managed through the public interface.

## Use Case 5: Event Handlers

Closures are essential when working with event handlers that need access to specific data.

```javascript
function createButton(buttonName) {
  let clickCount = 0

  return function handleClick() {
    clickCount++
    console.log(`${buttonName} clicked ${clickCount} times`)
  }
}

// In browser:
// const btn1 = document.getElementById('btn1')
// const btn2 = document.getElementById('btn2')
//
// btn1.addEventListener('click', createButton('Button 1'))
// btn2.addEventListener('click', createButton('Button 2'))

// Each button maintains its own click count through closure
```

Each button's handler remembers its own `buttonName` and `clickCount`.

## Use Case 6: Partial Application

Closures enable partial application - creating a new function by pre-filling some arguments.

```javascript
function createApiCaller(baseUrl) {
  // baseUrl is captured by closure
  return function(endpoint, params = {}) {
    const url = `${baseUrl}${endpoint}`
    console.log(`Calling ${url}`, params)
    // In real code: return fetch(url, params)
  }
}

const callUserApi = createApiCaller("https://api.example.com/users")
const callProductApi = createApiCaller("https://api.example.com/products")

callUserApi("/123")           // https://api.example.com/users/123
callProductApi("/search", {}) // https://api.example.com/products/search
```

This reduces repetition and makes code more maintainable.

## Interview Pattern: Module Pattern Preview

The module pattern (covered in detail in lesson 4) uses closures to create modules with private and public parts.

```javascript
const calculator = (function() {
  // Private variables and functions
  let result = 0

  function log(operation, value) {
    console.log(`${operation}: ${value}`)
  }

  // Public API
  return {
    add(n) {
      result += n
      log("Add", n)
      return this
    },
    subtract(n) {
      result -= n
      log("Subtract", n)
      return this
    },
    getResult() {
      return result
    }
  }
})()

calculator.add(10).subtract(3).add(5)
console.log(calculator.getResult())  // 12
console.log(calculator.result)        // undefined - private!
```

This pattern appears frequently in libraries and legacy code.

## Common Mistakes

### Mistake 1: Sharing Closures in Loops (Classic Interview Question)

```javascript
// WRONG - All handlers share the same 'i'
function createHandlers() {
  const handlers = []

  for (var i = 0; i < 3; i++) {
    handlers.push(function() {
      console.log(i)  // Closure over 'i'
    })
  }

  return handlers
}

const handlers = createHandlers()
handlers[0]()  // 3 (not 0!)
handlers[1]()  // 3 (not 1!)
handlers[2]()  // 3 (not 2!)

// FIX 1: Use 'let' instead of 'var'
for (let i = 0; i < 3; i++) {
  handlers.push(function() {
    console.log(i)  // Each iteration has its own 'i'
  })
}

// FIX 2: Create a new closure for each iteration
for (var i = 0; i < 3; i++) {
  handlers.push((function(index) {
    return function() {
      console.log(index)
    }
  })(i))
}
```

This is a classic interview question. Know both fixes.

### Mistake 2: Memory Leaks

```javascript
// Problematic - circular reference
function createLeaky() {
  const data = new Array(1000000).fill('data')

  return function() {
    // Function keeps entire 'data' array alive
    console.log("Function called")
  }
}

// Better - only keep what you need
function createBetter() {
  const data = new Array(1000000).fill('data')
  const dataLength = data.length  // Only keep length

  return function() {
    console.log(`Array had ${dataLength} items`)
    // 'data' can be garbage collected
  }
}
```

Only capture what you actually use in the closure.

## Key Takeaways

- Closures let you create **private variables** that are only accessible through returned methods
- **Factory functions** use closures to create objects with private state
- Closures enable **function generators** that remember configuration
- You can **maintain state** without global variables using closures
- Each function call creates a **new independent closure** with its own variables
- Closures are essential for event handlers and callbacks that need specific data
- Watch out for the classic **loop closure problem** - use `let` or create new scopes

In the next lesson, you'll learn about memory considerations with closures and how to avoid memory leaks.
