---
title: "Module Pattern & Revealing Module Pattern"
description: "Learn to organize code with Module Pattern and Revealing Module Pattern using closures for encapsulation and namespace management"
difficulty: intermediate
estimatedMinutes: 14
priority: essential
roadmap: fullstack
phase: 2
topic: closures-and-scope
learningObjectives:
  - "Implement the Module Pattern using IIFE and closures"
  - "Create modules with private and public members"
  - "Apply the Revealing Module Pattern for cleaner code"
  - "Understand when to use modules vs ES6 modules"
quiz:
  passingScore: 70
  questions:
    - question: "What is the primary purpose of the Module Pattern?"
      type: single
      options:
        - "To create encapsulated code with private and public members"
        - "To make code run faster"
        - "To replace all functions with objects"
        - "To create global variables"
      correctAnswer: "To create encapsulated code with private and public members"
      explanation: "The Module Pattern uses closures to create private variables and functions while exposing only the public API. This provides encapsulation and prevents global namespace pollution."

    - question: "How does the Module Pattern create privacy?"
      type: single
      options:
        - "Uses an IIFE with closures to keep variables in private scope"
        - "Uses the 'private' keyword"
        - "Uses special module syntax"
        - "Encrypts the code"
      correctAnswer: "Uses an IIFE with closures to keep variables in private scope"
      explanation: "The Module Pattern wraps code in an Immediately Invoked Function Expression (IIFE). Variables inside are private to that scope, and the IIFE returns an object with only the public methods, which access private variables through closures."

    - question: "What is the main difference between Module Pattern and Revealing Module Pattern?"
      type: single
      options:
        - "Revealing Module Pattern defines all functions privately and reveals them at the end"
        - "Revealing Module Pattern doesn't use closures"
        - "Revealing Module Pattern is faster"
        - "Module Pattern cannot have private variables"
      correctAnswer: "Revealing Module Pattern defines all functions privately and reveals them at the end"
      explanation: "In Revealing Module Pattern, all functions are defined as private with regular function syntax, then you return an object that 'reveals' which ones are public. This is cleaner and easier to read than the standard Module Pattern."

    - question: "Select all benefits of the Module Pattern."
      type: multiple
      options:
        - "Encapsulation of private data and methods"
        - "Avoids global namespace pollution"
        - "Provides a clear public API"
        - "Automatically makes code asynchronous"
      correctAnswers:
        - "Encapsulation of private data and methods"
        - "Avoids global namespace pollution"
        - "Provides a clear public API"
      explanation: "The Module Pattern provides encapsulation, reduces global variables, and creates a clean public interface. However, it doesn't affect whether code is synchronous or asynchronous."

    - question: "The Module Pattern is still useful even with ES6 modules available."
      type: true-false
      correctAnswer: true
      explanation: "True! While ES6 modules are preferred for new code, the Module Pattern is still useful when: working with legacy code, bundling for older browsers without a build step, or creating singleton-like objects. Understanding it also helps you read older codebases and libraries."
---

# Module Pattern & Revealing Module Pattern

Before ES6 modules, JavaScript developers used closures to organize code into modules. The **Module Pattern** and **Revealing Module Pattern** are design patterns that create encapsulated code with private and public members.

Even though ES6 modules exist, these patterns are still important. They appear in legacy code, libraries, and interviews. Understanding them shows mastery of closures and JavaScript design.

## The Problem: Global Namespace Pollution

Without modules, all code shares the global namespace. This causes problems.

```javascript
// File: utils.js
var counter = 0

function increment() {
  counter++
}

function getCount() {
  return counter
}

// File: analytics.js
var counter = 0  // Oops! Overwrites the first counter

function trackEvent() {
  counter++  // Which counter?
}
```

Everything is global. Name collisions happen. Code is hard to maintain.

## Solution: The Module Pattern

The Module Pattern uses an IIFE (Immediately Invoked Function Expression) and closures to create privacy.

```javascript
const CounterModule = (function() {
  // Private variables
  let counter = 0

  // Private function
  function log(message) {
    console.log(`[Counter] ${message}`)
  }

  // Public API
  return {
    increment: function() {
      counter++
      log(`Incremented to ${counter}`)
    },
    decrement: function() {
      counter--
      log(`Decremented to ${counter}`)
    },
    getCount: function() {
      return counter
    }
  }
})()  // IIFE executes immediately

CounterModule.increment()
CounterModule.increment()
console.log(CounterModule.getCount())  // 2
console.log(CounterModule.counter)      // undefined - private!
```

### How It Works

1. **IIFE** creates a new scope
2. **Private members** are defined inside the IIFE
3. **Public API** is returned as an object
4. **Closures** let public methods access private members
5. **Only the returned object** is accessible from outside

## Module Pattern Structure

```javascript
const ModuleName = (function() {
  // === PRIVATE SECTION ===

  // Private variables
  let privateVar = "private"

  // Private functions
  function privateFunction() {
    return "This is private"
  }

  // === PUBLIC SECTION ===

  return {
    // Public method
    publicMethod: function() {
      // Can access private members
      return privateFunction()
    },

    // Public property
    publicProperty: "public"
  }
})()
```

## Practical Example: Shopping Cart Module

```javascript
const ShoppingCart = (function() {
  // Private state
  let items = []
  let total = 0

  // Private helper
  function calculateTotal() {
    total = items.reduce((sum, item) => sum + item.price, 0)
  }

  // Private validation
  function isValidItem(item) {
    return item && typeof item.price === "number" && item.price > 0
  }

  // Public API
  return {
    addItem: function(item) {
      if (isValidItem(item)) {
        items.push(item)
        calculateTotal()
        return true
      }
      return false
    },

    removeItem: function(itemId) {
      items = items.filter(item => item.id !== itemId)
      calculateTotal()
    },

    getItems: function() {
      // Return copy to prevent external modification
      return [...items]
    },

    getTotal: function() {
      return total
    },

    clear: function() {
      items = []
      total = 0
    }
  }
})()

// Usage
ShoppingCart.addItem({ id: 1, name: "Book", price: 20 })
ShoppingCart.addItem({ id: 2, name: "Pen", price: 5 })

console.log(ShoppingCart.getTotal())  // 25
console.log(ShoppingCart.items)        // undefined - private!

// Can't modify items directly
ShoppingCart.items = []  // Does nothing
console.log(ShoppingCart.getTotal())  // Still 25
```

The cart state is truly private. Users can only interact through the public API.

## The Revealing Module Pattern

The **Revealing Module Pattern** is a variation that makes code cleaner and easier to read.

Instead of mixing private functions with public API objects, you define everything as private functions, then return an object that "reveals" what's public.

```javascript
const UserModule = (function() {
  // All functions defined privately with clear naming
  let currentUser = null

  function login(username, password) {
    // Authentication logic
    if (username && password) {
      currentUser = { username }
      logActivity("logged in")
      return true
    }
    return false
  }

  function logout() {
    if (currentUser) {
      logActivity("logged out")
      currentUser = null
    }
  }

  function getCurrentUser() {
    return currentUser ? { ...currentUser } : null
  }

  function logActivity(action) {
    console.log(`User ${currentUser?.username || "unknown"} ${action}`)
  }

  // Reveal public interface
  return {
    login: login,
    logout: logout,
    getCurrentUser: getCurrentUser
    // logActivity is NOT revealed - stays private
  }
})()
```

### Benefits of Revealing Module Pattern

1. **Consistent syntax**: All functions use the same declaration style
2. **Clear separation**: Easy to see what's public (in return object) vs private
3. **Easier to read**: Function names at top, reveal at bottom
4. **Simpler refactoring**: Change a function from public to private by removing it from return object

### Comparison

```javascript
// Module Pattern
const Module1 = (function() {
  let data = []

  return {
    add: function(item) {  // Inline definition
      data.push(item)
    },
    get: function() {      // Inline definition
      return data
    }
  }
})()

// Revealing Module Pattern
const Module2 = (function() {
  let data = []

  function add(item) {     // Named function
    data.push(item)
  }

  function get() {         // Named function
    return data
  }

  return {                 // Just reveal names
    add: add,
    get: get
  }
})()

// With ES6 shorthand
const Module3 = (function() {
  let data = []

  function add(item) {
    data.push(item)
  }

  function get() {
    return data
  }

  return { add, get }  // Even cleaner
})()
```

## Module Pattern with Dependencies

Modules can depend on other modules by passing them as parameters.

```javascript
const AnalyticsModule = (function($, _) {
  // Now we can use jQuery ($) and Lodash (_)
  let events = []

  function trackEvent(name, data) {
    events.push({
      name,
      data,
      timestamp: Date.now()
    })
  }

  function getEventReport() {
    // Use lodash to group by event name
    return _.groupBy(events, "name")
  }

  function sendToServer() {
    // Use jQuery for AJAX
    $.post("/analytics", { events })
  }

  return {
    track: trackEvent,
    report: getEventReport,
    send: sendToServer
  }
})(jQuery, _)  // Inject dependencies
```

This makes dependencies explicit and allows for easier testing.

## Advanced: Singleton Module

Modules created with IIFE are singletons - only one instance exists.

```javascript
const ConfigModule = (function() {
  // This code runs once
  let config = {
    apiUrl: "https://api.example.com",
    timeout: 5000
  }

  console.log("Config module initialized")

  return {
    get: function(key) {
      return config[key]
    },
    set: function(key, value) {
      config[key] = value
    }
  }
})()

// "Config module initialized" logs once
const c1 = ConfigModule  // Same instance
const c2 = ConfigModule  // Same instance
```

The IIFE runs immediately, creating one instance that is shared.

## Module Pattern vs ES6 Modules

| Feature | Module Pattern | ES6 Modules |
|---------|---------------|-------------|
| Syntax | IIFE + closures | `import`/`export` |
| Privacy | Closure-based | File-based |
| Loading | Immediate | Asynchronous |
| Browser Support | All browsers | Modern + transpilers |
| Tree Shaking | No | Yes |
| Best Use | Legacy, small scripts | New projects |

### When to Use Module Pattern Today

1. **Legacy code**: Maintaining older codebases
2. **No build step**: Simple scripts without bundlers
3. **Single-file modules**: Small utilities
4. **Learning**: Understanding closures and patterns

### Migration Example

```javascript
// Old: Module Pattern
const MathUtils = (function() {
  function add(a, b) {
    return a + b
  }

  function multiply(a, b) {
    return a * b
  }

  return { add, multiply }
})()

// New: ES6 Module (mathUtils.js)
export function add(a, b) {
  return a + b
}

export function multiply(a, b) {
  return a * b
}

// Usage
import { add, multiply } from "./mathUtils.js"
```

ES6 modules are simpler and have better tooling support.

## Common Mistakes

### Mistake 1: Forgetting the IIFE Parentheses

```javascript
// WRONG - Not an IIFE
const Module = function() {
  return { method: function() {} }
}
// Module is a function, not the result

// RIGHT - IIFE
const Module = (function() {
  return { method: function() {} }
})()
// Module is the returned object
```

### Mistake 2: Modifying Returned Objects

```javascript
const Module = (function() {
  let data = []

  return {
    getData: function() {
      return data  // Returns reference!
    }
  }
})()

const items = Module.getData()
items.push("hacked")  // Modifies private data!
```

**Fix: Return copies**

```javascript
getData: function() {
  return [...data]  // Return a copy
}
```

### Mistake 3: Over-engineering

```javascript
// OVERKILL for simple functions
const SimpleUtils = (function() {
  function capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1)
  }
  return { capitalize }
})()

// BETTER - Just use a regular function
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1)
}
```

Use modules when you need privacy and organization, not for every function.

## Interview Tips

### Common Interview Questions

**Q1: "Explain the Module Pattern."**

A: The Module Pattern uses an IIFE to create a private scope. Variables and functions inside are private. The IIFE returns an object with public methods that access private members through closures. This provides encapsulation and prevents global namespace pollution.

**Q2: "What's the difference between Module Pattern and Revealing Module Pattern?"**

A: In the Module Pattern, you define public methods inline in the returned object. In the Revealing Module Pattern, you define all functions privately with clear names, then return an object that reveals which are public. The Revealing pattern is cleaner and easier to read.

**Q3: "When would you use the Module Pattern instead of ES6 modules?"**

A: Use Module Pattern when:
- Working with legacy code
- No build tools available
- Creating simple single-file modules
- Needing singleton behavior
- Supporting very old browsers without transpilation

For new projects, prefer ES6 modules.

## Real-World Example: API Client Module

```javascript
const ApiClient = (function() {
  // Private configuration
  const baseUrl = "https://api.example.com"
  let authToken = null

  // Private helpers
  function buildUrl(endpoint) {
    return `${baseUrl}${endpoint}`
  }

  function getHeaders() {
    const headers = { "Content-Type": "application/json" }
    if (authToken) {
      headers["Authorization"] = `Bearer ${authToken}`
    }
    return headers
  }

  async function request(method, endpoint, data = null) {
    const options = {
      method,
      headers: getHeaders()
    }

    if (data) {
      options.body = JSON.stringify(data)
    }

    const response = await fetch(buildUrl(endpoint), options)
    return response.json()
  }

  // Public API
  return {
    setAuthToken(token) {
      authToken = token
    },

    get(endpoint) {
      return request("GET", endpoint)
    },

    post(endpoint, data) {
      return request("POST", endpoint, data)
    },

    put(endpoint, data) {
      return request("PUT", endpoint, data)
    },

    delete(endpoint) {
      return request("DELETE", endpoint)
    }
  }
})()

// Usage
ApiClient.setAuthToken("abc123")
const users = await ApiClient.get("/users")
const newUser = await ApiClient.post("/users", { name: "Alice" })
```

The implementation details (baseUrl, buildUrl, getHeaders) are private.

## Key Takeaways

- The **Module Pattern** uses IIFE and closures to create encapsulated code
- **Private members** stay inside the IIFE scope
- **Public API** is returned as an object
- **Revealing Module Pattern** defines all functions privately, then reveals public ones
- Modules are **singletons** - only one instance exists
- Module Pattern prevents **global namespace pollution**
- **ES6 modules** are preferred for new code, but Module Pattern is still relevant
- Understanding this pattern helps you read legacy code and master closures

In the next lesson, you'll learn about IIFE (Immediately Invoked Function Expressions) in more detail, including when and why to use them.
