---
title: "Object-Oriented JavaScript - Quick Reference"
description: "Quick reference for OOP concepts in JavaScript including classes, inheritance, and this binding"
estimatedMinutes: 5
difficulty: intermediate
learningObjectives:
  - "Quick reference for Object-Oriented JavaScript concepts"
isCheatSheet: true
cheatSheetTopic: "Object-Oriented JavaScript"
---

# Object-Oriented JavaScript - Quick Reference

## Prototypes

### Prototype Chain

```javascript
function Person(name) {
  this.name = name
}

Person.prototype.greet = function() {
  return `Hello, I'm ${this.name}`
}

const alice = new Person('Alice')
alice.greet() // "Hello, I'm Alice"

// Checking prototypes
Object.getPrototypeOf(alice) === Person.prototype // true
alice.hasOwnProperty('name') // true
alice.hasOwnProperty('greet') // false (on prototype)
```

### Key Methods

| Method | Purpose | Example |
|--------|---------|---------|
| `Object.getPrototypeOf(obj)` | Get object's prototype | `Object.getPrototypeOf(alice)` |
| `Object.create(proto)` | Create object with specific prototype | `Object.create(personMethods)` |
| `obj.hasOwnProperty(prop)` | Check if property is on object itself | `alice.hasOwnProperty('name')` |
| `proto.isPrototypeOf(obj)` | Check if object is in prototype chain | `Person.prototype.isPrototypeOf(alice)` |

---

## Classes (ES6)

### Basic Syntax

```javascript
class Person {
  // Constructor
  constructor(name, age) {
    this.name = name
    this.age = age
  }

  // Instance method
  greet() {
    return `Hello, I'm ${this.name}`
  }

  // Getter
  get info() {
    return `${this.name}, ${this.age}`
  }

  // Setter
  set age(value) {
    if (value < 0) throw new Error('Invalid age')
    this._age = value
  }

  // Static method
  static create(name) {
    return new Person(name, 0)
  }
}

const alice = new Person('Alice', 25)
```

### Class Components

| Component | Syntax | Purpose |
|-----------|--------|---------|
| Constructor | `constructor(args) {}` | Initialize instance |
| Instance method | `method() {}` | Behavior for instances |
| Static method | `static method() {}` | Utility functions on class |
| Getter | `get prop() {}` | Computed property |
| Setter | `set prop(val) {}` | Validate/control assignment |
| Private field | `#field` | Truly private data |

---

## Inheritance

### extends and super

```javascript
// Parent class
class Animal {
  constructor(name) {
    this.name = name
  }

  speak() {
    return `${this.name} makes a sound`
  }
}

// Child class
class Dog extends Animal {
  constructor(name, breed) {
    super(name) // Call parent constructor (must be first)
    this.breed = breed
  }

  // Override method
  speak() {
    return `${super.speak()}, woof!` // Call parent method
  }
}

const dog = new Dog('Buddy', 'Golden')
dog.speak() // "Buddy makes a sound, woof!"
```

### Inheritance Checklist

> **When extending a class:**
>
> - Always call `super()` in child constructor
> - Call `super()` before using `this`
> - Use `super.method()` to call parent methods
> - Child can override parent methods
> - Use `instanceof` to check inheritance

---

## Static Methods & Properties

### Definition and Usage

```javascript
class Config {
  // Static property
  static version = '1.0.0'

  // Static method
  static getVersion() {
    return this.version // 'this' is the class
  }

  // Factory method
  static create(data) {
    return new Config(data)
  }
}

// Call on class, not instance
Config.getVersion() // "1.0.0"

const c = new Config()
c.getVersion() // ❌ Error
```

### When to Use Static vs Instance

| Static | Instance |
|--------|----------|
| No access to `this` (instance) | Has access to `this` |
| Called on class: `Class.method()` | Called on instance: `obj.method()` |
| Utility/helper functions | Behavior specific to instance |
| Factory methods | State manipulation |
| Configuration/constants | Per-instance data |

---

## Getters & Setters

### Syntax

```javascript
class User {
  #age // Private field

  constructor(age) {
    this.#age = age
  }

  // Getter
  get age() {
    return this.#age
  }

  // Setter with validation
  set age(value) {
    if (value < 0 || value > 150) {
      throw new RangeError('Invalid age')
    }
    this.#age = value
  }

  // Computed property
  get isAdult() {
    return this.#age >= 18
  }
}

const user = new User(25)
console.log(user.age) // 25 (looks like property)
user.age = 30 // Uses setter
```

### Common Patterns

| Pattern | Code | Use Case |
|---------|------|----------|
| Computed property | `get total() { return this.a + this.b }` | Calculate from other properties |
| Validation | `set age(v) { if (v < 0) throw... }` | Check values before storing |
| Read-only | `get id() { return this._id }` (no setter) | Prevent external modification |
| Transform | `set name(v) { this._name = v.trim() }` | Clean data on assignment |

---

## Private Fields

### Syntax with #

```javascript
class BankAccount {
  #balance = 0 // Must declare at top

  deposit(amount) {
    this.#balance += amount // Access with #
  }

  get balance() {
    return this.#balance // Controlled access
  }

  // Private method
  #validateAmount(amount) {
    return amount > 0
  }
}

const account = new BankAccount()
account.#balance // ❌ SyntaxError
```

### Private vs Public

| Feature | Public | Private (`#`) |
|---------|--------|---------------|
| Access | Anywhere | Only inside class |
| Syntax | `this.field` | `this.#field` |
| Inheritance | Inherited | Not inherited |
| Encapsulation | None | True privacy |
| Check | `'field' in obj` | `#field in this` |

---

## this Binding

### The Four Rules

```javascript
// 1. Default binding (global or undefined)
function fn() { console.log(this) }
fn() // window or undefined (strict mode)

// 2. Implicit binding (object method)
const obj = {
  name: 'Alice',
  greet() { console.log(this.name) }
}
obj.greet() // 'Alice' - 'this' is obj

// 3. Explicit binding (call, apply, bind)
function greet() { console.log(this.name) }
const person = { name: 'Bob' }
greet.call(person) // 'Bob'
greet.apply(person) // 'Bob'
const bound = greet.bind(person)
bound() // 'Bob'

// 4. new binding (constructor)
function Person(name) { this.name = name }
const p = new Person('Charlie') // 'this' is new object
```

### call, apply, bind Comparison

| Method | Invokes? | Arguments | Returns | Use Case |
|--------|----------|-----------|---------|----------|
| `call(this, arg1, arg2)` | ✅ Yes | Individual | Result | Known number of args |
| `apply(this, [args])` | ✅ Yes | Array | Result | Args in array/arguments |
| `bind(this, ...args)` | ❌ No | Partial | New function | Callbacks, event handlers |

### Arrow Functions and this

```javascript
const obj = {
  name: 'Alice',
  regularFn() {
    console.log(this.name) // 'Alice'
  },
  arrowFn: () => {
    console.log(this.name) // undefined (lexical 'this')
  },
  withCallback() {
    // Regular function loses context
    setTimeout(function() {
      console.log(this.name) // undefined
    }, 1000)

    // Arrow function keeps context
    setTimeout(() => {
      console.log(this.name) // 'Alice'
    }, 1000)
  }
}
```

> **Arrow function rules:**
>
> - No own `this` (uses surrounding scope)
> - Ignores `call`, `apply`, `bind`
> - Cannot be used as constructors
> - Great for callbacks that need parent `this`

---

## Common Patterns

### Factory Functions

```javascript
class User {
  constructor(name, role) {
    this.name = name
    this.role = role
  }

  static createAdmin(name) {
    return new User(name, 'admin')
  }

  static createGuest() {
    return new User('Guest', 'guest')
  }
}

const admin = User.createAdmin('Alice')
```

### Method Chaining

```javascript
class Calculator {
  constructor() { this.value = 0 }

  add(n) {
    this.value += n
    return this // Enable chaining
  }

  multiply(n) {
    this.value *= n
    return this
  }
}

const result = new Calculator()
  .add(5)
  .multiply(2)
  .add(3)
  .value // 13
```

### Encapsulation with Private Fields

```javascript
class Counter {
  #count = 0

  increment() { this.#count++ }
  decrement() { this.#count-- }
  get value() { return this.#count }
  // No setter - read-only from outside
}
```

---

## Quick Decision Guide

### When to Use What

| Situation | Use |
|-----------|-----|
| Need shared methods for objects | Prototypes or Classes |
| Modern codebase | Classes (cleaner syntax) |
| Legacy codebase | Constructor functions + prototype |
| Reusable code without instances | Static methods |
| Computed values | Getters |
| Validate on assignment | Setters |
| Hide implementation | Private fields (`#`) |
| Need inheritance | `extends` and `super` |
| Preserve `this` in callbacks | Arrow functions or `bind()` |
| Utility functions | Static methods |

---

## Common Mistakes

| Mistake | Problem | Solution |
|---------|---------|----------|
| `this.name = ...` in arrow method | `this` is not the instance | Use regular method |
| Forgetting `super()` | Cannot use `this` in child | Call `super()` first |
| `obj.method` as callback | Loses `this` context | Use `bind()` or arrow function |
| Using `_field` for privacy | Not truly private | Use `#field` syntax |
| `set name(v) { this.name = v }` | Infinite loop | Use different internal name (`this._name`) |
| Expensive getter | Runs on every access | Use method or cache result |
| Modifying `Array.prototype` | Breaks existing code | Never modify built-in prototypes |

---

## Interview Quick Hits

| Question | Answer |
|----------|--------|
| What is the prototype chain? | A linked chain of objects where JavaScript looks up properties. Each object has a `[[Prototype]]` link to another object, ending at `null`. |
| What's the difference between `call`, `apply`, and `bind`? | `call()` and `apply()` invoke functions immediately with explicit `this` (call takes args individually, apply takes array). `bind()` returns a new function with permanent `this` binding. |
| How does `this` work in arrow functions? | Arrow functions don't have their own `this` - they inherit it lexically from the surrounding scope. They ignore `call`, `apply`, and `bind`. |
| What are private fields in JavaScript? | Fields prefixed with `#` that are truly private and enforced by JavaScript. Unlike underscore convention (`_field`), they cannot be accessed outside the class. |
| When should you use static methods? | For utility functions, factory methods, or operations that don't require instance data. They're called on the class itself, not instances. |
| What does `super()` do? | Calls the parent class constructor. Must be called before using `this` in a child constructor. Can also call parent methods with `super.methodName()`. |
| Why use getters and setters? | To add validation, create computed properties, enable read-only properties, or trigger side effects when properties are accessed or modified. |
| What's the benefit of prototypes? | Memory efficiency - methods are stored once on the prototype and shared by all instances rather than duplicated per instance. |
