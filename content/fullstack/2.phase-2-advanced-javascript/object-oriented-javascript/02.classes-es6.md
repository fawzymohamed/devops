---
title: "Classes (ES6 Syntax)"
description: "Master ES6 class syntax including constructors, methods, and class expressions"
estimatedMinutes: 8
difficulty: intermediate
learningObjectives:
  - "Write classes using ES6 syntax with constructors and methods"
  - "Understand the difference between class declarations and expressions"
  - "Use instance methods and the constructor method"
  - "Compare classes to constructor functions"
quiz:
  passingScore: 75
  questions:
    - question: "What happens if you try to instantiate a class without using the 'new' keyword?"
      type: single
      options:
        - "It returns undefined"
        - "It throws a TypeError"
        - "It creates the instance successfully"
        - "It returns null"
      correctAnswer: 1
      explanation: "Unlike constructor functions, classes cannot be invoked without 'new'. JavaScript throws a TypeError: 'Class constructor cannot be invoked without new'."
    - question: "How many constructor methods can a class have?"
      type: single
      options:
        - "Only one constructor method is allowed"
        - "As many as needed for different initialization patterns"
        - "Two - one for public and one for private initialization"
        - "Zero - constructors are optional but if present, only one is allowed"
      correctAnswer: 0
      explanation: "A class can have only one constructor method. If you need different initialization patterns, use static factory methods instead."
    - question: "Where are instance methods stored in a class?"
      type: single
      options:
        - "On each instance as own properties"
        - "On the class prototype, shared by all instances"
        - "In global scope as static references"
        - "In a separate methods object"
      correctAnswer: 1
      explanation: "Instance methods are stored on the class prototype and shared by all instances, just like prototype methods in constructor functions. This is memory efficient."
    - question: "Why would you return 'this' from a method?"
      type: single
      options:
        - "To prevent memory leaks"
        - "To enable method chaining"
        - "To make the method private"
        - "To ensure proper garbage collection"
      correctAnswer: 1
      explanation: "Returning 'this' from a method enables method chaining, allowing you to call multiple methods in sequence: obj.method1().method2().method3()"
    - question: "What is the key difference between class declarations and function declarations regarding hoisting?"
      type: single
      options:
        - "Both are hoisted the same way"
        - "Classes are hoisted but functions are not"
        - "Classes are not hoisted, functions are hoisted"
        - "Neither is hoisted in strict mode"
      correctAnswer: 2
      explanation: "Function declarations are hoisted (can be used before declaration), but class declarations are not. You must define a class before using it."
---

# Classes (ES6 Syntax)

ES6 introduced class syntax to JavaScript. Classes make it easier to create objects that share methods. They are cleaner than constructor functions, but they work the same way under the hood.

## What Are Classes?

A class is a template for creating objects. It groups data (properties) and behavior (methods) together. While JavaScript classes look like classes in other languages, they are built on prototypes.

```javascript
class Person {
  constructor(name, age) {
    this.name = name
    this.age = age
  }

  greet() {
    return `Hello, I'm ${this.name} and I'm ${this.age} years old`
  }
}

const alice = new Person('Alice', 25)
console.log(alice.greet()) // "Hello, I'm Alice and I'm 25 years old"
```

## Why Use Classes?

Classes give you a cleaner way to create objects with shared methods:

- **Cleaner syntax**: Easier to read than constructor functions
- **Familiar structure**: Similar to classes in other languages
- **Better tooling**: IDEs can provide better autocomplete
- **Standard pattern**: Most modern JavaScript uses classes

## The Constructor Method

The `constructor` method is special. It runs when you create a new instance with `new`. Use it to set up initial values.

```javascript
class User {
  constructor(username, email) {
    this.username = username
    this.email = email
    this.createdAt = new Date()
  }
}

const user = new User('alice', 'alice@example.com')
console.log(user.username)  // 'alice'
console.log(user.createdAt) // Current date
```

**Rules for constructors:**
- A class can only have one constructor
- The constructor is optional (if you don't need to set up values)
- It runs automatically when you use `new`

## Instance Methods

Methods defined inside the class are added to the prototype. All instances share these methods.

```javascript
class Rectangle {
  constructor(width, height) {
    this.width = width
    this.height = height
  }

  // Instance method
  area() {
    return this.width * this.height
  }

  // Another instance method
  perimeter() {
    return 2 * (this.width + this.height)
  }
}

const rect = new Rectangle(5, 10)
console.log(rect.area())      // 50
console.log(rect.perimeter()) // 30
```

These methods are stored on the prototype, so they use memory efficiently:

```javascript
const rect1 = new Rectangle(5, 10)
const rect2 = new Rectangle(3, 6)

// Both instances share the same method
console.log(rect1.area === rect2.area) // true
```

## Class Structure Visualization

::illustration-linear-flow
---
steps:
  - label: Class Declaration
    sublabel: "Define template"
    icon: üìù
    color: violet
  - label: Constructor
    sublabel: "Initialize instance"
    icon: üèóÔ∏è
    color: blue
  - label: Instance Methods
    sublabel: "Shared behavior"
    icon: ‚öôÔ∏è
    color: emerald
  - label: Create Instance
    sublabel: "new ClassName()"
    icon: ‚ú®
    color: amber
direction: horizontal
---
::

## Class Declarations vs Expressions

You can define classes in two ways:

**Class Declaration:**
```javascript
class Person {
  constructor(name) {
    this.name = name
  }
}
```

**Class Expression:**
```javascript
// Named expression
const Person = class PersonClass {
  constructor(name) {
    this.name = name
  }
}

// Anonymous expression
const Person = class {
  constructor(name) {
    this.name = name
  }
}
```

Both work the same way. Declarations are more common, but expressions are useful when you need to pass a class as a value.

## Methods Without the `function` Keyword

Class methods use shorthand syntax. You do not write `function`:

```javascript
class Calculator {
  // ‚úÖ Correct
  add(a, b) {
    return a + b
  }

  // ‚ùå Wrong (don't use 'function')
  multiply: function(a, b) {
    return a * b
  }
}
```

## The `this` Keyword in Methods

Inside methods, `this` refers to the instance of the class:

```javascript
class Counter {
  constructor() {
    this.count = 0
  }

  increment() {
    this.count++
    return this.count
  }

  getCount() {
    return this.count
  }
}

const counter = new Counter()
counter.increment()
console.log(counter.getCount()) // 1
```

## Method Chaining

You can return `this` from methods to enable chaining:

```javascript
class Calculator {
  constructor() {
    this.value = 0
  }

  add(n) {
    this.value += n
    return this // Return the instance for chaining
  }

  multiply(n) {
    this.value *= n
    return this
  }

  getValue() {
    return this.value
  }
}

const calc = new Calculator()
const result = calc.add(5).multiply(3).add(2).getValue()
console.log(result) // 17 (5 * 3 + 2)
```

## Classes vs Constructor Functions

Classes and constructor functions create the same result, but classes are cleaner:

**Constructor Function:**
```javascript
function Person(name, age) {
  this.name = name
  this.age = age
}

Person.prototype.greet = function() {
  return `Hello, I'm ${this.name}`
}
```

**Class:**
```javascript
class Person {
  constructor(name, age) {
    this.name = name
    this.age = age
  }

  greet() {
    return `Hello, I'm ${this.name}`
  }
}
```

Both create the same prototype chain, but the class syntax is easier to read and write.

## Common Mistakes to Avoid

1. **Forgetting `new`**: You must use `new` to create instances.

```javascript
class Person {
  constructor(name) {
    this.name = name
  }
}

// ‚ùå Wrong
const alice = Person('Alice') // Error: Class constructor Person cannot be invoked without 'new'

// ‚úÖ Correct
const bob = new Person('Bob')
```

2. **Using commas between methods**: Do not add commas.

```javascript
class Calculator {
  add(a, b) {
    return a + b
  } // ‚ùå No comma here
  multiply(a, b) {
    return a * b
  }
}
```

3. **Arrow functions as methods**: Arrow functions do not have their own `this`.

```javascript
class Counter {
  constructor() {
    this.count = 0
  }

  // ‚ùå Arrow function loses 'this' context
  increment = () => {
    this.count++
  }

  // ‚úÖ Use regular method
  increment() {
    this.count++
  }
}
```

## Classes Are Not Hoisted

Unlike function declarations, class declarations are not hoisted. You must define the class before using it.

```javascript
// ‚ùå Error
const alice = new Person('Alice')

class Person {
  constructor(name) {
    this.name = name
  }
}

// ‚úÖ Correct order
class Person {
  constructor(name) {
    this.name = name
  }
}

const bob = new Person('Bob')
```

## Key Takeaways

- Classes are a cleaner syntax for creating objects with shared methods
- The `constructor` method sets up initial values when creating instances
- Instance methods are stored on the prototype and shared by all instances
- Use `new` to create class instances
- Classes work the same as constructor functions but are easier to read
- You can chain methods by returning `this`
- Classes are not hoisted, so define them before use
