---
title: "Static Methods & Properties"
description: "Learn how to use static methods and properties that belong to the class itself, not instances"
estimatedMinutes: 8
difficulty: intermediate
learningObjectives:
  - "Define static methods and properties using the static keyword"
  - "Understand when to use static vs instance methods"
  - "Access static members correctly"
  - "Use static methods for utility functions and factory patterns"
quiz:
  passingScore: 75
  questions:
    - question: "How do you call a static method?"
      type: single
      options:
        - "instance.methodName()"
        - "ClassName.methodName()"
        - "this.methodName()"
        - "super.methodName()"
      correctAnswer: 1
      explanation: "Static methods are called on the class itself, not on instances. Use ClassName.methodName() to invoke them."
    - question: "What does 'this' refer to inside a static method?"
      type: single
      options:
        - "The current instance of the class"
        - "The parent class"
        - "The class itself"
        - "The global object"
      correctAnswer: 2
      explanation: "Inside a static method, 'this' refers to the class itself, not an instance. This allows you to access other static properties and methods."
    - question: "Why would you use static factory methods?"
      type: single
      options:
        - "To make the constructor private"
        - "To provide alternative ways to create instances with clearer intent"
        - "To prevent inheritance"
        - "To improve performance"
      correctAnswer: 1
      explanation: "Static factory methods like User.createAdmin() or User.createGuest() provide clearer, more readable ways to create instances with specific configurations compared to passing multiple constructor parameters."
    - question: "Are static methods inherited by subclasses?"
      type: single
      options:
        - "Yes, static methods are inherited"
        - "No, static methods are not inherited"
        - "Only if you use super"
        - "Only public static methods are inherited"
      correctAnswer: 0
      explanation: "Static methods are inherited by subclasses and can be called on the child class. They can also be overridden in subclasses."
    - question: "When should you use a static method instead of an instance method?"
      type: single
      options:
        - "When the method needs to access instance data"
        - "When the method doesn't need instance data and provides utility functionality"
        - "When you want the method to be private"
        - "When the method modifies instance state"
      correctAnswer: 1
      explanation: "Use static methods for utility functions, factory methods, or operations that don't require access to instance data. If a method needs 'this' to access instance properties, use an instance method."
---

# Static Methods & Properties

Static methods and properties belong to the class itself, not to instances. You call them on the class, not on objects created from the class.

## What Are Static Methods?

A static method is a function that belongs to the class. You call it using the class name, not an instance.

```javascript
class MathHelper {
  static add(a, b) {
    return a + b
  }

  static multiply(a, b) {
    return a * b
  }
}

// Call on the class, not an instance
console.log(MathHelper.add(5, 3))      // 8
console.log(MathHelper.multiply(4, 2)) // 8

// âŒ Cannot call on instance
const helper = new MathHelper()
console.log(helper.add(5, 3)) // Error: helper.add is not a function
```

## Why Use Static Methods?

Static methods are useful when the function does not need instance data:

- **Utility functions**: Math operations, formatting, validation
- **Factory methods**: Alternative ways to create instances
- **Configuration**: Constants or settings
- **Helper functions**: Operations that work with class data but don't need instance state

## Static vs Instance Methods

::illustration-comparison-map
---
leftTitle: Instance Methods
rightTitle: Static Methods
leftColor: blue
rightColor: violet
connections:
  - left: Called on instances
    right: Called on the class
    icon: ðŸ“ž
  - left: Access instance data (this)
    right: No access to this
    icon: ðŸ’¾
  - left: Different per instance
    right: Same for all instances
    icon: ðŸ”„
  - left: Example - user.save()
    right: Example - User.create()
    icon: ðŸ’¡
---
::

## Static Properties

Static properties are values stored on the class itself:

```javascript
class Config {
  static apiUrl = 'https://api.example.com'
  static timeout = 5000
  static version = '1.0.0'
}

console.log(Config.apiUrl)  // "https://api.example.com"
console.log(Config.timeout) // 5000
console.log(Config.version) // "1.0.0"
```

You can also define static properties using the `static` keyword inside the class:

```javascript
class DatabaseConfig {
  static host = 'localhost'
  static port = 5432

  static getConnectionString() {
    return `${this.host}:${this.port}`
  }
}

console.log(DatabaseConfig.getConnectionString()) // "localhost:5432"
```

## Factory Pattern with Static Methods

Static methods are great for creating instances in different ways:

```javascript
class User {
  constructor(name, email, role) {
    this.name = name
    this.email = email
    this.role = role
  }

  // Static factory methods
  static createAdmin(name, email) {
    return new User(name, email, 'admin')
  }

  static createGuest(name) {
    return new User(name, `${name}@guest.com`, 'guest')
  }

  static createFromData(data) {
    return new User(data.name, data.email, data.role)
  }
}

// Use factory methods to create instances
const admin = User.createAdmin('Alice', 'alice@example.com')
const guest = User.createGuest('Bob')
const user = User.createFromData({
  name: 'Charlie',
  email: 'charlie@example.com',
  role: 'user'
})

console.log(admin.role) // 'admin'
console.log(guest.role) // 'guest'
```

## Utility Functions

Static methods work well for operations that do not depend on instance data:

```javascript
class StringHelper {
  static capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1)
  }

  static truncate(str, length) {
    return str.length > length ? str.slice(0, length) + '...' : str
  }

  static slugify(str) {
    return str
      .toLowerCase()
      .trim()
      .replace(/[^\w\s-]/g, '')
      .replace(/[\s_-]+/g, '-')
  }
}

console.log(StringHelper.capitalize('hello'))     // "Hello"
console.log(StringHelper.truncate('Long text', 5)) // "Long..."
console.log(StringHelper.slugify('Hello World!'))  // "hello-world"
```

## Accessing Static Members

Inside static methods, `this` refers to the class itself:

```javascript
class Counter {
  static count = 0

  static increment() {
    this.count++ // 'this' refers to Counter class
    return this.count
  }

  static reset() {
    this.count = 0
  }
}

console.log(Counter.increment()) // 1
console.log(Counter.increment()) // 2
console.log(Counter.count)       // 2
Counter.reset()
console.log(Counter.count)       // 0
```

## Static Methods in Inheritance

Static methods are inherited by subclasses:

```javascript
class Animal {
  static kingdom = 'Animalia'

  static describe() {
    return `Kingdom: ${this.kingdom}`
  }
}

class Dog extends Animal {
  static species = 'Canis familiaris'
}

console.log(Dog.kingdom)    // 'Animalia' (inherited)
console.log(Dog.species)    // 'Canis familiaris'
console.log(Dog.describe()) // "Kingdom: Animalia"
```

You can override static methods in subclasses:

```javascript
class Animal {
  static getType() {
    return 'Generic Animal'
  }
}

class Dog extends Animal {
  static getType() {
    return 'Dog'
  }
}

console.log(Animal.getType()) // "Generic Animal"
console.log(Dog.getType())    // "Dog"
```

## Common Use Cases

### 1. Configuration and Constants

```javascript
class AppConfig {
  static ENV = 'production'
  static MAX_UPLOAD_SIZE = 5 * 1024 * 1024 // 5MB
  static ALLOWED_TYPES = ['image/jpeg', 'image/png']

  static isValidUpload(file) {
    return (
      file.size <= this.MAX_UPLOAD_SIZE &&
      this.ALLOWED_TYPES.includes(file.type)
    )
  }
}
```

### 2. Validation

```javascript
class Validator {
  static isEmail(str) {
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(str)
  }

  static isPhone(str) {
    return /^\d{10}$/.test(str)
  }

  static isURL(str) {
    try {
      new URL(str)
      return true
    } catch {
      return false
    }
  }
}

console.log(Validator.isEmail('test@example.com')) // true
console.log(Validator.isPhone('1234567890'))       // true
```

### 3. Counting Instances

```javascript
class Product {
  static totalProducts = 0

  constructor(name, price) {
    this.name = name
    this.price = price
    Product.totalProducts++ // Access static property
  }

  static getTotalProducts() {
    return Product.totalProducts
  }
}

const p1 = new Product('Laptop', 999)
const p2 = new Product('Mouse', 29)

console.log(Product.getTotalProducts()) // 2
```

## When to Use Static Methods

**Use static methods when:**
- The function does not need instance data
- You need utility or helper functions
- You want factory methods to create instances
- You need constants or configuration

**Use instance methods when:**
- The function needs access to instance data (`this`)
- The behavior differs per instance
- You need to modify instance state

## Common Mistakes to Avoid

1. **Trying to access instance data in static methods**:

```javascript
class User {
  constructor(name) {
    this.name = name
  }

  static greet() {
    // âŒ Error: Cannot access instance property
    return `Hello, ${this.name}`
  }
}
```

2. **Calling static methods on instances**:

```javascript
class Helper {
  static doSomething() {
    return 'Done'
  }
}

const h = new Helper()
console.log(h.doSomething()) // âŒ Error: not a function
console.log(Helper.doSomething()) // âœ… Correct
```

3. **Confusing `this` in static methods**:

```javascript
class Counter {
  static count = 0

  static increment() {
    // 'this' refers to the class (Counter), not an instance
    this.count++
  }
}
```

## Built-in Static Methods

JavaScript has many built-in static methods:

```javascript
// Object static methods
const obj = Object.create(null)
const keys = Object.keys({ a: 1, b: 2 })
const frozen = Object.freeze({ x: 1 })

// Array static methods
const arr = Array.from('hello')  // ['h', 'e', 'l', 'l', 'o']
const isArr = Array.isArray([])  // true

// Number static methods
const num = Number.parseInt('42')   // 42
const valid = Number.isInteger(42)  // true
```

## Key Takeaways

- Static methods and properties belong to the class, not instances
- Use `static` keyword to define them
- Call static methods on the class name: `ClassName.method()`
- Static methods cannot access instance data (`this` refers to the class)
- Great for utility functions, factory methods, and constants
- Static members are inherited by subclasses
- Use static methods when you do not need instance data
