---
title: "Getters & Setters"
description: "Use getters and setters to control access to object properties with validation and computed values"
estimatedMinutes: 8
difficulty: intermediate
learningObjectives:
  - "Define getters and setters using get and set keywords"
  - "Add validation logic in setters"
  - "Create computed properties with getters"
  - "Understand when to use getters and setters vs regular methods"
quiz:
  passingScore: 75
  questions:
    - question: "What happens if you define a setter like 'set name(value) { this.name = value }'?"
      type: single
      options:
        - "It works correctly and stores the value"
        - "It creates an infinite loop"
        - "It throws a syntax error"
        - "It creates a private field automatically"
      correctAnswer: 1
      explanation: "Setting this.name inside the setter calls the setter again, creating an infinite loop. Use a different internal property name like this._name to store the actual value."
    - question: "How do you access a getter?"
      type: single
      options:
        - "obj.getPropertyName()"
        - "obj.propertyName"
        - "obj.get('propertyName')"
        - "obj[getter.propertyName]"
      correctAnswer: 1
      explanation: "Getters are accessed like regular properties without parentheses. Despite being methods, they look like property access: obj.propertyName, not obj.propertyName()."
    - question: "What is a common use case for getters?"
      type: single
      options:
        - "Storing data in the database"
        - "Creating computed properties derived from other properties"
        - "Making methods private"
        - "Improving performance of loops"
      correctAnswer: 1
      explanation: "Getters are ideal for computed properties that are calculated from other properties, like 'get fullName()' that combines firstName and lastName."
    - question: "How do you create a read-only property?"
      type: single
      options:
        - "Use the const keyword"
        - "Define a getter without a setter"
        - "Use Object.freeze()"
        - "Add the readonly keyword"
      correctAnswer: 1
      explanation: "A property with only a getter (no setter) is read-only. Attempting to assign a value to it will fail silently in non-strict mode or throw an error in strict mode."
    - question: "When should you use a regular method instead of a getter?"
      type: single
      options:
        - "When the operation is expensive or has side effects"
        - "When you need to return a value"
        - "When the property depends on other properties"
        - "When you want a clean API"
      correctAnswer: 0
      explanation: "Use regular methods for expensive operations (like complex calculations or database queries) because getters are expected to be lightweight. Getters should not have side effects or be computationally expensive."
---

# Getters & Setters

Getters and setters let you control how properties are accessed and modified. They look like properties but run code when you read or write them.

## What Are Getters and Setters?

A **getter** is a method that runs when you read a property. A **setter** is a method that runs when you write to a property.

```javascript
class Person {
  constructor(firstName, lastName) {
    this.firstName = firstName
    this.lastName = lastName
  }

  // Getter
  get fullName() {
    return `${this.firstName} ${this.lastName}`
  }

  // Setter
  set fullName(value) {
    const parts = value.split(' ')
    this.firstName = parts[0]
    this.lastName = parts[1]
  }
}

const person = new Person('Alice', 'Smith')

// Use getter (looks like a property)
console.log(person.fullName) // "Alice Smith"

// Use setter (looks like a property)
person.fullName = 'Bob Jones'
console.log(person.firstName) // "Bob"
console.log(person.lastName)  // "Jones"
```

## Why Use Getters and Setters?

Getters and setters give you more control than regular properties:

- **Validation**: Check values before setting them
- **Computed properties**: Calculate values on the fly
- **Encapsulation**: Hide internal details
- **Side effects**: Run code when properties change
- **Read-only properties**: Create getters without setters

## How Getters and Setters Work

::illustration-linear-flow
---
steps:
  - label: Access Property
    sublabel: "person.fullName"
    icon: üëÅÔ∏è
    color: blue
  - label: Getter Runs
    sublabel: "get fullName()"
    icon: ‚öôÔ∏è
    color: violet
  - label: Returns Value
    sublabel: "Computed result"
    icon: ‚úÖ
    color: emerald
direction: horizontal
---
::

::illustration-linear-flow
---
steps:
  - label: Set Property
    sublabel: "person.age = 25"
    icon: ‚úèÔ∏è
    color: blue
  - label: Setter Runs
    sublabel: "set age(value)"
    icon: ‚öôÔ∏è
    color: violet
  - label: Validate & Store
    sublabel: "Check and save"
    icon: üíæ
    color: emerald
direction: horizontal
---
::

## Computed Properties with Getters

Getters are great for values calculated from other properties:

```javascript
class Rectangle {
  constructor(width, height) {
    this.width = width
    this.height = height
  }

  get area() {
    return this.width * this.height
  }

  get perimeter() {
    return 2 * (this.width + this.height)
  }
}

const rect = new Rectangle(5, 10)
console.log(rect.area)      // 50 (calculated on access)
console.log(rect.perimeter) // 30

// Update dimensions
rect.width = 8
console.log(rect.area)      // 80 (recalculated)
```

## Validation with Setters

Setters can check values before storing them:

```javascript
class User {
  constructor(name, age) {
    this.name = name
    this.age = age // Uses setter
  }

  get age() {
    return this._age
  }

  set age(value) {
    if (typeof value !== 'number') {
      throw new TypeError('Age must be a number')
    }
    if (value < 0 || value > 150) {
      throw new RangeError('Age must be between 0 and 150')
    }
    this._age = value
  }
}

const user = new User('Alice', 25)
console.log(user.age) // 25

user.age = 30 // ‚úÖ Valid
console.log(user.age) // 30

// ‚ùå Invalid values throw errors
try {
  user.age = -5
} catch (error) {
  console.log(error.message) // "Age must be between 0 and 150"
}

try {
  user.age = '25'
} catch (error) {
  console.log(error.message) // "Age must be a number"
}
```

**Note**: Use `_age` as the internal property name. If you use `age`, the setter calls itself forever (infinite loop).

## Read-Only Properties

Create a getter without a setter to make a property read-only:

```javascript
class Circle {
  constructor(radius) {
    this._radius = radius
  }

  get radius() {
    return this._radius
  }

  get diameter() {
    return this._radius * 2
  }

  get area() {
    return Math.PI * this._radius * this._radius
  }
}

const circle = new Circle(5)
console.log(circle.radius)   // 5
console.log(circle.diameter) // 10
console.log(circle.area)     // 78.54

// ‚ùå Cannot modify (no setter)
circle.diameter = 20 // Does nothing (or error in strict mode)
console.log(circle.diameter) // Still 10
```

## Private Properties with Getters/Setters

Combine getters and setters with private fields for true encapsulation:

```javascript
class BankAccount {
  #balance = 0

  constructor(initialBalance) {
    this.#balance = initialBalance
  }

  get balance() {
    return this.#balance
  }

  set balance(value) {
    if (value < 0) {
      throw new Error('Balance cannot be negative')
    }
    this.#balance = value
  }

  deposit(amount) {
    if (amount <= 0) {
      throw new Error('Deposit must be positive')
    }
    this.balance += amount // Uses setter
  }

  withdraw(amount) {
    if (amount > this.balance) {
      throw new Error('Insufficient funds')
    }
    this.balance -= amount // Uses setter
  }
}

const account = new BankAccount(100)
console.log(account.balance) // 100

account.deposit(50)
console.log(account.balance) // 150

// ‚ùå Cannot access private field directly
console.log(account.#balance) // Syntax error
```

## Getters and Setters in Object Literals

You can also use getters and setters in plain objects:

```javascript
const person = {
  firstName: 'Alice',
  lastName: 'Smith',

  get fullName() {
    return `${this.firstName} ${this.lastName}`
  },

  set fullName(value) {
    const parts = value.split(' ')
    this.firstName = parts[0]
    this.lastName = parts[1]
  }
}

console.log(person.fullName) // "Alice Smith"
person.fullName = 'Bob Jones'
console.log(person.firstName) // "Bob"
```

## Side Effects with Setters

Setters can trigger other actions when a property changes:

```javascript
class Temperature {
  constructor(celsius) {
    this._celsius = celsius
    this._listeners = []
  }

  get celsius() {
    return this._celsius
  }

  set celsius(value) {
    this._celsius = value
    this._notifyListeners() // Side effect
  }

  get fahrenheit() {
    return (this._celsius * 9/5) + 32
  }

  set fahrenheit(value) {
    this.celsius = (value - 32) * 5/9 // Uses celsius setter
  }

  onChange(callback) {
    this._listeners.push(callback)
  }

  _notifyListeners() {
    this._listeners.forEach(fn => fn(this._celsius))
  }
}

const temp = new Temperature(20)

temp.onChange(celsius => {
  console.log(`Temperature changed to ${celsius}¬∞C`)
})

temp.celsius = 25    // Logs: "Temperature changed to 25¬∞C"
temp.fahrenheit = 86 // Logs: "Temperature changed to 30¬∞C"
```

## When to Use Getters and Setters

**Use getters and setters when:**
- You need to compute values from other properties
- You want to validate data before storing
- You need to trigger side effects on property changes
- You want to create read-only properties
- You want a clean API that looks like properties

**Use regular methods when:**
- The operation is expensive (use `getArea()` method instead)
- You need parameters (setters only take one value)
- The name should suggest an action (use `calculate()` not `get calculate()`)

## Common Mistakes to Avoid

1. **Infinite loops with setters**:

```javascript
class User {
  set name(value) {
    this.name = value // ‚ùå Calls itself forever!
  }
}

// ‚úÖ Use a different property name
class User {
  set name(value) {
    this._name = value // Store in _name
  }

  get name() {
    return this._name
  }
}
```

2. **Forgetting `get` or `set` keyword**:

```javascript
class Person {
  // ‚ùå This is a regular method, not a getter
  fullName() {
    return `${this.firstName} ${this.lastName}`
  }

  // ‚úÖ This is a getter
  get fullName() {
    return `${this.firstName} ${this.lastName}`
  }
}

const p = new Person()
console.log(p.fullName)   // With getter: returns string
console.log(p.fullName()) // Without getter: call as function
```

3. **Expensive operations in getters**:

```javascript
class DataProcessor {
  // ‚ùå Bad: expensive operation
  get processedData() {
    return this.data.map(heavy_processing) // Runs every time!
  }

  // ‚úÖ Better: use a method or cache the result
  processData() {
    if (!this._cachedResult) {
      this._cachedResult = this.data.map(heavy_processing)
    }
    return this._cachedResult
  }
}
```

## Getters and Setters with Inheritance

Getters and setters are inherited like regular methods:

```javascript
class Shape {
  get type() {
    return 'Generic Shape'
  }
}

class Circle extends Shape {
  constructor(radius) {
    super()
    this._radius = radius
  }

  get area() {
    return Math.PI * this._radius * this._radius
  }

  // Override parent getter
  get type() {
    return 'Circle'
  }
}

const circle = new Circle(5)
console.log(circle.type) // "Circle" (overridden)
console.log(circle.area) // 78.54 (own getter)
```

## Key Takeaways

- Getters and setters control access to properties
- Use `get` keyword for getters and `set` keyword for setters
- Getters look like properties but run code when accessed
- Setters can validate data before storing it
- Create computed properties with getters
- Create read-only properties by using getter without setter
- Avoid infinite loops by using different internal property names (like `_age`)
- Use regular methods for expensive operations or when you need parameters
