---
title: "Private Fields (#privateField)"
description: "Use private fields with # syntax to truly encapsulate class data"
estimatedMinutes: 8
difficulty: intermediate
learningObjectives:
  - "Define private fields using # syntax"
  - "Understand the difference between private fields and underscore convention"
  - "Use private methods for internal logic"
  - "Combine private fields with getters and setters for controlled access"
quiz:
  passingScore: 75
  questions:
    - question: "What is the main difference between '_field' and '#field' in a class?"
      type: single
      options:
        - "They are identical - both create private fields"
        - "'#field' is truly private and enforced by JavaScript, '_field' is just a naming convention"
        - "'_field' is private, '#field' is protected"
        - "'#field' is slower but more secure"
      correctAnswer: 1
      explanation: "The underscore convention (_field) is a social contract suggesting developers shouldn't access the property, but it's still accessible. Private fields (#field) are enforced by JavaScript and truly cannot be accessed outside the class."
    - question: "Where must private fields be declared?"
      type: single
      options:
        - "In the constructor only"
        - "At the top of the class body"
        - "Anywhere inside the class"
        - "In a separate configuration file"
      correctAnswer: 1
      explanation: "Private fields must be declared at the top of the class body before they can be used. You cannot dynamically add private fields in the constructor without declaring them first."
    - question: "Are private fields inherited by child classes?"
      type: single
      options:
        - "Yes, all private fields are inherited"
        - "No, private fields are not inherited"
        - "Only if you use super"
        - "Only public private fields are inherited"
      correctAnswer: 1
      explanation: "Private fields are not inherited by subclasses. Each class maintains its own private fields. Child classes must access parent private fields through public methods."
    - question: "What happens if you try to access a private field from outside the class?"
      type: single
      options:
        - "JavaScript returns undefined"
        - "JavaScript throws a SyntaxError"
        - "JavaScript returns null"
        - "JavaScript creates the field automatically"
      correctAnswer: 1
      explanation: "Attempting to access a private field (e.g., obj.#field) from outside the class results in a SyntaxError: 'Private field must be declared in an enclosing class'."
    - question: "Why would you combine private fields with getters and setters?"
      type: single
      options:
        - "To make the code run faster"
        - "To provide controlled access with validation while keeping data truly private"
        - "To enable inheritance"
        - "To reduce memory usage"
      correctAnswer: 1
      explanation: "Combining private fields with getters/setters gives you the best of both worlds: true encapsulation (data can't be directly accessed) plus controlled access with validation logic."
---

# Private Fields (#privateField)

Private fields let you hide data inside a class. Only code inside the class can access them. This gives you true encapsulation.

## What Are Private Fields?

A private field is a property that starts with `#`. It can only be accessed from inside the class.

```javascript
class BankAccount {
  #balance = 0 // Private field

  constructor(initialBalance) {
    this.#balance = initialBalance
  }

  deposit(amount) {
    this.#balance += amount
  }

  getBalance() {
    return this.#balance
  }
}

const account = new BankAccount(100)
account.deposit(50)
console.log(account.getBalance()) // 150

// ‚ùå Cannot access private field from outside
console.log(account.#balance) // SyntaxError: Private field '#balance' must be declared in an enclosing class
```

## Why Use Private Fields?

Private fields protect your data:

- **Encapsulation**: Hide internal details
- **Prevent misuse**: Users cannot modify data incorrectly
- **Safe refactoring**: Change internal structure without breaking code
- **Clear API**: Public methods show what users should use

## Private vs Public Fields

::illustration-comparison-map
---
leftTitle: Public Fields
rightTitle: Private Fields
leftColor: blue
rightColor: violet
connections:
  - left: Accessible anywhere
    right: Only inside class
    icon: üîí
  - left: "this.name"
    right: "this.#name"
    icon: üìù
  - left: Part of public API
    right: Implementation detail
    icon: üèóÔ∏è
  - left: Can be modified externally
    right: Protected from outside
    icon: üõ°Ô∏è
---
::

## Declaring Private Fields

You must declare private fields at the top of the class:

```javascript
class User {
  // Declare private fields
  #id
  #password

  // Public field
  username

  constructor(username, password) {
    this.#id = Math.random().toString(36)
    this.#password = password
    this.username = username
  }

  verifyPassword(input) {
    return this.#password === input
  }
}

const user = new User('alice', 'secret123')
console.log(user.username)         // 'alice' (public)
console.log(user.#password)        // ‚ùå SyntaxError
console.log(user.verifyPassword('secret123')) // true
```

## Private Fields with Initial Values

You can set default values for private fields:

```javascript
class Counter {
  #count = 0      // Private with default value
  #maxCount = 100 // Private constant

  increment() {
    if (this.#count < this.#maxCount) {
      this.#count++
    }
  }

  getCount() {
    return this.#count
  }
}

const counter = new Counter()
counter.increment()
console.log(counter.getCount()) // 1
```

## Private Methods

You can also make methods private using `#`:

```javascript
class DataProcessor {
  #data = []

  addData(item) {
    if (this.#isValid(item)) { // Private method
      this.#data.push(item)
    }
  }

  // Private validation method
  #isValid(item) {
    return item !== null && item !== undefined
  }

  getData() {
    return [...this.#data] // Return copy to protect original
  }
}

const processor = new DataProcessor()
processor.addData('test')
console.log(processor.getData()) // ['test']

// ‚ùå Cannot call private method
processor.#isValid('test') // SyntaxError
```

## Private Fields vs Underscore Convention

Before private fields, developers used `_` to show a property was internal:

```javascript
// Old convention (not truly private)
class OldWay {
  constructor(value) {
    this._value = value // Convention: treat as private
  }
}

const obj = new OldWay(10)
console.log(obj._value) // 10 - still accessible! ‚ö†Ô∏è

// New way (truly private)
class NewWay {
  #value

  constructor(value) {
    this.#value = value
  }
}

const obj2 = new NewWay(10)
console.log(obj2.#value) // ‚ùå SyntaxError
```

The underscore convention is a **social contract** (please don't touch). Private fields are **enforced by JavaScript** (you cannot touch).

## Controlled Access with Getters and Setters

Combine private fields with getters and setters for controlled access:

```javascript
class Temperature {
  #celsius = 0

  get celsius() {
    return this.#celsius
  }

  set celsius(value) {
    if (typeof value !== 'number') {
      throw new TypeError('Temperature must be a number')
    }
    if (value < -273.15) {
      throw new RangeError('Temperature cannot go below absolute zero')
    }
    this.#celsius = value
  }

  get fahrenheit() {
    return (this.#celsius * 9/5) + 32
  }

  set fahrenheit(value) {
    this.celsius = (value - 32) * 5/9 // Uses celsius setter
  }
}

const temp = new Temperature()
temp.celsius = 25
console.log(temp.fahrenheit) // 77

// ‚ùå Validation prevents invalid values
try {
  temp.celsius = -300
} catch (error) {
  console.log(error.message) // "Temperature cannot go below absolute zero"
}
```

## Private Static Fields

Static fields can also be private:

```javascript
class Database {
  static #connection = null
  static #maxConnections = 10

  static getConnection() {
    if (!this.#connection) {
      this.#connection = this.#createConnection()
    }
    return this.#connection
  }

  static #createConnection() {
    // Private static method
    return { connected: true }
  }
}

const conn = Database.getConnection()
console.log(conn.connected) // true

// ‚ùå Cannot access private static fields
console.log(Database.#connection) // SyntaxError
```

## Private Fields in Inheritance

Private fields are **not inherited**. Subclasses cannot access parent private fields:

```javascript
class Parent {
  #secret = 'parent secret'

  getSecret() {
    return this.#secret
  }
}

class Child extends Parent {
  revealSecret() {
    // ‚ùå Cannot access parent's private field
    return this.#secret // SyntaxError
  }

  getParentSecret() {
    // ‚úÖ Can call public method
    return this.getSecret()
  }
}

const child = new Child()
console.log(child.getParentSecret()) // "parent secret"
```

Each class can have its own private fields with the same name:

```javascript
class Parent {
  #value = 'parent'

  getValue() {
    return this.#value
  }
}

class Child extends Parent {
  #value = 'child' // Different private field

  getChildValue() {
    return this.#value
  }
}

const child = new Child()
console.log(child.getValue())      // "parent"
console.log(child.getChildValue()) // "child"
```

## Checking for Private Fields

Use `in` to check if an object has a private field (inside the class only):

```javascript
class Wallet {
  #balance

  constructor(balance) {
    this.#balance = balance
  }

  hasBalance() {
    return #balance in this
  }
}

const wallet = new Wallet(100)
console.log(wallet.hasBalance()) // true
```

## Real-World Example

```javascript
class TodoList {
  #todos = []
  #nextId = 1

  addTodo(text) {
    const todo = {
      id: this.#nextId++,
      text,
      completed: false,
      createdAt: new Date()
    }
    this.#todos.push(todo)
    return todo.id
  }

  completeTodo(id) {
    const todo = this.#findTodoById(id)
    if (todo) {
      todo.completed = true
    }
  }

  getTodos() {
    // Return copy to prevent external modification
    return this.#todos.map(todo => ({ ...todo }))
  }

  #findTodoById(id) {
    return this.#todos.find(todo => todo.id === id)
  }
}

const list = new TodoList()
const id = list.addTodo('Learn JavaScript')
list.completeTodo(id)

const todos = list.getTodos()
console.log(todos) // [{ id: 1, text: 'Learn JavaScript', completed: true, ... }]

// ‚ùå Cannot access private data
console.log(list.#todos)   // SyntaxError
list.#findTodoById(1)      // SyntaxError
```

## When to Use Private Fields

**Use private fields when:**
- Data should not be modified from outside
- You want to enforce validation
- Internal implementation may change
- You need true encapsulation

**Use public fields when:**
- Users need direct access to the data
- The property is part of your public API
- Validation is not needed

## Common Mistakes to Avoid

1. **Forgetting to declare private fields**:

```javascript
class User {
  // ‚ùå Must declare at top
  constructor(name) {
    this.#name = name // SyntaxError: Private field '#name' must be declared
  }
}

// ‚úÖ Correct
class User {
  #name // Declare here

  constructor(name) {
    this.#name = name
  }
}
```

2. **Using underscore and thinking it's private**:

```javascript
class Data {
  constructor() {
    this._private = 'not really' // ‚ö†Ô∏è Still accessible
  }
}

const d = new Data()
console.log(d._private) // Works (but shouldn't be used)
```

3. **Accessing private fields from outside**:

```javascript
class Secret {
  #data = 'secret'
}

const s = new Secret()
console.log(s.#data)      // ‚ùå SyntaxError
console.log(s['#data'])   // ‚ùå undefined (not accessible this way either)
```

## Browser Support

Private fields are supported in:
- Chrome 74+
- Firefox 90+
- Safari 14.1+
- Node.js 12+

For older browsers, use build tools like Babel to transpile the code.

## Key Takeaways

- Private fields use `#` syntax and are truly private
- They can only be accessed inside the class
- Must be declared at the top of the class
- Private methods use the same `#` syntax
- Not inherited by subclasses
- Combine with getters and setters for controlled access
- More secure than underscore convention
- Use for data that should not be modified externally
