---
title: "Inheritance (extends, super)"
description: "Learn how to create class hierarchies using extends and super keywords"
estimatedMinutes: 8
difficulty: intermediate
learningObjectives:
  - "Use extends to create subclasses that inherit from parent classes"
  - "Call parent constructors and methods using super"
  - "Understand method overriding in subclasses"
  - "Design class hierarchies for code reuse"
quiz:
  passingScore: 75
  questions:
    - question: "If a child class has a constructor, when must you call super()?"
      type: single
      options:
        - "At any point before the constructor ends"
        - "Before using 'this' in the constructor"
        - "After initializing all child properties"
        - "Only if you want to access parent properties"
      correctAnswer: 1
      explanation: "You must call super() before using 'this' in a child constructor. Attempting to use 'this' before super() throws a ReferenceError."
    - question: "What does super.method() do in a child class?"
      type: single
      options:
        - "Creates a new instance of the parent class"
        - "Calls the method from the parent class"
        - "Overrides the parent method permanently"
        - "Makes the method static"
      correctAnswer: 1
      explanation: "super.method() calls the parent class version of the method. This is useful when you want to extend parent functionality rather than completely replace it."
    - question: "What happens if a child class does not define a constructor?"
      type: single
      options:
        - "The child class throws an error when instantiated"
        - "The child class automatically calls the parent constructor"
        - "The child class has no constructor at all"
        - "JavaScript creates an empty constructor with no parameters"
      correctAnswer: 1
      explanation: "If a child class has no constructor, JavaScript automatically creates one that calls super() with all arguments passed to it."
    - question: "Which operator checks if an object is an instance of a class or its parent classes?"
      type: single
      options:
        - "typeof"
        - "instanceof"
        - "isPrototypeOf"
        - "extends"
      correctAnswer: 1
      explanation: "The instanceof operator checks if an object is an instance of a class or any class in its inheritance chain. For example: dog instanceof Animal returns true if Dog extends Animal."
    - question: "When should you prefer composition over inheritance?"
      type: single
      options:
        - "When you need an 'is-a' relationship"
        - "When you need a 'has-a' relationship or need features from multiple sources"
        - "When the parent class is abstract"
        - "When working with legacy code"
      correctAnswer: 1
      explanation: "Use composition (has-a relationship) when an object needs functionality from multiple sources or when forcing an inheritance relationship doesn't make logical sense. For example, a Car 'has an' Engine rather than 'is an' Engine."
---

# Inheritance (extends, super)

Inheritance lets you create new classes based on existing classes. The new class gets all the properties and methods of the parent class. You can then add new features or change existing ones.

## What Is Inheritance?

Inheritance is when one class extends another class. The child class (subclass) inherits from the parent class (superclass).

```javascript
// Parent class
class Animal {
  constructor(name) {
    this.name = name
  }

  speak() {
    return `${this.name} makes a sound`
  }
}

// Child class extends parent
class Dog extends Animal {
  bark() {
    return `${this.name} barks: Woof!`
  }
}

const dog = new Dog('Buddy')
console.log(dog.speak()) // "Buddy makes a sound" (from Animal)
console.log(dog.bark())  // "Buddy barks: Woof!" (from Dog)
```

## Why Use Inheritance?

Inheritance helps you reuse code and create relationships between classes:

- **Code reuse**: Child classes get parent methods automatically
- **Logical hierarchy**: Model real-world relationships
- **Less duplication**: Write common code once in the parent
- **Easy maintenance**: Update parent class to affect all children

## Class Hierarchy

::illustration-linear-flow
---
steps:
  - label: Animal
    sublabel: "Base class"
    icon: ü¶Å
    color: violet
  - label: Dog extends Animal
    sublabel: "Inherits speak()"
    icon: üêï
    color: blue
  - label: Cat extends Animal
    sublabel: "Inherits speak()"
    icon: üêà
    color: emerald
direction: horizontal
---
::

## The `extends` Keyword

Use `extends` to create a subclass:

```javascript
class Vehicle {
  constructor(brand) {
    this.brand = brand
  }

  start() {
    return `${this.brand} is starting...`
  }
}

class Car extends Vehicle {
  constructor(brand, model) {
    super(brand) // Call parent constructor
    this.model = model
  }

  display() {
    return `${this.brand} ${this.model}`
  }
}

const car = new Car('Toyota', 'Camry')
console.log(car.start())   // "Toyota is starting..." (inherited)
console.log(car.display()) // "Toyota Camry" (own method)
```

## The `super` Keyword

`super` has two uses:

1. **Call the parent constructor**: `super(args)`
2. **Call parent methods**: `super.methodName()`

### Calling Parent Constructor

When a child class has a constructor, you must call `super()` before using `this`:

```javascript
class Person {
  constructor(name) {
    this.name = name
  }
}

class Employee extends Person {
  constructor(name, jobTitle) {
    super(name) // Must call parent constructor first
    this.jobTitle = jobTitle
  }
}

const emp = new Employee('Alice', 'Engineer')
console.log(emp.name)     // 'Alice'
console.log(emp.jobTitle) // 'Engineer'
```

**Important**: If you do not call `super()` before using `this`, you get an error:

```javascript
class Employee extends Person {
  constructor(name, jobTitle) {
    // ‚ùå Error: Must call super before accessing 'this'
    this.jobTitle = jobTitle
    super(name)
  }
}
```

### Calling Parent Methods

Use `super.methodName()` to call methods from the parent class:

```javascript
class Animal {
  speak() {
    return 'Animal makes a sound'
  }
}

class Dog extends Animal {
  speak() {
    const parentSpeak = super.speak() // Call parent method
    return `${parentSpeak}, and the dog barks`
  }
}

const dog = new Dog()
console.log(dog.speak()) // "Animal makes a sound, and the dog barks"
```

## Method Overriding

A child class can replace (override) methods from the parent:

```javascript
class Shape {
  area() {
    return 0
  }
}

class Rectangle extends Shape {
  constructor(width, height) {
    super()
    this.width = width
    this.height = height
  }

  // Override the area method
  area() {
    return this.width * this.height
  }
}

class Circle extends Shape {
  constructor(radius) {
    super()
    this.radius = radius
  }

  // Override with different calculation
  area() {
    return Math.PI * this.radius * this.radius
  }
}

const rect = new Rectangle(5, 10)
const circle = new Circle(7)

console.log(rect.area())   // 50
console.log(circle.area()) // 153.94
```

## Inheritance Chain

You can have multiple levels of inheritance:

```javascript
class LivingBeing {
  breathe() {
    return 'Breathing...'
  }
}

class Animal extends LivingBeing {
  move() {
    return 'Moving...'
  }
}

class Dog extends Animal {
  bark() {
    return 'Woof!'
  }
}

const dog = new Dog()
console.log(dog.breathe()) // From LivingBeing
console.log(dog.move())    // From Animal
console.log(dog.bark())    // From Dog
```

## Constructor Rules

**If child has no constructor:**
The parent constructor is used automatically.

```javascript
class Animal {
  constructor(name) {
    this.name = name
  }
}

class Dog extends Animal {
  // No constructor - parent constructor is used
}

const dog = new Dog('Buddy')
console.log(dog.name) // 'Buddy'
```

**If child has a constructor:**
You must call `super()` and it must be the first thing you do.

```javascript
class Employee extends Person {
  constructor(name, jobTitle) {
    super(name)           // ‚úÖ Call super first
    this.jobTitle = jobTitle
  }
}
```

## Checking Inheritance

Use `instanceof` to check if an object is an instance of a class or its parent:

```javascript
class Animal {}
class Dog extends Animal {}

const dog = new Dog()

console.log(dog instanceof Dog)    // true
console.log(dog instanceof Animal) // true
console.log(dog instanceof Object) // true (everything extends Object)
```

## When to Use Inheritance

**Good use cases:**
- Clear "is-a" relationship (Dog **is an** Animal)
- Shared behavior across multiple classes
- Logical hierarchy that matches your domain

**When to avoid:**
- Forcing relationships that don't make sense
- Deep inheritance chains (hard to understand)
- When composition would be simpler

```javascript
// ‚úÖ Good: Dog is an Animal
class Animal {}
class Dog extends Animal {}

// ‚ùå Bad: Car is not a Vehicle and an Engine
class Vehicle {}
class Engine {}
// Can't extend both - use composition instead
class Car {
  constructor() {
    this.engine = new Engine()
  }
}
```

## Common Mistakes to Avoid

1. **Forgetting `super()`**: You must call it in child constructors.

```javascript
class Parent {
  constructor(name) {
    this.name = name
  }
}

class Child extends Parent {
  constructor(name, age) {
    // ‚ùå Missing super()
    this.age = age // Error!
  }
}
```

2. **Using `this` before `super()`**: Call `super()` first.

```javascript
class Child extends Parent {
  constructor(name, age) {
    this.age = age // ‚ùå Error: 'this' before super()
    super(name)
  }
}
```

3. **Over-using inheritance**: Sometimes composition is better.

```javascript
// ‚ùå Complex inheritance
class User {}
class AdminUser extends User {}
class SuperAdminUser extends AdminUser {}

// ‚úÖ Better: composition
class User {
  constructor(role) {
    this.role = role
  }
}
```

## Inheritance vs Composition

**Inheritance**: "Is-a" relationship
```javascript
class Dog extends Animal {} // Dog IS AN Animal
```

**Composition**: "Has-a" relationship
```javascript
class Car {
  constructor() {
    this.engine = new Engine() // Car HAS AN Engine
  }
}
```

Use inheritance for clear hierarchies. Use composition when an object needs functionality from multiple sources.

## Key Takeaways

- Use `extends` to create a subclass that inherits from a parent class
- Call `super()` in the child constructor to initialize the parent
- Use `super.method()` to call parent methods
- Child classes can override parent methods
- Always call `super()` before using `this` in child constructors
- Use inheritance for "is-a" relationships, composition for "has-a"
- Avoid deep inheritance chains - keep hierarchies simple
