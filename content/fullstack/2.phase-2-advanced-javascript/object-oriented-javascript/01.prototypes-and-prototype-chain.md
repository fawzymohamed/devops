---
title: "Prototypes & Prototype Chain"
description: "Learn how JavaScript uses prototypes for inheritance and how the prototype chain works"
estimatedMinutes: 8
difficulty: intermediate
learningObjectives:
  - "Understand what prototypes are and how they work in JavaScript"
  - "Explain how the prototype chain enables property lookup"
  - "Use prototype-based inheritance to share methods"
  - "Identify when to use prototypes vs classes"
quiz:
  passingScore: 75
  questions:
    - question: "Why do all instances of a constructor function share the same prototype methods?"
      type: single
      options:
        - "Methods are stored once on the prototype and referenced by all instances"
        - "JavaScript automatically copies methods to each instance"
        - "Each instance has its own copy but they are synchronized"
        - "Methods are stored in global memory and accessed from there"
      correctAnswer: 0
      explanation: "Methods on the prototype are stored once and shared by all instances through the prototype chain. This is memory efficient because the method exists in only one location."
    - question: "What happens when you access a property that doesn't exist on an object or its prototype chain?"
      type: single
      options:
        - "JavaScript throws a ReferenceError"
        - "JavaScript returns null"
        - "JavaScript returns undefined"
        - "JavaScript creates the property with a default value"
      correctAnswer: 2
      explanation: "When JavaScript reaches the end of the prototype chain (null) without finding the property, it returns undefined. No error is thrown."
    - question: "Which statement correctly checks if a property exists on the object itself (not on its prototype)?"
      type: single
      options:
        - "obj.hasOwnProperty('name')"
        - "obj.hasPrototype('name')"
        - "'name' in obj"
        - "obj.prototype.has('name')"
      correctAnswer: 0
      explanation: "hasOwnProperty() checks if a property exists directly on the object, not on its prototype chain. The 'in' operator checks both the object and its prototype chain."
    - question: "What is the main difference between constructor functions with prototypes and ES6 classes?"
      type: single
      options:
        - "Classes use a completely different inheritance mechanism"
        - "Classes are syntactic sugar - they use prototypes under the hood"
        - "Classes are faster because they don't use prototypes"
        - "Constructor functions are deprecated and should not be used"
      correctAnswer: 1
      explanation: "ES6 classes are syntactic sugar over constructor functions and prototypes. They provide a cleaner syntax but work the same way internally."
---

# Prototypes & Prototype Chain

JavaScript uses prototypes for inheritance. Every object has a hidden link to another object. This link creates a chain that JavaScript uses to find properties and methods.

## What Are Prototypes?

A prototype is an object that other objects can inherit from. When you try to access a property on an object, JavaScript first looks at the object itself. If it does not find the property, it looks at the object's prototype. This continues up the chain until it finds the property or reaches the end.

```javascript
// Every function has a prototype property
function Person(name) {
  this.name = name
}

// Add a method to the prototype
Person.prototype.greet = function() {
  return `Hello, I'm ${this.name}`
}

// Create instances
const alice = new Person('Alice')
const bob = new Person('Bob')

console.log(alice.greet()) // "Hello, I'm Alice"
console.log(bob.greet())   // "Hello, I'm Bob"

// Both instances share the same method
console.log(alice.greet === bob.greet) // true
```

## Why Prototypes Matter

Prototypes are how JavaScript shares methods between objects. Without prototypes, every object would have its own copy of every method. This uses more memory and makes updates harder.

**Benefits:**
- **Memory efficient**: Methods are stored once in the prototype
- **Dynamic updates**: Change the prototype and all instances get the update
- **Inheritance chain**: Objects can inherit from other objects

## The Prototype Chain

Every object has an internal link called `[[Prototype]]`. You can access it using `Object.getPrototypeOf()` or the `__proto__` property (though `__proto__` is not recommended).

::illustration-linear-flow
---
steps:
  - label: Object Instance
    sublabel: "{ name: 'Alice' }"
    icon: üì¶
    color: blue
  - label: Constructor Prototype
    sublabel: "Person.prototype"
    icon: üîó
    color: violet
  - label: Object Prototype
    sublabel: "Object.prototype"
    icon: üèõÔ∏è
    color: emerald
  - label: null
    sublabel: "End of chain"
    icon: ‚õî
    color: gray
direction: horizontal
---
::

```javascript
const alice = new Person('Alice')

// Check the prototype chain
console.log(Object.getPrototypeOf(alice) === Person.prototype) // true
console.log(Object.getPrototypeOf(Person.prototype) === Object.prototype) // true
console.log(Object.getPrototypeOf(Object.prototype)) // null
```

## How Property Lookup Works

When you access a property, JavaScript follows this process:

1. Check the object itself
2. Check the object's prototype
3. Check the prototype's prototype
4. Continue until reaching null

```javascript
function Animal(name) {
  this.name = name
}

Animal.prototype.speak = function() {
  return `${this.name} makes a sound`
}

const dog = new Animal('Dog')

// Property lookup steps:
console.log(dog.name)   // Found on dog itself
console.log(dog.speak()) // Found on Animal.prototype
console.log(dog.toString()) // Found on Object.prototype
console.log(dog.missing) // Returns undefined (not found anywhere)
```

## Prototype vs Instance Properties

Properties added directly to an object are instance properties. Properties on the prototype are shared by all instances.

```javascript
function Counter() {
  this.count = 0 // Instance property (unique per instance)
}

Counter.prototype.increment = function() { // Prototype method (shared)
  this.count++
}

const c1 = new Counter()
const c2 = new Counter()

c1.increment()
console.log(c1.count) // 1
console.log(c2.count) // 0 (separate instance)

// But they share the method
console.log(c1.increment === c2.increment) // true
```

## Checking Prototypes

JavaScript gives you tools to inspect the prototype chain:

```javascript
const alice = new Person('Alice')

// Check if an object is in the prototype chain
console.log(Person.prototype.isPrototypeOf(alice)) // true
console.log(Object.prototype.isPrototypeOf(alice)) // true

// Check if a property exists on the object itself (not prototype)
console.log(alice.hasOwnProperty('name')) // true
console.log(alice.hasOwnProperty('greet')) // false (it's on the prototype)

// Get the prototype
console.log(Object.getPrototypeOf(alice) === Person.prototype) // true
```

## Creating Objects with Specific Prototypes

You can create objects with a specific prototype using `Object.create()`:

```javascript
const personMethods = {
  greet() {
    return `Hello, I'm ${this.name}`
  }
}

const alice = Object.create(personMethods)
alice.name = 'Alice'

console.log(alice.greet()) // "Hello, I'm Alice"
console.log(Object.getPrototypeOf(alice) === personMethods) // true
```

## Common Mistakes to Avoid

1. **Modifying built-in prototypes**: Do not change `Array.prototype`, `Object.prototype`, etc. This can break existing code.

```javascript
// ‚ùå BAD: Never do this
Array.prototype.myMethod = function() { }

// ‚úÖ GOOD: Extend with your own classes or use composition
```

2. **Using `__proto__`**: Use `Object.getPrototypeOf()` and `Object.setPrototypeOf()` instead.

```javascript
// ‚ùå Avoid
const proto = obj.__proto__

// ‚úÖ Better
const proto = Object.getPrototypeOf(obj)
```

3. **Forgetting `new`**: Without `new`, `this` does not refer to a new object.

```javascript
function Person(name) {
  this.name = name
}

const alice = Person('Alice') // ‚ùå Missing 'new'
console.log(alice) // undefined
console.log(window.name) // 'Alice' (created global variable!)

const bob = new Person('Bob') // ‚úÖ Correct
console.log(bob.name) // 'Bob'
```

## Prototypes vs Classes

Modern JavaScript has classes, but they use prototypes under the hood. Classes are cleaner syntax for the same concept.

```javascript
// Using prototype
function Person(name) {
  this.name = name
}
Person.prototype.greet = function() {
  return `Hello, I'm ${this.name}`
}

// Using class (same result)
class Person {
  constructor(name) {
    this.name = name
  }
  greet() {
    return `Hello, I'm ${this.name}`
  }
}
```

Both create the same prototype chain. Classes are easier to read and write, but understanding prototypes helps you understand how JavaScript works.

## Key Takeaways

- Every JavaScript object has a prototype (another object it inherits from)
- The prototype chain is how JavaScript finds properties and methods
- Methods on the prototype are shared between all instances (memory efficient)
- Use `Object.getPrototypeOf()` to inspect the prototype chain
- Classes use prototypes under the hood
- Understanding prototypes helps you understand JavaScript inheritance
