---
title: "Error Handling in Async Code"
description: "Master error handling patterns for asynchronous JavaScript: try/catch with async/await, Promise rejection handling, and best practices"
difficulty: intermediate
estimatedMinutes: 18
priority: essential
roadmap: fullstack
phase: 2
topic: asynchronous-javascript
learningObjectives:
  - "Handle errors in async/await code using try/catch"
  - "Properly handle Promise rejections with .catch()"
  - "Implement global error handlers for unhandled rejections"
  - "Use error handling patterns for parallel async operations"
  - "Create custom error classes for better error identification"
quiz:
  passingScore: 70
  questions:
    - question: "What happens to an unhandled Promise rejection in modern JavaScript?"
      type: single
      options:
        - "It triggers an 'unhandledrejection' event and may crash the process"
        - "It's silently ignored"
        - "It automatically retries the operation"
        - "It's converted to a resolved Promise"
      correctAnswer: "It triggers an 'unhandledrejection' event and may crash the process"
      explanation: "Unhandled Promise rejections trigger the 'unhandledrejection' event. In Node.js, they can crash the process. Modern environments warn about or reject unhandled rejections."

    - question: "How do you handle errors in async/await code?"
      type: single
      options:
        - "Wrap await calls in try/catch blocks"
        - "Use .catch() after the await"
        - "Errors can't be caught in async/await"
        - "Use only if/else statements"
      correctAnswer: "Wrap await calls in try/catch blocks"
      explanation: "In async/await, errors are handled with try/catch, just like synchronous code. When a Promise rejects, it throws an error that can be caught."

    - question: "Select all valid error handling patterns for Promise.all()."
      type: multiple
      options:
        - "Wrap in try/catch when using await"
        - "Add .catch() to the Promise.all() call"
        - "Use Promise.allSettled() to handle partial failures"
        - "Errors automatically propagate to all Promises"
      correctAnswers:
        - "Wrap in try/catch when using await"
        - "Add .catch() to the Promise.all() call"
        - "Use Promise.allSettled() to handle partial failures"
      explanation: "Promise.all() fails fast on the first rejection. Handle with try/catch or .catch(). Use Promise.allSettled() when you need results from all promises regardless of failures."

    - question: "What's the advantage of re-throwing errors after catching them?"
      type: single
      options:
        - "It allows logging/cleanup while letting errors propagate up"
        - "It makes errors disappear"
        - "It automatically retries the operation"
        - "It's required by JavaScript"
      correctAnswer: "It allows logging/cleanup while letting errors propagate up"
      explanation: "Re-throwing (throw error) after catching allows you to log the error, clean up resources, or add context, then let it propagate to higher-level handlers."

    - question: "finally blocks execute even if an error is thrown."
      type: true-false
      correctAnswer: true
      explanation: "True! The finally block always executes, whether the try block succeeds, catches an error, or re-throws. It's perfect for cleanup code like closing connections."

    - question: "What's wrong with this code? `async function getData() { const data = await fetch('/api'); return data; }`"
      type: single
      options:
        - "No error handling - network failures will cause unhandled rejections"
        - "Nothing is wrong"
        - "fetch() can't be used with await"
        - "async functions can't return values"
      correctAnswer: "No error handling - network failures will cause unhandled rejections"
      explanation: "This code has no error handling. If the network request fails, the Promise rejection will propagate up unhandled. Always wrap fetch calls in try/catch or add .catch()."

    - question: "When should you use Promise.allSettled() instead of Promise.all()?"
      type: single
      options:
        - "When you need all results regardless of individual failures"
        - "When you want to fail fast on first error"
        - "When you only have one Promise"
        - "When performance is critical"
      correctAnswer: "When you need all results regardless of individual failures"
      explanation: "Promise.allSettled() waits for all promises to complete, returning both fulfilled and rejected results. Use it when you need to process all results and handle failures individually."
---

# Error Handling in Async Code

Asynchronous code fails silently if you don't handle errors properly. Network requests fail, APIs return errors, files don't exist. Understanding how to catch and handle these failures is essential for building robust applications.

This lesson covers error handling patterns for Promises and async/await, including best practices for production code.

## Why Async Error Handling Matters

Unlike synchronous code, async errors don't automatically crash your program in an obvious way. They can:

- Silently fail, leaving your app in a broken state
- Cause unhandled rejection warnings
- Lead to hard-to-debug issues
- Leave resources (connections, files) open

```javascript
// Bad - no error handling
async function getData() {
  const response = await fetch('/api/data')  // What if this fails?
  return response.json()
}

// Good - errors are handled
async function getData() {
  try {
    const response = await fetch('/api/data')
    return response.json()
  } catch (error) {
    console.error('Failed to fetch data:', error)
    throw error  // Re-throw to let caller handle it
  }
}
```

## Error Handling with try/catch

### Basic Pattern

Wrap `await` calls in `try/catch`:

```javascript
async function fetchUser(id) {
  try {
    const response = await fetch(`/api/users/${id}`)

    if (!response.ok) {
      throw new Error(`HTTP error: ${response.status}`)
    }

    const user = await response.json()
    return user
  } catch (error) {
    console.error('Failed to fetch user:', error.message)
    throw error  // Re-throw or return a default value
  }
}
```

### Using finally

The `finally` block always executes, whether an error occurred or not:

```javascript
async function loadData() {
  showLoadingSpinner()

  try {
    const data = await fetchData()
    displayData(data)
  } catch (error) {
    showError(error.message)
  } finally {
    // Always runs - cleanup
    hideLoadingSpinner()
  }
}
```

### Multiple await Calls

```javascript
async function processOrder(orderId) {
  try {
    const order = await getOrder(orderId)
    const inventory = await checkInventory(order.items)
    const payment = await processPayment(order.total)
    const shipping = await createShipment(order)

    return { order, payment, shipping }
  } catch (error) {
    // Any of the above can fail
    console.error('Order processing failed:', error)
    throw error
  }
}
```

### Separate Error Handling

Handle different operations differently:

```javascript
async function createUserAccount(userData) {
  let user

  // Handle user creation errors
  try {
    user = await createUser(userData)
  } catch (error) {
    throw new Error(`Failed to create user: ${error.message}`)
  }

  // Handle email errors - non-critical
  try {
    await sendWelcomeEmail(user.email)
  } catch (error) {
    console.warn('Welcome email failed:', error)
    // Don't throw - email is non-critical
  }

  return user
}
```

## Error Handling with Promises

### Using .catch()

```javascript
fetch('/api/data')
  .then(response => response.json())
  .then(data => processData(data))
  .catch(error => {
    console.error('Error:', error)
  })
```

### Catch Position Matters

```javascript
fetch('/api/data')
  .then(response => response.json())
  .catch(error => {
    console.error('Fetch or parse failed:', error)
    return { default: 'data' }  // Provide fallback
  })
  .then(data => {
    // This runs with either real data or fallback
    processData(data)
  })
```

### .catch() Returns a Promise

```javascript
const getData = () => fetch('/api/data')
  .then(response => {
    if (!response.ok) throw new Error('Not found')
    return response.json()
  })
  .catch(error => {
    console.error(error)
    return null  // Return null instead of throwing
  })

// Usage
const data = await getData()  // null if error, data if success
```

## Handling Multiple Promises

### Promise.all() - Fail Fast

`Promise.all()` rejects immediately when any Promise rejects:

```javascript
async function fetchMultipleUsers(ids) {
  try {
    const users = await Promise.all(
      ids.map(id => fetchUser(id))
    )
    return users
  } catch (error) {
    // One failure = entire operation fails
    console.error('One or more users failed to fetch:', error)
    throw error
  }
}
```

### Promise.allSettled() - Get All Results

When you need results from all promises, even if some fail:

```javascript
async function fetchMultipleUsers(ids) {
  const results = await Promise.allSettled(
    ids.map(id => fetchUser(id))
  )

  const users = []
  const errors = []

  results.forEach((result, index) => {
    if (result.status === 'fulfilled') {
      users.push(result.value)
    } else {
      errors.push({ id: ids[index], error: result.reason })
    }
  })

  if (errors.length > 0) {
    console.warn('Some users failed to load:', errors)
  }

  return users
}
```

### Per-Promise Error Handling

Handle errors for each Promise individually:

```javascript
async function fetchMultipleAPIs() {
  const results = await Promise.all([
    fetch('/api/users').catch(e => ({ error: e, source: 'users' })),
    fetch('/api/posts').catch(e => ({ error: e, source: 'posts' })),
    fetch('/api/comments').catch(e => ({ error: e, source: 'comments' }))
  ])

  // All results are available, check each for errors
  return results.map(result => {
    if (result.error) {
      console.warn(`${result.source} failed:`, result.error)
      return null
    }
    return result
  })
}
```

## Custom Error Classes

Create specific error types for better error handling:

```javascript
class NetworkError extends Error {
  constructor(message, status) {
    super(message)
    this.name = 'NetworkError'
    this.status = status
  }
}

class ValidationError extends Error {
  constructor(message, field) {
    super(message)
    this.name = 'ValidationError'
    this.field = field
  }
}

class NotFoundError extends Error {
  constructor(resource) {
    super(`${resource} not found`)
    this.name = 'NotFoundError'
    this.resource = resource
  }
}
```

### Using Custom Errors

```javascript
async function fetchUser(id) {
  const response = await fetch(`/api/users/${id}`)

  if (response.status === 404) {
    throw new NotFoundError('User')
  }

  if (!response.ok) {
    throw new NetworkError('Failed to fetch user', response.status)
  }

  return response.json()
}

// Handle specific error types
async function loadUserProfile(id) {
  try {
    const user = await fetchUser(id)
    displayUser(user)
  } catch (error) {
    if (error instanceof NotFoundError) {
      showNotFound('User does not exist')
    } else if (error instanceof NetworkError) {
      showRetryButton('Network error. Please try again.')
    } else {
      showGenericError('Something went wrong')
    }
  }
}
```

## Global Error Handlers

### Browser - Unhandled Rejections

```javascript
window.addEventListener('unhandledrejection', (event) => {
  console.error('Unhandled promise rejection:', event.reason)

  // Prevent the default handling (error in console)
  event.preventDefault()

  // Send to error tracking service
  trackError(event.reason)
})
```

### Node.js - Unhandled Rejections

```javascript
process.on('unhandledRejection', (reason, promise) => {
  console.error('Unhandled Rejection at:', promise, 'reason:', reason)

  // Log to error tracking service
  logError(reason)

  // Optionally exit process in production
  // process.exit(1)
})
```

## Best Practices

### 1. Always Handle Errors

Don't let Promises go unhandled:

```javascript
// Bad - unhandled rejection
fetchData()

// Good - handled with catch
fetchData().catch(console.error)

// Good - handled with try/catch
try {
  await fetchData()
} catch (error) {
  console.error(error)
}
```

### 2. Re-throw When Appropriate

Log and re-throw to let callers handle errors:

```javascript
async function fetchData() {
  try {
    const response = await fetch('/api/data')
    return response.json()
  } catch (error) {
    console.error('fetchData failed:', error)
    throw error  // Let caller decide what to do
  }
}
```

### 3. Provide Context

Add context when re-throwing:

```javascript
async function processOrder(orderId) {
  try {
    await submitOrder(orderId)
  } catch (error) {
    throw new Error(`Failed to process order ${orderId}: ${error.message}`)
  }
}
```

### 4. Use finally for Cleanup

```javascript
async function withConnection(callback) {
  const connection = await openConnection()

  try {
    return await callback(connection)
  } finally {
    await connection.close()  // Always closes, even on error
  }
}
```

### 5. Don't Swallow Errors

```javascript
// Bad - error is swallowed
async function getData() {
  try {
    return await fetchData()
  } catch (error) {
    console.error(error)
    // Returns undefined - caller doesn't know about error!
  }
}

// Good - error is handled properly
async function getData() {
  try {
    return await fetchData()
  } catch (error) {
    console.error(error)
    throw error  // Or return a meaningful default
  }
}
```

### 6. Validate Response Status

```javascript
async function fetchJSON(url) {
  const response = await fetch(url)

  if (!response.ok) {
    throw new Error(`HTTP ${response.status}: ${response.statusText}`)
  }

  return response.json()
}
```

## Common Patterns

### Retry Pattern

```javascript
async function fetchWithRetry(url, retries = 3, delay = 1000) {
  for (let i = 0; i < retries; i++) {
    try {
      return await fetch(url)
    } catch (error) {
      if (i === retries - 1) throw error

      console.warn(`Attempt ${i + 1} failed, retrying...`)
      await new Promise(resolve => setTimeout(resolve, delay))
    }
  }
}
```

### Timeout Pattern

```javascript
function fetchWithTimeout(url, timeout = 5000) {
  return Promise.race([
    fetch(url),
    new Promise((_, reject) =>
      setTimeout(() => reject(new Error('Request timeout')), timeout)
    )
  ])
}

// Usage
try {
  const response = await fetchWithTimeout('/api/slow', 3000)
} catch (error) {
  if (error.message === 'Request timeout') {
    console.log('Request took too long')
  }
}
```

### Default Value Pattern

```javascript
async function getConfig() {
  try {
    const response = await fetch('/api/config')
    return response.json()
  } catch (error) {
    console.warn('Using default config:', error)
    return { theme: 'light', language: 'en' }  // Fallback
  }
}
```

## Key Takeaways

- **Always handle async errors** - unhandled rejections cause issues
- Use **try/catch** with async/await for error handling
- Use **.catch()** with Promise chains
- **finally** always runs - use it for cleanup
- **Promise.all()** fails fast - one rejection fails all
- **Promise.allSettled()** returns all results, success or failure
- Create **custom error classes** for specific error types
- **Re-throw errors** after logging to let callers handle them
- Set up **global handlers** for unhandled rejections
- Don't **swallow errors** - handle them or propagate them
- Add **context** to errors to make debugging easier

Proper error handling is what separates production-ready code from fragile prototypes. Handle errors at appropriate levels, provide meaningful messages, and always clean up resources.
