---
title: "Fetch API & AbortController"
description: "Master the modern Fetch API for HTTP requests and learn to cancel requests using AbortController"
difficulty: intermediate
estimatedMinutes: 20
priority: essential
roadmap: fullstack
phase: 2
topic: asynchronous-javascript
learningObjectives:
  - "Use the Fetch API to make HTTP GET and POST requests"
  - "Handle responses including status codes and JSON parsing"
  - "Configure request headers and body for different HTTP methods"
  - "Cancel in-flight requests using AbortController"
  - "Implement timeout patterns and request cancellation"
quiz:
  passingScore: 70
  questions:
    - question: "What does the fetch() function return?"
      type: single
      options:
        - "A Promise that resolves to a Response object"
        - "The response data directly"
        - "A JSON object"
        - "An XMLHttpRequest object"
      correctAnswer: "A Promise that resolves to a Response object"
      explanation: "fetch() returns a Promise that resolves to a Response object. You need to call response.json() or response.text() to get the actual data - these also return Promises."

    - question: "When does a fetch() Promise reject?"
      type: single
      options:
        - "Only on network errors, NOT on HTTP error status codes like 404 or 500"
        - "On any error including 404 and 500 status codes"
        - "Only when the server is completely down"
        - "Whenever response.ok is false"
      correctAnswer: "Only on network errors, NOT on HTTP error status codes like 404 or 500"
      explanation: "fetch() only rejects on network errors (no connection, DNS failure, etc.). HTTP error codes like 404 or 500 still resolve the Promise. You must check response.ok or response.status to detect HTTP errors."

    - question: "Select all TRUE statements about AbortController."
      type: multiple
      options:
        - "It can cancel fetch requests before they complete"
        - "You pass controller.signal to the fetch options"
        - "Calling controller.abort() triggers an AbortError"
        - "Each AbortController can only cancel one request"
      correctAnswers:
        - "It can cancel fetch requests before they complete"
        - "You pass controller.signal to the fetch options"
        - "Calling controller.abort() triggers an AbortError"
      explanation: "All are true except the last one - a single AbortController can cancel multiple requests if they all use the same signal. When abort() is called, all associated operations receive an AbortError."

    - question: "You must always check response.ok or response.status before processing fetch response data."
      type: true-false
      correctAnswer: true
      explanation: "True! Since fetch() doesn't reject on HTTP errors, you must manually check response.ok (true for 200-299 status codes) or response.status before processing the response. Otherwise, you might try to parse error HTML as JSON."

    - question: "How do you send JSON data in a POST request with fetch?"
      type: single
      options:
        - "Set Content-Type header to 'application/json' and use JSON.stringify() on the body"
        - "Just pass the JavaScript object directly to the body option"
        - "Use the json() method instead of body"
        - "Fetch automatically converts objects to JSON"
      correctAnswer: "Set Content-Type header to 'application/json' and use JSON.stringify() on the body"
      explanation: "You must manually stringify your data with JSON.stringify() and set the Content-Type header to 'application/json'. Fetch doesn't automatically convert JavaScript objects to JSON."

    - question: "What happens when you call abort() on an AbortController?"
      type: single
      options:
        - "All fetch requests using that signal immediately throw an AbortError"
        - "The request completes but the response is discarded"
        - "Only future requests are cancelled, not in-flight ones"
        - "It sets a flag that you must manually check"
      correctAnswer: "All fetch requests using that signal immediately throw an AbortError"
      explanation: "When you call abort(), all operations using that AbortSignal are cancelled immediately and receive an AbortError. You can catch this error to handle cancellation gracefully."
---

# Fetch API & AbortController

The **Fetch API** is the modern way to make HTTP requests in JavaScript. It replaces the old `XMLHttpRequest` with a cleaner, Promise-based interface. Combine it with **AbortController**, and you can cancel requests that are no longer needed.

In this lesson, you will learn how to use fetch for GET and POST requests, handle errors properly, and cancel requests with AbortController.

## What Is the Fetch API?

The **Fetch API** provides a simple interface for making HTTP requests:

```javascript
fetch('https://api.example.com/users')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error))
```

Much cleaner than the old `XMLHttpRequest`!

### Basic Fetch Syntax

```javascript
fetch(url, options)
  .then(response => {
    // Response object
  })
```

- **url**: The endpoint URL
- **options**: Configuration object (method, headers, body, etc.)

## Making GET Requests

The simplest fetch is a GET request:

```javascript
// Basic GET
fetch('https://api.example.com/users')
  .then(response => response.json())
  .then(users => {
    console.log('Users:', users)
  })
  .catch(error => {
    console.error('Fetch failed:', error)
  })
```

### With Async/Await

```javascript
async function getUsers() {
  try {
    const response = await fetch('https://api.example.com/users')
    const users = await response.json()
    console.log('Users:', users)
    return users
  } catch (error) {
    console.error('Fetch failed:', error)
    return []
  }
}
```

## The Response Object

The Response object contains:

| Property | Description |
|----------|-------------|
| `response.ok` | `true` if status is 200-299 |
| `response.status` | HTTP status code (200, 404, 500, etc.) |
| `response.statusText` | Status message ("OK", "Not Found", etc.) |
| `response.headers` | Response headers |
| `response.body` | ReadableStream of the body |

### Important Methods

| Method | Returns | Use For |
|--------|---------|---------|
| `response.json()` | Promise â†’ parsed JSON | JSON responses |
| `response.text()` | Promise â†’ string | Plain text |
| `response.blob()` | Promise â†’ Blob | Images, files |
| `response.formData()` | Promise â†’ FormData | Form submissions |
| `response.arrayBuffer()` | Promise â†’ ArrayBuffer | Binary data |

**Important:** These methods return Promises and can only be called once!

## Checking Response Status

**Critical:** Fetch only rejects on **network errors**, not HTTP errors!

```javascript
// WRONG - Doesn't handle HTTP errors
async function fetchUserWrong(id) {
  const response = await fetch(`/api/users/${id}`)
  const user = await response.json()  // Might be error HTML!
  return user
}

// CORRECT - Check response.ok
async function fetchUser(id) {
  const response = await fetch(`/api/users/${id}`)

  if (!response.ok) {
    throw new Error(`HTTP error: ${response.status}`)
  }

  const user = await response.json()
  return user
}
```

### Handling Different Status Codes

```javascript
async function handleResponse(response) {
  if (response.ok) {
    // 200-299: Success
    return await response.json()
  }

  // Handle specific errors
  switch (response.status) {
    case 400:
      throw new Error('Bad request')
    case 401:
      throw new Error('Unauthorized - please log in')
    case 404:
      throw new Error('Resource not found')
    case 500:
      throw new Error('Server error')
    default:
      throw new Error(`HTTP error: ${response.status}`)
  }
}

// Use it
try {
  const response = await fetch('/api/data')
  const data = await handleResponse(response)
} catch (error) {
  console.error(error.message)
}
```

## Making POST Requests

Send data to the server using POST:

```javascript
async function createUser(userData) {
  const response = await fetch('https://api.example.com/users', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(userData)
  })

  if (!response.ok) {
    throw new Error(`Failed to create user: ${response.status}`)
  }

  const newUser = await response.json()
  return newUser
}

// Use it
const newUser = await createUser({
  name: 'Alice',
  email: 'alice@example.com'
})
```

**Key points:**
1. Set `method: 'POST'`
2. Set `Content-Type: 'application/json'` header
3. Use `JSON.stringify()` on the body
4. Check `response.ok` before parsing

## Other HTTP Methods

### PUT (Update)

```javascript
async function updateUser(id, updates) {
  const response = await fetch(`/api/users/${id}`, {
    method: 'PUT',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(updates)
  })

  if (!response.ok) {
    throw new Error('Update failed')
  }

  return await response.json()
}
```

### DELETE

```javascript
async function deleteUser(id) {
  const response = await fetch(`/api/users/${id}`, {
    method: 'DELETE'
  })

  if (!response.ok) {
    throw new Error('Delete failed')
  }

  // DELETE often returns 204 No Content
  if (response.status === 204) {
    return true
  }

  return await response.json()
}
```

### PATCH (Partial Update)

```javascript
async function patchUser(id, changes) {
  const response = await fetch(`/api/users/${id}`, {
    method: 'PATCH',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(changes)
  })

  if (!response.ok) {
    throw new Error('Patch failed')
  }

  return await response.json()
}
```

## Request Headers

Common headers you might need:

```javascript
const response = await fetch('/api/data', {
  headers: {
    'Content-Type': 'application/json',
    'Authorization': `Bearer ${token}`,
    'Accept': 'application/json',
    'X-Custom-Header': 'value'
  }
})
```

### Reading Response Headers

```javascript
const response = await fetch('/api/data')

console.log(response.headers.get('Content-Type'))
console.log(response.headers.get('Date'))

// Iterate all headers
response.headers.forEach((value, name) => {
  console.log(`${name}: ${value}`)
})
```

## AbortController - Canceling Requests

Sometimes you need to cancel a request:
- User navigates away
- Component unmounts
- New search replaces old search
- Request timeout

**AbortController** lets you cancel in-flight requests.

### Basic Usage

```javascript
// Create controller
const controller = new AbortController()

// Pass signal to fetch
fetch('/api/data', {
  signal: controller.signal
})
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => {
    if (error.name === 'AbortError') {
      console.log('Request was cancelled')
    } else {
      console.error('Request failed:', error)
    }
  })

// Cancel the request
controller.abort()
```

::illustration-linear-flow
---
steps:
  - label: Create Controller
    icon: ðŸŽ›ï¸
    color: violet
  - label: Start Fetch with Signal
    icon: ðŸš€
    color: blue
  - label: Call abort()
    icon: â›”
    color: rose
  - label: Catch AbortError
    icon: ðŸ”„
    color: amber
---
::

### With Async/Await

```javascript
async function fetchWithAbort() {
  const controller = new AbortController()

  try {
    const response = await fetch('/api/data', {
      signal: controller.signal
    })

    const data = await response.json()
    return data

  } catch (error) {
    if (error.name === 'AbortError') {
      console.log('Fetch cancelled')
      return null
    }
    throw error
  }
}
```

## Practical Examples

### Example 1: Timeout Pattern

```javascript
async function fetchWithTimeout(url, timeout = 5000) {
  const controller = new AbortController()

  // Set timeout
  const timeoutId = setTimeout(() => controller.abort(), timeout)

  try {
    const response = await fetch(url, {
      signal: controller.signal
    })

    clearTimeout(timeoutId)  // Clear timeout if request succeeds

    if (!response.ok) {
      throw new Error(`HTTP error: ${response.status}`)
    }

    return await response.json()

  } catch (error) {
    clearTimeout(timeoutId)

    if (error.name === 'AbortError') {
      throw new Error('Request timeout')
    }
    throw error
  }
}

// Use it
try {
  const data = await fetchWithTimeout('/api/slow', 3000)
  console.log(data)
} catch (error) {
  console.error('Failed:', error.message)
}
```

### Example 2: Search Autocomplete

```javascript
let currentController = null

async function search(query) {
  // Cancel previous search
  if (currentController) {
    currentController.abort()
  }

  // Create new controller for this search
  currentController = new AbortController()

  try {
    const response = await fetch(`/api/search?q=${query}`, {
      signal: currentController.signal
    })

    if (!response.ok) {
      throw new Error('Search failed')
    }

    const results = await response.json()
    displayResults(results)

  } catch (error) {
    if (error.name === 'AbortError') {
      console.log('Search cancelled (user typed more)')
    } else {
      console.error('Search error:', error)
    }
  }
}

// User types in search box
input.addEventListener('input', (e) => {
  search(e.target.value)
})
```

Each new search cancels the previous one.

### Example 3: Component Cleanup

```javascript
class UserProfile {
  constructor() {
    this.controller = new AbortController()
  }

  async loadData(userId) {
    try {
      const response = await fetch(`/api/users/${userId}`, {
        signal: this.controller.signal
      })

      const user = await response.json()
      this.displayUser(user)

    } catch (error) {
      if (error.name !== 'AbortError') {
        console.error('Load failed:', error)
      }
    }
  }

  destroy() {
    // Cancel any in-flight requests
    this.controller.abort()
    console.log('Component destroyed, requests cancelled')
  }
}
```

### Example 4: Multiple Requests with One Controller

```javascript
async function loadDashboard() {
  const controller = new AbortController()

  try {
    // All requests use the same signal
    const [users, posts, comments] = await Promise.all([
      fetch('/api/users', { signal: controller.signal }),
      fetch('/api/posts', { signal: controller.signal }),
      fetch('/api/comments', { signal: controller.signal })
    ])

    // Process responses
    const userData = await users.json()
    const postsData = await posts.json()
    const commentsData = await comments.json()

    return { userData, postsData, commentsData }

  } catch (error) {
    if (error.name === 'AbortError') {
      console.log('Dashboard load cancelled')
    }
    throw error
  }
}

// Cancel all three requests
controller.abort()
```

## Common Patterns

### Pattern 1: Retry with Exponential Backoff

```javascript
async function fetchWithRetry(url, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      const response = await fetch(url)

      if (response.ok) {
        return await response.json()
      }

      // Don't retry client errors (4xx)
      if (response.status >= 400 && response.status < 500) {
        throw new Error(`Client error: ${response.status}`)
      }

    } catch (error) {
      if (i === maxRetries - 1) throw error

      const delay = Math.pow(2, i) * 1000  // 1s, 2s, 4s
      console.log(`Retry ${i + 1} after ${delay}ms`)
      await new Promise(resolve => setTimeout(resolve, delay))
    }
  }
}
```

### Pattern 2: Progress Tracking

```javascript
async function downloadWithProgress(url) {
  const response = await fetch(url)

  if (!response.ok) {
    throw new Error('Download failed')
  }

  const contentLength = response.headers.get('Content-Length')
  const total = parseInt(contentLength, 10)
  let received = 0

  const reader = response.body.getReader()
  const chunks = []

  while (true) {
    const { done, value } = await reader.read()

    if (done) break

    chunks.push(value)
    received += value.length

    const progress = (received / total) * 100
    console.log(`Downloaded: ${progress.toFixed(2)}%`)
  }

  const blob = new Blob(chunks)
  return blob
}
```

### Pattern 3: Caching with Expiry

```javascript
const cache = new Map()

async function fetchWithCache(url, cacheTime = 60000) {
  const cached = cache.get(url)

  if (cached && Date.now() - cached.timestamp < cacheTime) {
    console.log('Using cached data')
    return cached.data
  }

  const response = await fetch(url)
  const data = await response.json()

  cache.set(url, {
    data,
    timestamp: Date.now()
  })

  return data
}
```

## Error Handling Best Practices

```javascript
async function robustFetch(url, options = {}) {
  try {
    const response = await fetch(url, options)

    // Check HTTP status
    if (!response.ok) {
      const errorBody = await response.text()
      throw new Error(
        `HTTP ${response.status}: ${errorBody || response.statusText}`
      )
    }

    // Parse JSON safely
    const contentType = response.headers.get('Content-Type')
    if (contentType && contentType.includes('application/json')) {
      return await response.json()
    }

    return await response.text()

  } catch (error) {
    // Network error
    if (error instanceof TypeError) {
      throw new Error('Network error - check your connection')
    }

    // Abort error
    if (error.name === 'AbortError') {
      throw new Error('Request was cancelled')
    }

    // Re-throw other errors
    throw error
  }
}
```

## Key Takeaways

- **fetch()** returns a Promise that resolves to a Response object
- fetch() only rejects on **network errors**, not HTTP errors (404, 500, etc.)
- Always check **response.ok** or **response.status** before parsing
- Use **response.json()** for JSON, **response.text()** for text
- Set **method, headers, and body** for POST/PUT/PATCH/DELETE requests
- Use **JSON.stringify()** for the body and set Content-Type header
- **AbortController** lets you cancel requests with abort()
- Pass **controller.signal** to fetch options
- Catch **AbortError** to handle cancellation gracefully
- One controller can cancel multiple requests using the same signal
- Use timeouts, search cancellation, and cleanup patterns with AbortController

The Fetch API is the modern standard for HTTP requests. Combined with AbortController, you have full control over network operations. Master these, and you can build robust, responsive web applications.
