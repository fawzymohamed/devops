---
title: "Event Loop - JavaScript's Async Engine"
description: "Understand how JavaScript handles async operations using the event loop, call stack, task queue, and microtask queue"
difficulty: intermediate
estimatedMinutes: 22
priority: essential
roadmap: fullstack
phase: 2
topic: asynchronous-javascript
learningObjectives:
  - "Understand JavaScript's single-threaded execution model"
  - "Explain how the call stack manages function execution"
  - "Differentiate between the task queue and microtask queue"
  - "Predict the order of async code execution"
  - "Visualize how the event loop coordinates all these components"
quiz:
  passingScore: 70
  questions:
    - question: "Is JavaScript single-threaded or multi-threaded?"
      type: single
      options:
        - "Single-threaded - only one call stack executes code at a time"
        - "Multi-threaded - multiple threads run simultaneously"
        - "It depends on whether you use async/await"
        - "Single-threaded for sync code, multi-threaded for async code"
      correctAnswer: "Single-threaded - only one call stack executes code at a time"
      explanation: "JavaScript is single-threaded, meaning only one piece of code executes at a time. The event loop creates the illusion of concurrency by switching between tasks, but actual execution is sequential."

    - question: "What is the call stack?"
      type: single
      options:
        - "A data structure that tracks function calls - last in, first out"
        - "A queue that stores async callbacks"
        - "A list of all variables in memory"
        - "A mechanism for handling errors"
      correctAnswer: "A data structure that tracks function calls - last in, first out"
      explanation: "The call stack is a LIFO (Last In, First Out) data structure that tracks function execution. When a function is called, it's pushed onto the stack. When it completes, it's popped off."

    - question: "Select all TRUE statements about the event loop."
      type: multiple
      options:
        - "It checks if the call stack is empty before processing queues"
        - "It processes microtasks before macrotasks"
        - "It runs continuously, checking for work to do"
        - "It only runs when you use async/await"
      correctAnswers:
        - "It checks if the call stack is empty before processing queues"
        - "It processes microtasks before macrotasks"
        - "It runs continuously, checking for work to do"
      explanation: "The event loop continuously checks if the call stack is empty, then processes all microtasks before taking one macrotask. It always runs - async/await is just syntax sugar for Promises, which use the event loop."

    - question: "Microtasks (Promises) have higher priority than macrotasks (setTimeout)."
      type: true-false
      correctAnswer: true
      explanation: "True! When the call stack is empty, the event loop processes ALL microtasks before moving to the next macrotask. Promises (.then callbacks) are microtasks, while setTimeout/setInterval are macrotasks."

    - question: "What happens when you call a function in JavaScript?"
      type: single
      options:
        - "It's pushed onto the call stack and executed immediately"
        - "It's added to the task queue"
        - "It's added to the microtask queue"
        - "It waits for the event loop to process it"
      correctAnswer: "It's pushed onto the call stack and executed immediately"
      explanation: "Regular function calls are pushed onto the call stack and executed immediately. Only async callbacks (from setTimeout, Promises, etc.) go into queues to be processed later by the event loop."

    - question: "What is the correct order of execution for this code?\n```\nconsole.log('1')\nsetTimeout(() => console.log('2'), 0)\nPromise.resolve().then(() => console.log('3'))\nconsole.log('4')\n```"
      type: single
      options:
        - "1, 4, 3, 2"
        - "1, 2, 3, 4"
        - "1, 3, 4, 2"
        - "1, 4, 2, 3"
      correctAnswer: "1, 4, 3, 2"
      explanation: "Synchronous code runs first (1, 4), then microtasks (Promise - 3), then macrotasks (setTimeout - 2). Even with 0ms delay, setTimeout is a macrotask that runs after microtasks."
---

# Event Loop - JavaScript's Async Engine

How does JavaScript handle async operations when it's single-threaded? The answer is the **event loop** - the mechanism that coordinates the call stack, Web APIs, and callback queues to create non-blocking behavior.

In this lesson, you will learn how JavaScript executes code behind the scenes. Understanding the event loop helps you predict code execution order and debug tricky async issues.

## JavaScript Is Single-Threaded

JavaScript has **one call stack**, meaning only one piece of code executes at a time. It can't do two things simultaneously.

So how does it handle async operations without blocking?

The event loop coordinates multiple components:
- **Call Stack** - Executes functions
- **Web APIs** - Handle async operations (timers, network, DOM events)
- **Task Queue (Macrotask Queue)** - Holds callbacks from setTimeout, setInterval, I/O
- **Microtask Queue** - Holds Promise callbacks and mutation observers

::illustration-linear-flow
---
steps:
  - label: Call Stack
    sublabel: "Executes code"
    icon: ðŸ“š
    color: violet
  - label: Web APIs
    sublabel: "Async operations"
    icon: âš™ï¸
    color: blue
  - label: Queues
    sublabel: "Waiting callbacks"
    icon: ðŸ“¥
    color: amber
  - label: Event Loop
    sublabel: "Coordinates all"
    icon: ðŸ”„
    color: emerald
---
::

## The Call Stack

The **call stack** tracks function execution. It works like a stack of plates - last in, first out (LIFO).

```javascript
function third() {
  console.log('Third')
}

function second() {
  third()
  console.log('Second')
}

function first() {
  second()
  console.log('First')
}

first()

// Call stack visualization:
// 1. first()           â†’ pushed
// 2. first() second()  â†’ pushed
// 3. first() second() third()  â†’ pushed
// 4. third() completes â†’ popped
// 5. second() completes â†’ popped
// 6. first() completes â†’ popped

// Output:
// Third
// Second
// First
```

The call stack executes from top to bottom. When a function completes, it's removed from the stack.

### Stack Overflow

If the call stack grows too large (infinite recursion), you get a **stack overflow** error:

```javascript
function recursive() {
  recursive()  // Calls itself forever
}

recursive()  // Error: Maximum call stack size exceeded
```

## Web APIs

The browser provides **Web APIs** that handle async operations outside the JavaScript engine:

- **Timers**: `setTimeout()`, `setInterval()`
- **Network**: `fetch()`, `XMLHttpRequest`
- **DOM Events**: `addEventListener()`
- **Others**: `requestAnimationFrame()`, `IndexedDB`

These run in the background while JavaScript continues executing.

```javascript
console.log('Start')

setTimeout(() => {
  console.log('Timeout')  // Handled by Web API
}, 1000)

console.log('End')

// Output:
// Start
// End
// (1 second later)
// Timeout
```

The Web API handles the timer while JavaScript keeps running.

## Task Queue (Macrotask Queue)

When a Web API completes, its callback goes to the **task queue** (also called macrotask queue):

- `setTimeout()` callbacks
- `setInterval()` callbacks
- I/O operations
- UI rendering
- `setImmediate()` (Node.js)

These wait in the queue until the call stack is empty.

## Microtask Queue

The **microtask queue** has **higher priority** than the task queue:

- Promise `.then()` / `.catch()` / `.finally()` callbacks
- `async`/`await` continuations
- `queueMicrotask()`
- `MutationObserver` callbacks

Microtasks run **before** the next macrotask.

## The Event Loop Cycle

The event loop follows this cycle continuously:

::illustration-linear-flow
---
steps:
  - label: Execute Script
    sublabel: "Run all sync code"
    icon: 1ï¸âƒ£
    color: violet
  - label: Check Microtasks
    sublabel: "Run ALL microtasks"
    icon: 2ï¸âƒ£
    color: blue
  - label: Render (if needed)
    sublabel: "Update UI"
    icon: 3ï¸âƒ£
    color: cyan
  - label: Take One Macrotask
    sublabel: "Run next macrotask"
    icon: 4ï¸âƒ£
    color: amber
  - label: Repeat
    sublabel: "Back to step 2"
    icon: ðŸ”
    color: emerald
showFeedbackLoop: true
feedbackLabel: Loop continues
---
::

**Key Rules:**
1. Execute all synchronous code first
2. Process **ALL** microtasks (until queue is empty)
3. Render if needed
4. Process **ONE** macrotask
5. Back to step 2

## Execution Order Example

```javascript
console.log('1')  // Synchronous

setTimeout(() => {
  console.log('2')  // Macrotask
}, 0)

Promise.resolve().then(() => {
  console.log('3')  // Microtask
})

console.log('4')  // Synchronous

// Output:
// 1
// 4
// 3
// 2
```

**Step by step:**

1. **Sync code**: Print `1`
2. **setTimeout**: Schedule macrotask (goes to Web API)
3. **Promise**: Schedule microtask
4. **Sync code**: Print `4`
5. **Call stack empty** â†’ Event loop checks queues
6. **Microtasks first**: Print `3`
7. **Macrotasks**: Print `2`

Even with `0ms` delay, `setTimeout` runs **after** Promises!

## Detailed Walkthrough

Let's trace a more complex example:

```javascript
console.log('Start')

setTimeout(() => {
  console.log('Timeout 1')
}, 0)

Promise.resolve()
  .then(() => {
    console.log('Promise 1')
    return Promise.resolve()
  })
  .then(() => {
    console.log('Promise 2')
  })

setTimeout(() => {
  console.log('Timeout 2')
}, 0)

console.log('End')
```

**Execution trace:**

| Step | Action | Call Stack | Microtask Queue | Macrotask Queue | Output |
|------|--------|------------|-----------------|-----------------|--------|
| 1 | Run sync | `console.log('Start')` | - | - | Start |
| 2 | setTimeout | - | - | `[Timeout 1]` | - |
| 3 | Promise.resolve | - | `[Promise 1]` | `[Timeout 1]` | - |
| 4 | setTimeout | - | `[Promise 1]` | `[Timeout 1, Timeout 2]` | - |
| 5 | Run sync | `console.log('End')` | `[Promise 1]` | `[Timeout 1, Timeout 2]` | End |
| 6 | Stack empty, check microtasks | `Promise 1` | `[Promise 2]` | `[Timeout 1, Timeout 2]` | Promise 1 |
| 7 | Continue microtasks | `Promise 2` | `[]` | `[Timeout 1, Timeout 2]` | Promise 2 |
| 8 | Microtasks done, take macrotask | `Timeout 1` | `[]` | `[Timeout 2]` | Timeout 1 |
| 9 | Take next macrotask | `Timeout 2` | `[]` | `[]` | Timeout 2 |

**Final output:**
```
Start
End
Promise 1
Promise 2
Timeout 1
Timeout 2
```

## Microtasks vs Macrotasks

### Microtasks

**Always run before the next macrotask:**

```javascript
setTimeout(() => console.log('Macro'), 0)

Promise.resolve()
  .then(() => console.log('Micro 1'))
  .then(() => console.log('Micro 2'))
  .then(() => console.log('Micro 3'))

// Output:
// Micro 1
// Micro 2
// Micro 3
// Macro
```

All microtasks run before any macrotask.

### Macrotasks

**Run one at a time:**

```javascript
setTimeout(() => {
  console.log('Macro 1')
  Promise.resolve().then(() => console.log('Micro from Macro 1'))
}, 0)

setTimeout(() => {
  console.log('Macro 2')
}, 0)

// Output:
// Macro 1
// Micro from Macro 1  â† Runs before next macrotask!
// Macro 2
```

After each macrotask, all microtasks run before the next macrotask.

## Real-World Implications

### 1. Promise vs setTimeout

```javascript
// Which runs first?
setTimeout(() => console.log('Timer'), 0)
Promise.resolve().then(() => console.log('Promise'))

// Output:
// Promise  â† Microtask wins
// Timer    â† Macrotask waits
```

Promises **always** run before timers, even with 0ms delay.

### 2. Async/Await

```javascript
async function example() {
  console.log('1')

  await Promise.resolve()

  console.log('2')  // This is a microtask!
}

setTimeout(() => console.log('3'), 0)

example()

console.log('4')

// Output:
// 1
// 4
// 2
// 3
```

Code after `await` runs as a microtask.

### 3. Infinite Microtasks

Be careful - microtasks can starve macrotasks:

```javascript
// WRONG - This never lets macrotasks run!
function infiniteMicrotasks() {
  Promise.resolve().then(() => {
    console.log('Microtask')
    infiniteMicrotasks()  // Schedules another microtask
  })
}

setTimeout(() => console.log('I will never run!'), 0)

infiniteMicrotasks()
```

The macrotask never runs because microtasks keep adding more microtasks.

## Blocking the Event Loop

Long-running synchronous code **blocks** the event loop:

```javascript
console.log('Start')

// Block for 3 seconds
const start = Date.now()
while (Date.now() - start < 3000) {
  // Doing nothing
}

console.log('End')

// UI is frozen for 3 seconds!
```

During this time:
- No callbacks run
- UI doesn't update
- Page is unresponsive

**Solution:** Break work into chunks or use Web Workers (next lesson).

## Practical Examples

### Example 1: Button Click Handler

```javascript
button.addEventListener('click', () => {
  console.log('Click')

  Promise.resolve().then(() => console.log('Microtask'))

  setTimeout(() => console.log('Macrotask'), 0)

  console.log('Sync')
})

// When clicked:
// Click
// Sync
// Microtask
// Macrotask
```

### Example 2: Fetch with Timeout

```javascript
async function fetchWithTimeout(url) {
  const timeout = new Promise((_, reject) => {
    setTimeout(() => reject(new Error('Timeout')), 5000)
  })

  const request = fetch(url)

  try {
    const result = await Promise.race([request, timeout])
    return result
  } catch (error) {
    console.error('Request failed:', error)
  }
}
```

The event loop manages both the timeout and the fetch request.

### Example 3: Debounce with Event Loop

```javascript
function debounce(fn, delay) {
  let timeoutId

  return function(...args) {
    // Cancel previous timeout (macrotask)
    clearTimeout(timeoutId)

    // Schedule new timeout
    timeoutId = setTimeout(() => {
      fn.apply(this, args)
    }, delay)
  }
}

const handleInput = debounce((e) => {
  console.log('Search:', e.target.value)
}, 500)

input.addEventListener('input', handleInput)
```

## Interview Question Patterns

### Pattern 1: Predict Output

```javascript
console.log('A')

setTimeout(() => console.log('B'), 0)

Promise.resolve()
  .then(() => console.log('C'))
  .then(() => console.log('D'))

console.log('E')

// Answer: A, E, C, D, B
```

### Pattern 2: Nested Promises and Timers

```javascript
Promise.resolve().then(() => {
  console.log('1')

  setTimeout(() => console.log('2'), 0)

  Promise.resolve().then(() => console.log('3'))
})

setTimeout(() => console.log('4'), 0)

console.log('5')

// Answer: 5, 1, 3, 4, 2
```

### Pattern 3: Async Function Order

```javascript
async function async1() {
  console.log('A')
  await async2()
  console.log('B')
}

async function async2() {
  console.log('C')
}

console.log('D')
async1()
console.log('E')

// Answer: D, A, C, E, B
```

## Common Misconceptions

1. **"setTimeout(fn, 0) runs immediately"**
   - False! It runs after all microtasks

2. **"Promises are faster than callbacks"**
   - False! Microtasks just have higher priority

3. **"Async/await makes code run in parallel"**
   - False! JavaScript is still single-threaded

4. **"The event loop only runs with async code"**
   - False! It always runs, managing all execution

## Key Takeaways

- JavaScript is **single-threaded** - one call stack executes code
- The **event loop** coordinates the call stack and queues
- **Microtasks** (Promises) have higher priority than macrotasks (setTimeout)
- The event loop processes **all microtasks** before the next macrotask
- Web APIs handle async operations in the background
- Understanding execution order helps debug async code
- Long synchronous code blocks the event loop (and UI)
- Code after `await` runs as a microtask
- Even `setTimeout(..., 0)` waits for all microtasks first

The event loop is the heart of JavaScript's async model. It creates the illusion of concurrency in a single-threaded language. Understanding it helps you write better async code and debug issues that seem mysterious at first.
