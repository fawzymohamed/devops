---
title: "Async/Await - Promise Syntax Sugar"
description: "Master async/await syntax for writing cleaner async code including error handling with try/catch and parallel execution patterns"
difficulty: intermediate
estimatedMinutes: 20
priority: essential
roadmap: fullstack
phase: 2
topic: asynchronous-javascript
learningObjectives:
  - "Understand async/await as syntactic sugar over Promises"
  - "Write async functions and use await to pause execution"
  - "Handle errors with try/catch in async functions"
  - "Execute multiple async operations in parallel with await"
  - "Convert Promise chains to async/await syntax"
quiz:
  passingScore: 70
  questions:
    - question: "What does the 'async' keyword do when added to a function?"
      type: single
      options:
        - "Makes the function always return a Promise"
        - "Makes the function run faster"
        - "Allows the function to run in parallel"
        - "Prevents the function from blocking"
      correctAnswer: "Makes the function always return a Promise"
      explanation: "The 'async' keyword makes a function automatically return a Promise. If you return a value, it's wrapped in Promise.resolve(). If you throw an error, it's wrapped in Promise.reject()."

    - question: "What does 'await' do in an async function?"
      type: single
      options:
        - "Pauses execution until the Promise resolves, then returns the value"
        - "Speeds up Promise execution"
        - "Makes Promises run in parallel"
        - "Converts callbacks to Promises"
      correctAnswer: "Pauses execution until the Promise resolves, then returns the value"
      explanation: "await pauses the async function's execution until the Promise settles. If the Promise fulfills, await returns the value. If it rejects, await throws the error."

    - question: "Select all TRUE statements about async/await error handling."
      type: multiple
      options:
        - "You can use try/catch blocks to handle errors"
        - "If you don't catch errors, the async function returns a rejected Promise"
        - "await throws an error if the Promise rejects"
        - "try/catch is the only way to handle errors in async functions"
      correctAnswers:
        - "You can use try/catch blocks to handle errors"
        - "If you don't catch errors, the async function returns a rejected Promise"
        - "await throws an error if the Promise rejects"
      explanation: "try/catch works with async/await because await throws on rejection. Uncaught errors reject the returned Promise. However, you can also use .catch() on the returned Promise - it's not the only way."

    - question: "Awaiting Promises sequentially when they could run in parallel wastes time."
      type: true-false
      correctAnswer: true
      explanation: "True! If operations don't depend on each other, await them sequentially wastes time. Use Promise.all() or start Promises without await, then await them together to run in parallel."

    - question: "How do you run multiple async operations in parallel with async/await?"
      type: single
      options:
        - "Start all Promises without await, then await Promise.all()"
        - "Use multiple await keywords on the same line"
        - "Use the 'parallel' keyword"
        - "Async/await cannot run operations in parallel"
      correctAnswer: "Start all Promises without await, then await Promise.all()"
      explanation: "To run in parallel: start the Promises without await (they begin executing), then use await Promise.all() to wait for all. If you await each one individually, they run sequentially."

    - question: "Can you use 'await' outside of an async function?"
      type: true-false
      correctAnswer: false
      explanation: "False! You can only use 'await' inside async functions. Using it outside causes a syntax error. Exception: Top-level await is allowed in ES modules, but that's a special case."
---

# Async/Await - Promise Syntax Sugar

Async/await makes async code look and behave like synchronous code. No more `.then()` chains - just write code top to bottom as if it were blocking. It's built on Promises but with cleaner syntax.

In this lesson, you will learn how async/await works, how to handle errors with try/catch, and how to run operations in parallel while keeping your code readable.

## What Is Async/Await?

**Async/await** is syntactic sugar over Promises. It doesn't replace Promises - it makes them easier to work with.

- **`async`** makes a function return a Promise
- **`await`** pauses execution until a Promise resolves

Think of `await` as saying, "Wait for this to finish before moving on."

### Basic Syntax

```javascript
// Function marked with 'async'
async function fetchUser() {
  // 'await' pauses until fetch completes
  const response = await fetch('/api/user/1')
  const user = await response.json()
  return user  // Automatically wrapped in Promise.resolve()
}

// Using the async function
fetchUser()
  .then(user => console.log(user))
  .catch(error => console.error(error))
```

### Comparison: Promises vs Async/Await

```javascript
// PROMISES (.then chain)
function getUserPosts() {
  return fetch('/api/user/1')
    .then(response => response.json())
    .then(user => {
      console.log('User:', user.name)
      return fetch(`/api/posts/${user.id}`)
    })
    .then(response => response.json())
    .then(posts => {
      console.log('Posts:', posts.length)
      return posts
    })
}

// ASYNC/AWAIT (looks synchronous)
async function getUserPosts() {
  const userResponse = await fetch('/api/user/1')
  const user = await userResponse.json()
  console.log('User:', user.name)

  const postsResponse = await fetch(`/api/posts/${user.id}`)
  const posts = await postsResponse.json()
  console.log('Posts:', posts.length)

  return posts
}
```

Both do the same thing, but async/await reads top to bottom like normal code.

## The Async Keyword

The `async` keyword makes a function **always return a Promise**:

```javascript
// Regular function returns a value
function regularFunction() {
  return 42
}

console.log(regularFunction())  // 42

// Async function returns a Promise
async function asyncFunction() {
  return 42
}

console.log(asyncFunction())  // Promise { 42 }

asyncFunction().then(value => console.log(value))  // 42
```

**What async does:**
- Wraps return values in `Promise.resolve(value)`
- Wraps thrown errors in `Promise.reject(error)`

```javascript
async function success() {
  return 'Success!'  // Same as: return Promise.resolve('Success!')
}

async function failure() {
  throw new Error('Failed!')  // Same as: return Promise.reject(new Error('Failed!'))
}
```

## The Await Keyword

The `await` keyword **pauses execution** until a Promise settles:

```javascript
async function example() {
  console.log('Start')

  const result = await delay(2000)  // Pauses here for 2 seconds

  console.log('After delay:', result)
  console.log('End')
}

function delay(ms) {
  return new Promise(resolve => setTimeout(() => resolve('Done!'), ms))
}

example()
// Output:
// Start
// (2 second pause)
// After delay: Done!
// End
```

**Important:** `await` only works inside `async` functions.

```javascript
// WRONG - SyntaxError
function notAsync() {
  const result = await fetch('/api/data')  // Error!
}

// CORRECT
async function isAsync() {
  const result = await fetch('/api/data')  // Works!
}
```

### What await Returns

- If Promise **fulfills**: `await` returns the value
- If Promise **rejects**: `await` throws the error

```javascript
async function example() {
  // Promise fulfills
  const value = await Promise.resolve(42)
  console.log(value)  // 42

  // Promise rejects - throws error
  try {
    await Promise.reject(new Error('Failed'))
  } catch (error) {
    console.error(error.message)  // "Failed"
  }
}
```

## Error Handling with Try/Catch

Use `try/catch` blocks to handle errors in async/await code:

```javascript
async function fetchUserData(userId) {
  try {
    const response = await fetch(`/api/users/${userId}`)

    if (!response.ok) {
      throw new Error(`HTTP error: ${response.status}`)
    }

    const user = await response.json()
    console.log('User:', user)
    return user

  } catch (error) {
    console.error('Error fetching user:', error.message)
    throw error  // Re-throw or handle
  }
}
```

### Multiple Operations in Try/Catch

```javascript
async function loadDashboard() {
  try {
    // All in one try block
    const user = await fetchUser()
    const posts = await fetchPosts(user.id)
    const comments = await fetchComments(posts[0].id)

    return { user, posts, comments }

  } catch (error) {
    console.error('Dashboard load failed:', error)
    return null  // Fallback value
  }
}
```

### Finally Block

Use `finally` for cleanup code:

```javascript
async function loadData() {
  showLoadingSpinner()

  try {
    const data = await fetch('/api/data')
    return await data.json()

  } catch (error) {
    showError(error)
    return null

  } finally {
    hideLoadingSpinner()  // Always runs
  }
}
```

## Sequential vs Parallel Execution

### Sequential (One After Another)

```javascript
// SLOW - Each await waits for previous to finish
async function sequential() {
  const user = await fetchUser(1)      // Wait 1 second
  const posts = await fetchPosts(2)    // Wait 1 second
  const comments = await fetchComments(3)  // Wait 1 second

  // Total: 3 seconds
  return { user, posts, comments }
}
```

::illustration-linear-flow
---
steps:
  - label: Fetch User
    sublabel: "1 second"
    icon: ðŸ‘¤
    color: violet
  - label: Fetch Posts
    sublabel: "1 second"
    icon: ðŸ“
    color: blue
  - label: Fetch Comments
    sublabel: "1 second"
    icon: ðŸ’¬
    color: emerald
---
::

### Parallel (All At Once)

```javascript
// FAST - All start at the same time
async function parallel() {
  // Start all Promises (don't await yet)
  const userPromise = fetchUser(1)
  const postsPromise = fetchPosts(2)
  const commentsPromise = fetchComments(3)

  // Wait for all to complete
  const [user, posts, comments] = await Promise.all([
    userPromise,
    postsPromise,
    commentsPromise
  ])

  // Total: 1 second (all run in parallel)
  return { user, posts, comments }
}
```

**Even cleaner:**

```javascript
async function parallel() {
  const [user, posts, comments] = await Promise.all([
    fetchUser(1),
    fetchPosts(2),
    fetchComments(3)
  ])

  return { user, posts, comments }
}
```

### When to Use Each

**Sequential** - When operations **depend** on each other:

```javascript
async function getUserAndPosts() {
  const user = await fetchUser(1)  // Need user first
  const posts = await fetchPosts(user.id)  // Depends on user
  return posts
}
```

**Parallel** - When operations are **independent**:

```javascript
async function getMultipleUsers() {
  const users = await Promise.all([
    fetchUser(1),
    fetchUser(2),
    fetchUser(3)
  ])
  return users
}
```

## Practical Examples

### Example 1: API Request with Error Handling

```javascript
async function loadUserProfile(userId) {
  try {
    // Fetch user data
    const userResponse = await fetch(`/api/users/${userId}`)

    if (!userResponse.ok) {
      throw new Error('User not found')
    }

    const user = await userResponse.json()

    // Fetch user's recent activity
    const activityResponse = await fetch(`/api/users/${userId}/activity`)
    const activity = await activityResponse.json()

    return {
      user,
      activity,
      loadedAt: new Date()
    }

  } catch (error) {
    console.error('Profile load error:', error)
    return null
  }
}
```

### Example 2: Mixed Sequential and Parallel

```javascript
async function loadDashboard(userId) {
  try {
    // Step 1: Get user (must be first)
    const user = await fetchUser(userId)

    // Step 2: Parallel fetch user's data
    const [posts, followers, settings] = await Promise.all([
      fetchPosts(user.id),
      fetchFollowers(user.id),
      fetchSettings(user.id)
    ])

    // Step 3: Sequential - need post IDs from step 2
    const postStats = await fetchPostStats(posts.map(p => p.id))

    return {
      user,
      posts,
      followers,
      settings,
      postStats
    }

  } catch (error) {
    console.error('Dashboard error:', error)
    throw error
  }
}
```

### Example 3: Retry Logic

```javascript
async function fetchWithRetry(url, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      const response = await fetch(url)

      if (response.ok) {
        return await response.json()
      }

      throw new Error(`HTTP ${response.status}`)

    } catch (error) {
      if (i === maxRetries - 1) {
        throw error  // Last attempt failed
      }

      console.log(`Retry ${i + 1}/${maxRetries}`)
      await delay(1000 * (i + 1))  // Exponential backoff
    }
  }
}

function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms))
}
```

### Example 4: Async Array Processing

```javascript
// WRONG - forEach doesn't await
async function processWrong(items) {
  items.forEach(async (item) => {
    await processItem(item)  // Doesn't actually wait!
  })
  console.log('Done')  // Runs before items are processed!
}

// CORRECT - for...of loop
async function processSequential(items) {
  for (const item of items) {
    await processItem(item)  // Waits for each
  }
  console.log('Done')  // Runs after all items processed
}

// CORRECT - parallel processing
async function processParallel(items) {
  await Promise.all(items.map(item => processItem(item)))
  console.log('Done')
}
```

## Common Patterns

### Pattern 1: Conditional Async

```javascript
async function getData(useCache = false) {
  if (useCache) {
    return getCachedData()  // Synchronous
  }

  const response = await fetch('/api/data')  // Asynchronous
  return await response.json()
}
```

### Pattern 2: Promise.race with Timeout

```javascript
async function fetchWithTimeout(url, timeout = 5000) {
  const timeoutPromise = new Promise((_, reject) => {
    setTimeout(() => reject(new Error('Timeout')), timeout)
  })

  const fetchPromise = fetch(url)

  const response = await Promise.race([fetchPromise, timeoutPromise])
  return await response.json()
}
```

### Pattern 3: Async IIFE

```javascript
// Immediately-invoked async function
(async () => {
  const data = await fetch('/api/data')
  console.log(await data.json())
})()

// Or use top-level await in ES modules
// const data = await fetch('/api/data')
```

## Converting Promises to Async/Await

### Before (Promise Chain)

```javascript
function loginUser(email, password) {
  return validateCredentials(email, password)
    .then(isValid => {
      if (!isValid) {
        throw new Error('Invalid credentials')
      }
      return authenticateUser(email, password)
    })
    .then(token => {
      return getUserProfile(token)
    })
    .then(profile => {
      return loadUserData(profile.id)
    })
    .catch(error => {
      console.error('Login failed:', error)
      throw error
    })
}
```

### After (Async/Await)

```javascript
async function loginUser(email, password) {
  try {
    const isValid = await validateCredentials(email, password)

    if (!isValid) {
      throw new Error('Invalid credentials')
    }

    const token = await authenticateUser(email, password)
    const profile = await getUserProfile(token)
    const userData = await loadUserData(profile.id)

    return userData

  } catch (error) {
    console.error('Login failed:', error)
    throw error
  }
}
```

Much easier to read!

## Common Mistakes

### 1. Forgetting await

```javascript
// WRONG - returns Promise, not value
async function wrong() {
  const user = fetchUser()  // No await!
  console.log(user)  // Promise { <pending> }
}

// CORRECT
async function correct() {
  const user = await fetchUser()
  console.log(user)  // { id: 1, name: 'Alice' }
}
```

### 2. Sequential When Parallel Would Work

```javascript
// SLOW - 3 seconds total
async function slow() {
  const user1 = await fetchUser(1)    // 1s
  const user2 = await fetchUser(2)    // 1s
  const user3 = await fetchUser(3)    // 1s
  return [user1, user2, user3]
}

// FAST - 1 second total
async function fast() {
  const users = await Promise.all([
    fetchUser(1),
    fetchUser(2),
    fetchUser(3)
  ])
  return users
}
```

### 3. Not Handling Errors

```javascript
// WRONG - unhandled rejection
async function risky() {
  const data = await fetch('/api/data')
  // If fetch fails, uncaught error
}

// CORRECT
async function safe() {
  try {
    const data = await fetch('/api/data')
    return data
  } catch (error) {
    console.error('Fetch failed:', error)
    return null
  }
}
```

### 4. Using await in forEach

```javascript
// WRONG - doesn't wait
async function wrong(items) {
  items.forEach(async (item) => {
    await processItem(item)  // forEach doesn't await!
  })
}

// CORRECT
async function correct(items) {
  for (const item of items) {
    await processItem(item)
  }
}
```

## Key Takeaways

- **async** makes functions return Promises automatically
- **await** pauses execution until a Promise resolves
- Use **try/catch** for error handling in async functions
- Await **sequentially** when operations depend on each other
- Run **in parallel** using Promise.all() when operations are independent
- Async/await is **syntactic sugar** over Promises - not a replacement
- You can mix async/await with Promise methods (all, race, etc.)
- Remember: await **only works inside async functions**
- Avoid sequential await when parallel would work - it wastes time
- Always handle errors with try/catch or .catch()

Async/await makes async code readable and maintainable. It's built on Promises, so understanding Promises (lesson 2) is essential. Next, you'll learn how JavaScript manages async operations behind the scenes with the event loop.
