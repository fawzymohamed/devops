---
title: "Asynchronous JavaScript - Quick Reference"
description: "Quick reference for callbacks, Promises, async/await, event loop, Fetch API, AbortController, and Web Workers"
estimatedMinutes: 5
difficulty: intermediate
learningObjectives:
  - "Quick reference for async JavaScript concepts and patterns"
isCheatSheet: true
cheatSheetTopic: "Asynchronous JavaScript"
roadmap: fullstack
phase: 2
topic: asynchronous-javascript
---

# Asynchronous JavaScript - Quick Reference

## Callbacks

### Error-First Callback Convention

```javascript
function getData(callback) {
  // callback(error, result)
  if (error) {
    callback(new Error('Failed'), null)
  } else {
    callback(null, data)
  }
}

// Usage
getData((error, result) => {
  if (error) return console.error(error)
  console.log(result)
})
```

### Callback Hell (Anti-pattern)

```javascript
// AVOID - Pyramid of Doom
doStep1((err, data1) => {
  if (err) return handleError(err)
  doStep2(data1, (err, data2) => {
    if (err) return handleError(err)
    doStep3(data2, (err, data3) => {
      // Deeply nested...
    })
  })
})
```

---

## Promises

### Creating Promises

```javascript
const promise = new Promise((resolve, reject) => {
  if (success) {
    resolve(value)   // Fulfill
  } else {
    reject(error)    // Reject
  }
})
```

### Promise States

| State | Description |
|-------|-------------|
| **Pending** | Initial state, neither fulfilled nor rejected |
| **Fulfilled** | Operation completed successfully |
| **Rejected** | Operation failed |

### Promise Methods

```javascript
// Chaining
promise
  .then(result => {
    // Handle success
    return nextValue  // Pass to next .then()
  })
  .catch(error => {
    // Handle error
  })
  .finally(() => {
    // Cleanup (runs regardless)
  })
```

### Promise Static Methods

| Method | Behavior | Use Case |
|--------|----------|----------|
| `Promise.all([...])` | Fulfills when ALL succeed, rejects on first failure | All must succeed |
| `Promise.race([...])` | Returns first to settle (fulfill or reject) | Timeout patterns |
| `Promise.allSettled([...])` | Returns all results (never rejects) | Need all results |
| `Promise.any([...])` | Fulfills on first success, rejects if all fail | First available source |

```javascript
// Promise.all - all or nothing
const [users, posts, comments] = await Promise.all([
  fetchUsers(),
  fetchPosts(),
  fetchComments()
])

// Promise.allSettled - all results
const results = await Promise.allSettled([
  fetch('/api/1'),
  fetch('/api/2'),
  fetch('/api/3')
])
// Returns: [{ status, value/reason }, ...]

// Promise.race - first to finish
const result = await Promise.race([
  fetch('/api/data'),
  timeout(5000)  // Timeout after 5s
])

// Promise.any - first success
const data = await Promise.any([
  fetch('https://server1.com/api'),
  fetch('https://server2.com/api'),
  fetch('https://server3.com/api')
])
```

---

## Async/Await

### Basic Syntax

```javascript
async function fetchData() {
  try {
    const response = await fetch('/api/data')
    const data = await response.json()
    return data
  } catch (error) {
    console.error('Error:', error)
    throw error
  } finally {
    console.log('Cleanup')
  }
}
```

### Key Rules

1. **async** makes function return a Promise
2. **await** pauses until Promise resolves
3. Can only use **await** inside **async** functions
4. Use **try/catch** for error handling

### Sequential vs Parallel

```javascript
// ❌ SLOW - Sequential (3 seconds total)
async function sequential() {
  const user = await fetchUser()    // 1s
  const posts = await fetchPosts()  // 1s
  const comments = await fetchComments()  // 1s
  return { user, posts, comments }
}

// ✅ FAST - Parallel (1 second total)
async function parallel() {
  const [user, posts, comments] = await Promise.all([
    fetchUser(),
    fetchPosts(),
    fetchComments()
  ])
  return { user, posts, comments }
}
```

---

## Event Loop

### Components

| Component | Role |
|-----------|------|
| **Call Stack** | Executes functions (LIFO) |
| **Web APIs** | Handle async operations (timers, fetch, events) |
| **Microtask Queue** | Promises, async/await, queueMicrotask |
| **Macrotask Queue** | setTimeout, setInterval, I/O |

### Execution Order

```javascript
console.log('1')           // Sync → 1

setTimeout(() => {
  console.log('2')         // Macrotask → 4
}, 0)

Promise.resolve().then(() => {
  console.log('3')         // Microtask → 3
})

console.log('4')           // Sync → 2

// Output: 1, 4, 3, 2
```

### Priority Order

1. **Synchronous code** (call stack)
2. **All microtasks** (Promises)
3. **One macrotask** (setTimeout)
4. Repeat from step 2

> **Microtasks always run before the next macrotask!**

---

## Fetch API

### Basic GET Request

```javascript
async function getData() {
  try {
    const response = await fetch('/api/data')

    // Check status FIRST!
    if (!response.ok) {
      throw new Error(`HTTP error: ${response.status}`)
    }

    const data = await response.json()
    return data
  } catch (error) {
    console.error('Fetch failed:', error)
    return null
  }
}
```

### POST Request

```javascript
async function createUser(userData) {
  const response = await fetch('/api/users', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(userData)
  })

  if (!response.ok) {
    throw new Error('Create failed')
  }

  return await response.json()
}
```

### HTTP Methods

| Method | Purpose | Body Required |
|--------|---------|---------------|
| **GET** | Retrieve data | No |
| **POST** | Create resource | Yes |
| **PUT** | Full update | Yes |
| **PATCH** | Partial update | Yes |
| **DELETE** | Delete resource | No |

### Response Methods

| Method | Returns | Use For |
|--------|---------|---------|
| `response.json()` | Promise → parsed JSON | JSON APIs |
| `response.text()` | Promise → string | Plain text |
| `response.blob()` | Promise → Blob | Images, files |
| `response.arrayBuffer()` | Promise → ArrayBuffer | Binary data |

---

## AbortController

### Basic Usage

```javascript
const controller = new AbortController()

fetch('/api/data', {
  signal: controller.signal
})
  .then(response => response.json())
  .catch(error => {
    if (error.name === 'AbortError') {
      console.log('Request cancelled')
    }
  })

// Cancel the request
controller.abort()
```

### Timeout Pattern

```javascript
async function fetchWithTimeout(url, timeout = 5000) {
  const controller = new AbortController()
  const timeoutId = setTimeout(() => controller.abort(), timeout)

  try {
    const response = await fetch(url, {
      signal: controller.signal
    })
    clearTimeout(timeoutId)
    return await response.json()
  } catch (error) {
    clearTimeout(timeoutId)
    if (error.name === 'AbortError') {
      throw new Error('Request timeout')
    }
    throw error
  }
}
```

### Cancel Previous Request Pattern

```javascript
let currentController = null

async function search(query) {
  // Cancel previous search
  if (currentController) {
    currentController.abort()
  }

  currentController = new AbortController()

  try {
    const response = await fetch(`/api/search?q=${query}`, {
      signal: currentController.signal
    })
    return await response.json()
  } catch (error) {
    if (error.name !== 'AbortError') {
      throw error
    }
  }
}
```

---

## Web Workers

### Creating a Worker

```javascript
// worker.js
onmessage = function(event) {
  const result = processData(event.data)
  postMessage(result)
}

function processData(data) {
  // Heavy computation
  return result
}
```

### Using a Worker

```javascript
// Main thread
const worker = new Worker('worker.js')

// Send data
worker.postMessage({ type: 'calculate', data: [1, 2, 3] })

// Receive results
worker.onmessage = (event) => {
  console.log('Result:', event.data)
}

// Handle errors
worker.onerror = (error) => {
  console.error('Worker error:', error)
}

// Terminate when done
worker.terminate()
```

### Workers Can vs Cannot

| ✅ CAN | ❌ CANNOT |
|--------|-----------|
| Run JavaScript | Access DOM |
| Use fetch() | Access window |
| Use timers | Access localStorage |
| Spawn nested workers | Manipulate UI |
| Use standard objects | Access parent variables |

### When to Use Workers

| ✅ Use Workers | ❌ Don't Use Workers |
|----------------|---------------------|
| Heavy calculations | Simple operations |
| Data parsing | DOM manipulation |
| Image processing | Small datasets |
| Cryptography | Already async operations |
| Game AI | Network requests alone |

---

## Common Patterns

### Retry with Exponential Backoff

```javascript
async function fetchWithRetry(url, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      const response = await fetch(url)
      if (response.ok) return await response.json()

      // Don't retry client errors (4xx)
      if (response.status >= 400 && response.status < 500) {
        throw new Error(`Client error: ${response.status}`)
      }
    } catch (error) {
      if (i === maxRetries - 1) throw error

      const delay = Math.pow(2, i) * 1000  // 1s, 2s, 4s
      await new Promise(resolve => setTimeout(resolve, delay))
    }
  }
}
```

### Promise Wrapper for Callbacks

```javascript
function promisify(fn) {
  return function(...args) {
    return new Promise((resolve, reject) => {
      fn(...args, (error, result) => {
        if (error) reject(error)
        else resolve(result)
      })
    })
  }
}

// Usage
const readFileAsync = promisify(fs.readFile)
const data = await readFileAsync('file.txt', 'utf8')
```

### Debounce with Promises

```javascript
function debounce(fn, delay) {
  let timeoutId
  return function(...args) {
    clearTimeout(timeoutId)
    return new Promise((resolve) => {
      timeoutId = setTimeout(() => {
        resolve(fn.apply(this, args))
      }, delay)
    })
  }
}
```

---

## Interview Quick Tips

### Predicting Execution Order

1. All synchronous code first
2. All microtasks (Promises)
3. One macrotask (setTimeout)
4. Repeat from step 2

### Common Gotchas

| Issue | Problem | Solution |
|-------|---------|----------|
| **fetch() doesn't reject on 404** | HTTP errors don't throw | Check `response.ok` |
| **await in forEach** | forEach doesn't await | Use `for...of` loop |
| **Sequential when parallel** | Slow performance | Use `Promise.all()` |
| **Forgetting to return** | Broken Promise chain | Always return from `.then()` |
| **No error handling** | Unhandled rejections | Always use `.catch()` or try/catch |

### Best Practices

1. Always check `response.ok` with fetch
2. Use async/await over .then() chains for readability
3. Parallel operations with `Promise.all()` when possible
4. Cancel requests with AbortController when needed
5. Use Workers only for CPU-intensive tasks
6. Handle errors with try/catch in async functions
7. Clean up resources in finally blocks

---

## Quick Syntax Reference

```javascript
// Promise creation
new Promise((resolve, reject) => {})

// Promise consumption
promise.then().catch().finally()

// Async function
async function name() {
  const result = await promise
}

// Fetch
await fetch(url, { method, headers, body })

// AbortController
const controller = new AbortController()
fetch(url, { signal: controller.signal })
controller.abort()

// Web Worker
const worker = new Worker('worker.js')
worker.postMessage(data)
worker.onmessage = (event) => {}
worker.terminate()
```
