---
title: "Promises - Modern Async JavaScript"
description: "Master JavaScript Promises including then, catch, finally, Promise.all, Promise.race, Promise.allSettled, and Promise.any"
difficulty: intermediate
estimatedMinutes: 25
priority: essential
roadmap: fullstack
phase: 2
topic: asynchronous-javascript
learningObjectives:
  - "Understand what Promises are and their three states"
  - "Chain Promises using then, catch, and finally methods"
  - "Use Promise.all for parallel operations"
  - "Compare Promise.race, Promise.allSettled, and Promise.any"
  - "Handle errors effectively in Promise chains"
quiz:
  passingScore: 70
  questions:
    - question: "What are the three states of a JavaScript Promise?"
      type: single
      options:
        - "Pending, Fulfilled, Rejected"
        - "Created, Running, Completed"
        - "Start, Process, End"
        - "Ready, Executing, Done"
      correctAnswer: "Pending, Fulfilled, Rejected"
      explanation: "A Promise has three states: Pending (initial state), Fulfilled (operation completed successfully), and Rejected (operation failed). Once a Promise is fulfilled or rejected, it's settled and can't change state again."

    - question: "What does Promise.all() do when one of the Promises rejects?"
      type: single
      options:
        - "Rejects immediately with the first rejection reason"
        - "Waits for all Promises to settle then returns errors"
        - "Ignores the rejection and continues"
        - "Returns only the successful Promise results"
      correctAnswer: "Rejects immediately with the first rejection reason"
      explanation: "Promise.all() is all-or-nothing. If any Promise rejects, Promise.all() rejects immediately with that rejection reason, without waiting for other Promises. Use Promise.allSettled() if you want all results regardless of success/failure."

    - question: "Select all TRUE statements about Promise chaining."
      type: multiple
      options:
        - "Each .then() returns a new Promise"
        - "You can return values from .then() to pass to the next .then()"
        - "You can return Promises from .then() to chain async operations"
        - "A single .catch() at the end catches all errors in the chain"
      correctAnswers:
        - "Each .then() returns a new Promise"
        - "You can return values from .then() to pass to the next .then()"
        - "You can return Promises from .then() to chain async operations"
        - "A single .catch() at the end catches all errors in the chain"
      explanation: "All statements are true! Promises chain because each .then() returns a new Promise. You can return values or Promises to continue the chain. A .catch() at the end catches any error from any step in the chain."

    - question: "Promise.race() returns when the first Promise settles, regardless of whether it fulfills or rejects."
      type: true-false
      correctAnswer: true
      explanation: "True! Promise.race() lives up to its name - it returns as soon as ANY Promise settles, whether that's a fulfillment or rejection. The first to finish wins the race."

    - question: "Which Promise method should you use when you need results from ALL Promises even if some fail?"
      type: single
      options:
        - "Promise.allSettled()"
        - "Promise.all()"
        - "Promise.race()"
        - "Promise.any()"
      correctAnswer: "Promise.allSettled()"
      explanation: "Promise.allSettled() waits for all Promises to settle and returns an array of outcome objects { status, value/reason } for each Promise. It never rejects, making it perfect when you need all results regardless of success or failure."

    - question: "What does the .finally() method run?"
      type: single
      options:
        - "Cleanup code that runs whether the Promise fulfills or rejects"
        - "Only when the Promise is rejected"
        - "Only when the Promise is fulfilled"
        - "Before any .then() or .catch() handlers"
      correctAnswer: "Cleanup code that runs whether the Promise fulfills or rejects"
      explanation: ".finally() runs regardless of whether the Promise fulfills or rejects. It's perfect for cleanup code like hiding loading spinners, closing connections, or releasing resources."
---

# Promises - Modern Async JavaScript

Promises revolutionized async JavaScript by solving callback hell. Instead of nesting callbacks, Promises let you chain operations in a flat, readable way. They're now the foundation of modern async code.

In this lesson, you will learn how Promises work, how to chain them, and how to use powerful methods like Promise.all() and Promise.race() to manage multiple async operations.

## What Is a Promise?

A **Promise** is an object that represents a future value. It's JavaScript saying, "I don't have the result yet, but I promise to give it to you when ready."

Think of it like ordering food online:
- **Pending**: Your order is being prepared
- **Fulfilled**: Food arrives (success!)
- **Rejected**: Restaurant is closed (failure)

```javascript
// Creating a Promise
const myPromise = new Promise((resolve, reject) => {
  // Do async work here
  const success = true

  if (success) {
    resolve("Operation succeeded!")  // Fulfill the Promise
  } else {
    reject("Operation failed!")      // Reject the Promise
  }
})
```

### The Three States

::illustration-linear-flow
---
steps:
  - label: Pending
    sublabel: "Initial state"
    icon: â³
    color: violet
  - label: Fulfilled
    sublabel: "Success"
    icon: âœ…
    color: emerald
  - label: Rejected
    sublabel: "Failure"
    icon: âŒ
    color: rose
---
::

- **Pending**: Initial state, neither fulfilled nor rejected
- **Fulfilled**: Operation completed successfully
- **Rejected**: Operation failed

Once a Promise is fulfilled or rejected, it's **settled** and can never change state again.

## Basic Promise Usage

Use `.then()` to handle success and `.catch()` to handle errors:

```javascript
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("Data loaded!")
  }, 1000)
})

promise
  .then(result => {
    console.log(result)  // "Data loaded!"
  })
  .catch(error => {
    console.error(error)
  })
```

### Comparison with Callbacks

Remember the callback hell from lesson 1? Here's the same logic with Promises:

```javascript
// CALLBACKS (nested)
getUser(1, (err, user) => {
  if (err) return handleError(err)

  getPosts(user.id, (err, posts) => {
    if (err) return handleError(err)

    getComments(posts[0].id, (err, comments) => {
      if (err) return handleError(err)
      console.log(comments)
    })
  })
})

// PROMISES (flat)
getUser(1)
  .then(user => getPosts(user.id))
  .then(posts => getComments(posts[0].id))
  .then(comments => console.log(comments))
  .catch(handleError)  // Single error handler!
```

Much cleaner! Code flows top to bottom, and one `.catch()` handles all errors.

## Promise Chaining

Each `.then()` returns a **new Promise**, allowing you to chain operations:

```javascript
fetch('https://api.example.com/user/1')
  .then(response => response.json())      // Parse JSON
  .then(user => {
    console.log('User:', user.name)
    return fetch(`https://api.example.com/posts/${user.id}`)
  })
  .then(response => response.json())      // Parse posts
  .then(posts => {
    console.log('Posts:', posts.length)
    return posts[0]
  })
  .then(firstPost => {
    console.log('First post:', firstPost.title)
  })
  .catch(error => {
    console.error('Error:', error)
  })
```

### Key Rules for Chaining

1. **Return a value**: Next `.then()` receives it

```javascript
Promise.resolve(5)
  .then(num => num * 2)      // Returns 10
  .then(num => num + 3)      // Receives 10, returns 13
  .then(num => console.log(num))  // 13
```

2. **Return a Promise**: Next `.then()` waits for it

```javascript
Promise.resolve(5)
  .then(num => {
    return new Promise(resolve => {
      setTimeout(() => resolve(num * 2), 1000)
    })
  })
  .then(num => console.log(num))  // 10 (after 1 second)
```

3. **Don't return anything**: Next `.then()` receives undefined

```javascript
Promise.resolve(5)
  .then(num => {
    console.log(num)  // 5
    // No return!
  })
  .then(num => console.log(num))  // undefined
```

## Error Handling in Promises

### Using .catch()

`.catch()` catches any error in the chain before it:

```javascript
Promise.resolve(5)
  .then(num => num * 2)
  .then(num => {
    throw new Error("Something broke!")
  })
  .then(num => console.log(num))  // Skipped
  .catch(error => {
    console.error("Caught:", error.message)  // "Something broke!"
  })
```

### Error Recovery

You can recover from errors and continue the chain:

```javascript
fetch('/api/data')
  .catch(error => {
    console.warn('API failed, using cached data')
    return getCachedData()  // Recovery
  })
  .then(data => {
    console.log('Using data:', data)
  })
```

### Using .finally()

`.finally()` runs whether the Promise succeeds or fails:

```javascript
showLoadingSpinner()

fetch('/api/data')
  .then(response => response.json())
  .then(data => displayData(data))
  .catch(error => showError(error))
  .finally(() => {
    hideLoadingSpinner()  // Runs no matter what
  })
```

Perfect for cleanup code!

## Promise.all() - Parallel Operations

`Promise.all()` runs multiple Promises in parallel and waits for **all** to complete:

```javascript
const promise1 = fetch('/api/users')
const promise2 = fetch('/api/posts')
const promise3 = fetch('/api/comments')

Promise.all([promise1, promise2, promise3])
  .then(responses => {
    // All three succeeded
    return Promise.all(responses.map(r => r.json()))
  })
  .then(([users, posts, comments]) => {
    console.log('Users:', users.length)
    console.log('Posts:', posts.length)
    console.log('Comments:', comments.length)
  })
  .catch(error => {
    // ANY Promise failed
    console.error('One or more requests failed:', error)
  })
```

**Behavior:**
- âœ… Fulfills with array of results when **all** Promises succeed
- âŒ Rejects immediately when **any** Promise fails

**Use When:**
- All operations must succeed
- You need all results before proceeding
- Operations can run in parallel

## Promise.race() - First to Finish

`Promise.race()` returns when the **first** Promise settles (success or failure):

```javascript
const timeout = new Promise((resolve, reject) => {
  setTimeout(() => reject(new Error('Timeout')), 5000)
})

const fetchData = fetch('/api/data')

Promise.race([fetchData, timeout])
  .then(response => console.log('Got response!'))
  .catch(error => console.error('Timed out or failed'))
```

**Use Cases:**
- Timeout patterns
- Using fastest of multiple sources
- Racing against time limits

## Promise.allSettled() - All Results

`Promise.allSettled()` waits for **all** Promises and returns results for each, regardless of success or failure:

```javascript
const promises = [
  fetch('/api/users'),      // Succeeds
  fetch('/api/invalid'),    // Fails
  fetch('/api/posts')       // Succeeds
]

Promise.allSettled(promises)
  .then(results => {
    results.forEach((result, index) => {
      if (result.status === 'fulfilled') {
        console.log(`Promise ${index}: Success`, result.value)
      } else {
        console.log(`Promise ${index}: Failed`, result.reason)
      }
    })
  })

// Output:
// Promise 0: Success [response]
// Promise 1: Failed [error]
// Promise 2: Success [response]
```

**Returns array of objects:**
```javascript
[
  { status: 'fulfilled', value: result },
  { status: 'rejected', reason: error },
  { status: 'fulfilled', value: result }
]
```

**Use When:**
- You need all results regardless of success/failure
- Failures in some operations shouldn't stop others
- You want to process successes and log failures separately

## Promise.any() - First Success

`Promise.any()` fulfills when the **first** Promise succeeds. Rejects only if **all** fail:

```javascript
const server1 = fetch('https://server1.example.com/api')
const server2 = fetch('https://server2.example.com/api')
const server3 = fetch('https://server3.example.com/api')

Promise.any([server1, server2, server3])
  .then(response => {
    console.log('Got response from fastest server')
    return response.json()
  })
  .catch(error => {
    // ALL servers failed
    console.error('All servers are down:', error)
  })
```

**Behavior:**
- âœ… Fulfills with first successful result
- âŒ Rejects with `AggregateError` only if **all** fail

**Use Cases:**
- Load balancing (try multiple servers)
- Fallback sources (use first available)
- Best-effort operations

## Comparison Table

::illustration-comparison-map
---
leftTitle: Method
rightTitle: Behavior
leftColor: violet
rightColor: cyan
connections:
  - left: Promise.all()
    right: All must succeed or rejects immediately
    icon: ðŸŽ¯
  - left: Promise.race()
    right: Returns first to settle (success or failure)
    icon: ðŸ
  - left: Promise.allSettled()
    right: Returns all results (never rejects)
    icon: ðŸ“Š
  - left: Promise.any()
    right: Returns first success or all failures
    icon: ðŸŽ²
footnote: Choose based on your needs - all, first, or resilient
---
::

## Practical Examples

### Example 1: Sequential API Calls

```javascript
// Get user, then their posts, then first post's comments
function getUserData(userId) {
  return fetch(`/api/users/${userId}`)
    .then(res => res.json())
    .then(user => {
      console.log('User:', user.name)
      return fetch(`/api/users/${user.id}/posts`)
    })
    .then(res => res.json())
    .then(posts => {
      console.log('Posts:', posts.length)
      if (posts.length > 0) {
        return fetch(`/api/posts/${posts[0].id}/comments`)
      }
      throw new Error('No posts found')
    })
    .then(res => res.json())
    .then(comments => {
      console.log('Comments:', comments.length)
      return comments
    })
    .catch(error => {
      console.error('Error in chain:', error)
    })
}
```

### Example 2: Parallel + Sequential

```javascript
// Fetch multiple users in parallel, then fetch each user's posts
function getAllUserPosts() {
  const userIds = [1, 2, 3, 4, 5]

  // Step 1: Fetch all users in parallel
  const userPromises = userIds.map(id =>
    fetch(`/api/users/${id}`).then(r => r.json())
  )

  return Promise.all(userPromises)
    .then(users => {
      console.log('Fetched all users')

      // Step 2: Fetch posts for each user in parallel
      const postPromises = users.map(user =>
        fetch(`/api/users/${user.id}/posts`).then(r => r.json())
      )

      return Promise.all(postPromises)
    })
    .then(allPosts => {
      console.log('Fetched all posts')
      return allPosts
    })
}
```

### Example 3: With Timeout

```javascript
function fetchWithTimeout(url, timeout = 5000) {
  const fetchPromise = fetch(url)

  const timeoutPromise = new Promise((_, reject) => {
    setTimeout(() => reject(new Error('Request timeout')), timeout)
  })

  return Promise.race([fetchPromise, timeoutPromise])
}

// Use it
fetchWithTimeout('/api/slow-endpoint', 3000)
  .then(response => response.json())
  .then(data => console.log('Data:', data))
  .catch(error => console.error('Failed:', error.message))
```

## Creating Your Own Promises

```javascript
function delay(ms) {
  return new Promise(resolve => {
    setTimeout(resolve, ms)
  })
}

// Use it
console.log('Start')
delay(2000)
  .then(() => {
    console.log('2 seconds passed')
    return delay(1000)
  })
  .then(() => {
    console.log('Another second passed')
  })

// Or simulate async operations
function fetchUser(id) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (id > 0) {
        resolve({ id, name: 'Alice' })
      } else {
        reject(new Error('Invalid user ID'))
      }
    }, 1000)
  })
}
```

## Common Mistakes

### 1. Forgetting to Return

```javascript
// WRONG - broken chain
fetch('/api/user')
  .then(response => {
    response.json()  // No return!
  })
  .then(data => {
    console.log(data)  // undefined
  })

// CORRECT
fetch('/api/user')
  .then(response => response.json())  // Return the Promise
  .then(data => console.log(data))
```

### 2. Nested Promises (Back to Callback Hell!)

```javascript
// WRONG - defeats the purpose of Promises
fetch('/api/user')
  .then(response => {
    response.json().then(user => {
      fetch(`/api/posts/${user.id}`).then(response => {
        // Nested hell!
      })
    })
  })

// CORRECT - flat chain
fetch('/api/user')
  .then(response => response.json())
  .then(user => fetch(`/api/posts/${user.id}`))
  .then(response => response.json())
```

### 3. Not Handling Rejections

```javascript
// WRONG - unhandled rejection
fetch('/api/data')
  .then(response => response.json())
  .then(data => console.log(data))
// No .catch() = uncaught error if fetch fails

// CORRECT
fetch('/api/data')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Failed:', error))
```

## Key Takeaways

- **Promises** represent future values with three states: pending, fulfilled, rejected
- Use `.then()` for success, `.catch()` for errors, `.finally()` for cleanup
- **Chain Promises** by returning values or new Promises from `.then()`
- **Promise.all()** runs operations in parallel; rejects if any fail
- **Promise.race()** returns first to settle (success or failure)
- **Promise.allSettled()** returns all results; never rejects
- **Promise.any()** returns first success; rejects if all fail
- Always return values/Promises in chains to avoid breaking the flow
- One `.catch()` at the end catches all errors in the chain
- Promises are the foundation for async/await (next lesson)

Promises transformed async JavaScript from callback hell to elegant chains. Master Promises, and you're ready for async/await - which makes Promises even easier to work with.
