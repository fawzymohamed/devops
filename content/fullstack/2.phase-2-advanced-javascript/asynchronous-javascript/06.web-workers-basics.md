---
title: "Web Workers Basics"
description: "Learn to run JavaScript in background threads using Web Workers for CPU-intensive tasks without blocking the UI"
difficulty: intermediate
estimatedMinutes: 18
priority: essential
roadmap: fullstack
phase: 2
topic: asynchronous-javascript
learningObjectives:
  - "Understand what Web Workers are and when to use them"
  - "Create and communicate with Web Workers using postMessage"
  - "Handle messages and errors from Worker threads"
  - "Recognize the limitations of Web Workers (no DOM access)"
  - "Implement practical use cases for background processing"
quiz:
  passingScore: 70
  questions:
    - question: "What is the main purpose of Web Workers?"
      type: single
      options:
        - "Run JavaScript in a separate thread to avoid blocking the UI"
        - "Make network requests faster"
        - "Access the DOM from multiple threads"
        - "Automatically parallelize all JavaScript code"
      correctAnswer: "Run JavaScript in a separate thread to avoid blocking the UI"
      explanation: "Web Workers run JavaScript in a background thread separate from the main UI thread. This prevents CPU-intensive tasks from freezing the interface. However, they don't make individual operations faster - they just don't block the UI."

    - question: "Can Web Workers directly access the DOM?"
      type: true-false
      correctAnswer: false
      explanation: "False! Web Workers run in a separate context without access to the DOM, window object, or document. They can't manipulate the UI directly. You must send messages between the main thread and worker thread."

    - question: "How do you communicate between the main thread and a Web Worker?"
      type: single
      options:
        - "Using postMessage() to send messages and onmessage to receive them"
        - "By sharing variables directly"
        - "Through the DOM using event listeners"
        - "Workers automatically share the main thread's scope"
      correctAnswer: "Using postMessage() to send messages and onmessage to receive them"
      explanation: "Communication happens via message passing. The main thread uses worker.postMessage() to send data, and the worker uses onmessage to receive it. Data is copied (structured clone), not shared."

    - question: "Select all TRUE statements about Web Workers."
      type: multiple
      options:
        - "Workers can make network requests using fetch()"
        - "Workers can spawn new workers (nested workers)"
        - "Data sent to workers is copied, not shared"
        - "Workers have access to localStorage"
      correctAnswers:
        - "Workers can make network requests using fetch()"
        - "Workers can spawn new workers (nested workers)"
        - "Data sent to workers is copied, not shared"
      explanation: "Workers can use fetch(), spawn nested workers, and receive copied data via structured cloning. However, they do NOT have access to localStorage, sessionStorage, or other Window-specific APIs."

    - question: "When should you use Web Workers?"
      type: single
      options:
        - "For CPU-intensive tasks like data processing, calculations, or parsing"
        - "For all async operations to improve performance"
        - "To make network requests faster"
        - "Whenever you need to update the DOM"
      correctAnswer: "For CPU-intensive tasks like data processing, calculations, or parsing"
      explanation: "Use Web Workers for CPU-intensive synchronous operations that would otherwise block the UI - like heavy calculations, data parsing, image processing, or cryptography. Don't use them for simple async operations (use Promises) or DOM manipulation (workers can't access DOM)."

    - question: "What happens to data sent via postMessage()?"
      type: single
      options:
        - "It's copied using structured clone algorithm - not shared by reference"
        - "It's shared by reference for efficiency"
        - "It's converted to JSON automatically"
        - "Only strings can be sent"
      correctAnswer: "It's copied using structured clone algorithm - not shared by reference"
      explanation: "Data sent via postMessage() is copied using the structured clone algorithm. This means changes in one context don't affect the other. You can send most data types, but not functions, DOM nodes, or objects with methods."
---

# Web Workers Basics

JavaScript is single-threaded, but sometimes you need to do heavy work without freezing the UI. **Web Workers** let you run JavaScript in background threads, keeping your interface responsive during CPU-intensive tasks.

In this lesson, you will learn what Web Workers are, how to create them, how to communicate between threads, and when to use them.

## What Are Web Workers?

**Web Workers** are JavaScript running in a separate thread from the main UI thread. They let you:

- Run CPU-intensive code without blocking the UI
- Keep the interface responsive during long operations
- Truly parallelize work across multiple threads

Think of workers as background helpers. They do heavy lifting while your main thread stays free to handle user interactions.

```javascript
// Main thread stays responsive
const worker = new Worker('worker.js')

worker.postMessage('Start heavy calculation')

worker.onmessage = (event) => {
  console.log('Result:', event.data)
}

// UI remains responsive while worker computes
```

## Single-Threaded vs Multi-Threaded

**Without Workers (Single Thread):**

```javascript
// This blocks the UI for 3 seconds
function heavyCalculation() {
  let result = 0
  for (let i = 0; i < 3000000000; i++) {
    result += i
  }
  return result
}

console.log('Start')
const result = heavyCalculation()  // UI freezes here!
console.log('Result:', result)
console.log('End')
```

The UI is frozen - buttons don't work, page doesn't scroll.

**With Workers (Multi-Threaded):**

```javascript
// Main thread
const worker = new Worker('calculator.js')

console.log('Start')
worker.postMessage('calculate')  // UI stays responsive

worker.onmessage = (event) => {
  console.log('Result:', event.data)
  console.log('End')
}
```

The UI remains responsive while the worker calculates in the background.

## Creating a Web Worker

### Step 1: Create Worker File

```javascript
// worker.js
onmessage = function(event) {
  console.log('Worker received:', event.data)

  // Do heavy work
  const result = doSomethingIntensive(event.data)

  // Send result back
  postMessage(result)
}

function doSomethingIntensive(data) {
  let sum = 0
  for (let i = 0; i < 1000000000; i++) {
    sum += i
  }
  return sum
}
```

### Step 2: Use Worker in Main Thread

```javascript
// main.js
const worker = new Worker('worker.js')

// Send message to worker
worker.postMessage({ type: 'start', value: 42 })

// Receive messages from worker
worker.onmessage = function(event) {
  console.log('Received from worker:', event.data)
}

// Handle errors
worker.onerror = function(error) {
  console.error('Worker error:', error.message)
}

// Terminate worker when done
worker.terminate()
```

::illustration-linear-flow
---
steps:
  - label: Main Thread
    sublabel: "Create worker"
    icon: üñ•Ô∏è
    color: violet
  - label: Send Message
    sublabel: "postMessage()"
    icon: üì§
    color: blue
  - label: Worker Thread
    sublabel: "Process data"
    icon: ‚öôÔ∏è
    color: amber
  - label: Send Result
    sublabel: "postMessage()"
    icon: üì•
    color: emerald
---
::

## Message Passing

Communication between threads uses **message passing** - data is copied, not shared.

### From Main Thread to Worker

```javascript
// Main thread
const worker = new Worker('worker.js')

worker.postMessage('Hello')
worker.postMessage({ type: 'calculate', numbers: [1, 2, 3] })
worker.postMessage([1, 2, 3, 4, 5])
```

### From Worker to Main Thread

```javascript
// worker.js
onmessage = function(event) {
  const data = event.data

  // Process data
  const result = processData(data)

  // Send back
  postMessage(result)
}
```

### Two-Way Communication

```javascript
// worker.js
onmessage = function(event) {
  const { command, data } = event.data

  switch (command) {
    case 'sum':
      const sum = data.reduce((a, b) => a + b, 0)
      postMessage({ type: 'result', value: sum })
      break

    case 'multiply':
      const product = data.reduce((a, b) => a * b, 1)
      postMessage({ type: 'result', value: product })
      break

    default:
      postMessage({ type: 'error', message: 'Unknown command' })
  }
}
```

```javascript
// Main thread
worker.postMessage({ command: 'sum', data: [1, 2, 3, 4, 5] })

worker.onmessage = (event) => {
  if (event.data.type === 'result') {
    console.log('Result:', event.data.value)
  } else if (event.data.type === 'error') {
    console.error('Error:', event.data.message)
  }
}
```

## What Workers Can and Cannot Do

### Workers CAN:

‚úÖ Run JavaScript code
‚úÖ Use standard objects (Array, Object, JSON, Math, etc.)
‚úÖ Make network requests (fetch, XMLHttpRequest)
‚úÖ Use timers (setTimeout, setInterval)
‚úÖ Spawn nested workers
‚úÖ Use WebSockets
‚úÖ Access navigator and location (read-only)

### Workers CANNOT:

‚ùå Access the DOM (no document, no window)
‚ùå Manipulate the UI directly
‚ùå Access parent page's variables
‚ùå Use localStorage or sessionStorage
‚ùå Access window-specific APIs

```javascript
// worker.js

// ‚úÖ This works
const data = JSON.parse('{"name": "Alice"}')
console.log('Worker:', data.name)

fetch('/api/data')
  .then(response => response.json())
  .then(data => postMessage(data))

// ‚ùå This doesn't work
document.getElementById('button')  // Error: document is not defined
localStorage.setItem('key', 'value')  // Error: localStorage is not defined
```

## Practical Examples

### Example 1: Prime Number Calculator

```javascript
// prime-worker.js
function isPrime(n) {
  if (n < 2) return false
  for (let i = 2; i <= Math.sqrt(n); i++) {
    if (n % i === 0) return false
  }
  return true
}

onmessage = function(event) {
  const limit = event.data
  const primes = []

  for (let i = 2; i <= limit; i++) {
    if (isPrime(i)) {
      primes.push(i)
    }

    // Send progress updates
    if (i % 10000 === 0) {
      postMessage({ type: 'progress', current: i, total: limit })
    }
  }

  postMessage({ type: 'complete', primes })
}
```

```javascript
// Main thread
const worker = new Worker('prime-worker.js')

worker.postMessage(100000)  // Find primes up to 100,000

worker.onmessage = (event) => {
  if (event.data.type === 'progress') {
    const percent = (event.data.current / event.data.total) * 100
    console.log(`Progress: ${percent.toFixed(2)}%`)
  } else if (event.data.type === 'complete') {
    console.log(`Found ${event.data.primes.length} primes`)
    worker.terminate()
  }
}
```

### Example 2: Image Processing

```javascript
// image-worker.js
onmessage = function(event) {
  const { imageData, filter } = event.data

  const pixels = imageData.data

  // Apply grayscale filter
  if (filter === 'grayscale') {
    for (let i = 0; i < pixels.length; i += 4) {
      const avg = (pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3
      pixels[i] = avg      // Red
      pixels[i + 1] = avg  // Green
      pixels[i + 2] = avg  // Blue
      // pixels[i + 3] is alpha (unchanged)
    }
  }

  postMessage({ imageData }, [imageData.data.buffer])
}
```

```javascript
// Main thread
const canvas = document.getElementById('canvas')
const ctx = canvas.getContext('2d')
const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)

const worker = new Worker('image-worker.js')

worker.postMessage({ imageData, filter: 'grayscale' })

worker.onmessage = (event) => {
  ctx.putImageData(event.data.imageData, 0, 0)
  worker.terminate()
}
```

### Example 3: Data Parsing

```javascript
// parser-worker.js
onmessage = function(event) {
  const { csv, delimiter = ',' } = event.data

  const lines = csv.split('\n')
  const headers = lines[0].split(delimiter)

  const data = []

  for (let i = 1; i < lines.length; i++) {
    const values = lines[i].split(delimiter)
    const row = {}

    headers.forEach((header, index) => {
      row[header.trim()] = values[index]?.trim() || ''
    })

    data.push(row)

    // Progress updates for large files
    if (i % 1000 === 0) {
      postMessage({
        type: 'progress',
        processed: i,
        total: lines.length
      })
    }
  }

  postMessage({ type: 'complete', data })
}
```

```javascript
// Main thread
async function parseCSV(csvString) {
  const worker = new Worker('parser-worker.js')

  worker.postMessage({ csv: csvString, delimiter: ',' })

  return new Promise((resolve, reject) => {
    worker.onmessage = (event) => {
      if (event.data.type === 'progress') {
        console.log(`Parsing: ${event.data.processed} / ${event.data.total}`)
      } else if (event.data.type === 'complete') {
        worker.terminate()
        resolve(event.data.data)
      }
    }

    worker.onerror = (error) => {
      worker.terminate()
      reject(error)
    }
  })
}
```

## Error Handling

```javascript
// worker.js
onmessage = function(event) {
  try {
    const result = riskyOperation(event.data)
    postMessage({ success: true, result })
  } catch (error) {
    postMessage({ success: false, error: error.message })
  }
}
```

```javascript
// Main thread
worker.onmessage = (event) => {
  if (event.data.success) {
    console.log('Result:', event.data.result)
  } else {
    console.error('Worker error:', event.data.error)
  }
}

worker.onerror = (error) => {
  console.error('Worker crashed:', error.message)
  console.error('File:', error.filename)
  console.error('Line:', error.lineno)
}
```

## Terminating Workers

```javascript
// Terminate from main thread
worker.terminate()

// Self-terminate from worker
// worker.js
onmessage = function(event) {
  if (event.data === 'shutdown') {
    close()  // Worker terminates itself
  }
}
```

## When to Use Web Workers

### Good Use Cases

‚úÖ **Heavy calculations** - Mathematical operations, cryptography
‚úÖ **Data processing** - Parsing large files, sorting huge datasets
‚úÖ **Image/video processing** - Filters, compression, analysis
‚úÖ **Background sync** - Periodically fetching and processing data
‚úÖ **Game AI** - Path-finding, physics simulations
‚úÖ **Text analysis** - Search indexing, spell checking

### Not Worth It

‚ùå **Simple operations** - Worker overhead isn't worth it
‚ùå **DOM manipulation** - Workers can't access DOM
‚ùå **Small datasets** - Copying data costs more than computation
‚ùå **Already async** - fetch() and Promises don't block the UI

## Performance Considerations

### Data Transfer Cost

Data is **copied**, not shared. Large data transfers have overhead:

```javascript
// Slow - copies 100MB of data
const hugeArray = new Array(100000000)
worker.postMessage(hugeArray)

// Faster - transfer ownership (Transferable Objects)
const buffer = new ArrayBuffer(100000000)
worker.postMessage(buffer, [buffer])
// Main thread can no longer use 'buffer'
```

### Worker Pool Pattern

Don't create too many workers - browsers have limits:

```javascript
class WorkerPool {
  constructor(workerScript, poolSize = 4) {
    this.workers = []
    this.taskQueue = []

    for (let i = 0; i < poolSize; i++) {
      const worker = new Worker(workerScript)
      worker.onmessage = (event) => this.handleResult(event, worker)
      this.workers.push({ worker, busy: false })
    }
  }

  runTask(data) {
    return new Promise((resolve) => {
      this.taskQueue.push({ data, resolve })
      this.assignTask()
    })
  }

  assignTask() {
    if (this.taskQueue.length === 0) return

    const freeWorker = this.workers.find(w => !w.busy)
    if (!freeWorker) return

    const task = this.taskQueue.shift()
    freeWorker.busy = true
    freeWorker.currentTask = task

    freeWorker.worker.postMessage(task.data)
  }

  handleResult(event, worker) {
    const workerObj = this.workers.find(w => w.worker === worker)
    workerObj.currentTask.resolve(event.data)
    workerObj.busy = false

    this.assignTask()  // Assign next task
  }
}

// Use it
const pool = new WorkerPool('worker.js', 4)

const results = await Promise.all([
  pool.runTask(data1),
  pool.runTask(data2),
  pool.runTask(data3),
  pool.runTask(data4),
  pool.runTask(data5)  // Waits for worker to be free
])
```

## Key Takeaways

- **Web Workers** run JavaScript in background threads without blocking the UI
- Workers **cannot access the DOM** or window object
- Communication uses **postMessage()** and **onmessage**
- Data is **copied** (structured clone), not shared
- Use workers for **CPU-intensive tasks** like calculations or data processing
- Workers can make **network requests** using fetch()
- Always **terminate workers** when done to free resources
- Don't overuse workers - overhead isn't worth it for simple tasks
- Workers are best for **synchronous** heavy operations, not async operations
- Modern browsers support workers, but always check compatibility for production

Web Workers unlock true parallelism in JavaScript. Use them wisely for CPU-intensive tasks, and your users will enjoy a responsive interface even during heavy processing. For most async operations, stick with Promises and async/await.
