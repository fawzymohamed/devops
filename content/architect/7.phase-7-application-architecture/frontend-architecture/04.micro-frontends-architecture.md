---
title: "Micro-Frontends Architecture"
description: "Learn how micro-frontends decompose monolithic UIs into independently deployable pieces owned by separate teams."
estimatedMinutes: 14
difficulty: intermediate
learningObjectives:
  - "Understand what micro-frontends are and the problems they solve"
  - "Identify the main integration patterns: build-time, runtime, and server-side"
  - "Explain the trade-offs of micro-frontends versus a monolithic frontend"
  - "Recognize when micro-frontends add value and when they add unnecessary complexity"
  - "Apply team ownership boundaries to frontend decomposition"
prerequisites:
  - "component-architecture-and-design-systems"
quiz:
  passingScore: 70
  questions:
    - question: "What is the primary organizational problem that micro-frontends solve?"
      type: single
      options:
        - "Multiple teams blocked by a shared monolithic frontend codebase"
        - "CSS files being too large"
        - "JavaScript running too slowly in the browser"
        - "Backend APIs returning too much data"
      correctAnswer: "Multiple teams blocked by a shared monolithic frontend codebase"
      explanation: "Micro-frontends let each team own, develop, and deploy their section of the UI independently. In a monolith, every team shares one codebase, leading to merge conflicts, coordinated releases, and bottlenecks."

    - question: "Select all valid micro-frontend integration patterns."
      type: multiple
      options:
        - "Build-time integration via npm packages"
        - "Runtime integration via Module Federation or iframes"
        - "Server-side composition via edge includes or reverse proxy"
        - "Database-level integration via shared tables"
      correctAnswers:
        - "Build-time integration via npm packages"
        - "Runtime integration via Module Federation or iframes"
        - "Server-side composition via edge includes or reverse proxy"
      explanation: "Micro-frontends integrate at the build level (npm packages), at runtime in the browser (Module Federation, iframes, web components), or on the server (edge-side includes, reverse proxy routing). Database-level integration is a backend concern, not a frontend composition pattern."

    - question: "Micro-frontends are a good default choice for small teams with a single product."
      type: true-false
      correctAnswer: false
      explanation: "Micro-frontends add significant complexity: shared routing, consistent styling, inter-app communication, and deployment orchestration. For small teams or single products, a well-structured monolith is simpler and faster. Micro-frontends pay off when multiple autonomous teams need independent deployment."

    - question: "What is the 'shared nothing' principle in micro-frontends?"
      type: single
      options:
        - "Each micro-frontend avoids sharing runtime state or dependencies with others"
        - "Teams do not share any design documents"
        - "No code is ever reused between micro-frontends"
        - "Each micro-frontend uses a different programming language"
      correctAnswer: "Each micro-frontend avoids sharing runtime state or dependencies with others"
      explanation: "Shared nothing means each micro-frontend bundles its own dependencies and manages its own state. This prevents version conflicts and coupling. Teams may still share design tokens or a component library, but runtime coupling is avoided."

    - question: "Which risk is most significant when adopting micro-frontends?"
      type: single
      options:
        - "Inconsistent user experience across independently developed sections"
        - "The application loads too quickly"
        - "Developers have too much autonomy"
        - "The backend becomes a monolith"
      correctAnswer: "Inconsistent user experience across independently developed sections"
      explanation: "When each team builds independently, visual and behavioral inconsistencies creep in -- different button styles, different loading patterns, different error messages. A shared design system with enforced tokens and components is essential to prevent this."
---

# Micro-Frontends Architecture

Microservices split the backend into independently deployable services. Micro-frontends apply the same idea to the frontend. Instead of one monolithic UI codebase that every team contributes to, each team owns and deploys its own slice of the user interface.

This pattern matters most when **organizational scaling** is the bottleneck. If five teams all merge code into one frontend repo, they block each other with merge conflicts, coordinated releases, and shared build pipelines. Micro-frontends remove that bottleneck.

## How It Works

Each team owns a vertical slice of the product -- from UI to API. The frontend is divided into independently built and deployed pieces that are composed into a single user-facing application.

```
┌─────────────────────────────────────────────┐
│              App Shell (Host)                │
├─────────────┬──────────────┬────────────────┤
│  Team A:    │  Team B:     │  Team C:       │
│  Product    │  Cart &      │  User Account  │
│  Catalog    │  Checkout    │  & Settings    │
├─────────────┼──────────────┼────────────────┤
│  Product    │  Cart API    │  User API      │
│  API        │              │                │
└─────────────┴──────────────┴────────────────┘
```

The **app shell** (or host) handles routing, navigation, and composition. Each team's micro-frontend plugs into the shell at designated mount points.

## Integration Patterns

### Build-Time Integration

Each micro-frontend is published as an npm package. The host application installs them as dependencies and bundles everything together at build time.

```json
{
  "dependencies": {
    "@team-a/product-catalog": "^2.1.0",
    "@team-b/cart": "^1.5.0",
    "@team-c/user-account": "^3.0.0"
  }
}
```

**Pros:** Simple, one deployment artifact, good performance.
**Cons:** Teams cannot deploy independently. Changing one package requires rebuilding the host.

### Runtime Integration

Micro-frontends load at runtime in the browser. The host fetches remote bundles on demand.

| Method | How It Works | Trade-off |
|--------|-------------|-----------|
| **Module Federation** | Webpack/Vite shares modules at runtime | Fast, flexible, framework-aware |
| **Iframes** | Each micro-frontend in its own iframe | Strong isolation, poor UX (styling, routing) |
| **Web Components** | Custom elements wrapping each app | Framework-agnostic, standard API |

Module Federation is the most popular runtime approach. The host declares remote entry points, and each micro-frontend exposes components that the host loads on demand.

### Server-Side Composition

The server assembles HTML fragments from multiple micro-frontends before sending the response.

- **Edge-Side Includes (ESI)** -- CDN assembles HTML fragments from different origins
- **Reverse proxy** -- Routes like `/products/*` go to Team A's server, `/cart/*` to Team B's

This works well for SSR-heavy applications where each team renders its own HTML.

## The Shared Nothing Principle

Each micro-frontend should avoid sharing runtime state or dependencies with others. This means:

- **Bundle your own dependencies** -- Do not assume the host provides React or Vue
- **Own your own state** -- Do not read from another team's global store
- **Communicate through events** -- Use custom events or a lightweight message bus, not direct imports

Shared design tokens and a component library are the exception. Visual consistency requires some sharing, but it should be at the design system level, not runtime coupling.

## When to Use Micro-Frontends

**Good fit:**
- Multiple autonomous teams (3+) working on one product
- Teams need independent deployment cycles
- Different sections have different technology needs
- The monolith is slowing down team velocity

**Bad fit:**
- Small team (1-2 developers)
- Single product with tightly coupled features
- All features share heavy state (e.g., a collaborative editor)
- The team is not yet experienced with distributed systems

## Risks and Mitigations

| Risk | Mitigation |
|------|-----------|
| Inconsistent UX | Shared design system with enforced tokens |
| Duplicate dependencies (3 copies of React) | Module Federation's shared scope or import maps |
| Routing conflicts | Central app shell owns the router |
| Performance overhead from multiple bundles | Lazy-load micro-frontends per route |
| Cross-app communication complexity | Lightweight event bus with typed contracts |

## Best Practices

- **Split by business domain, not by UI layer** -- Team A owns the entire product catalog (UI + API), not "all buttons"
- **Keep the app shell thin** -- It handles routing and composition. No business logic.
- **Enforce a design system** -- Shared tokens and components prevent visual drift
- **Use feature flags** -- Deploy micro-frontends independently and toggle them on gradually
- **Monitor bundle sizes** -- Track the total payload. Multiple micro-frontends can bloat the page if unchecked.

## Key Takeaways

- Micro-frontends let independent teams own, build, and deploy their UI sections separately
- Integration can happen at build time (npm packages), runtime (Module Federation), or server side (ESI/proxy)
- The shared nothing principle keeps micro-frontends decoupled at runtime
- A shared design system is essential to prevent visual inconsistency
- Micro-frontends add complexity -- use them only when organizational scaling justifies the cost
- Split by business domain, not by UI layer
