---
title: "State Management Patterns (Local, Global, Server State)"
description: "Learn the three categories of frontend state and the patterns for managing each effectively without over-engineering."
estimatedMinutes: 14
difficulty: intermediate
learningObjectives:
  - "Distinguish between local, global, and server state in frontend applications"
  - "Identify when each state category is the right choice for a given use case"
  - "Explain the Flux/Redux pattern and its trade-offs"
  - "Understand how server state libraries eliminate manual cache management"
  - "Apply state colocation to keep state close to where it is used"
prerequisites:
  - "component-architecture-and-design-systems"
quiz:
  passingScore: 70
  questions:
    - question: "Which type of state represents data fetched from an API that lives on a remote server?"
      type: single
      options:
        - "Server state"
        - "Local state"
        - "Global state"
        - "Session state"
      correctAnswer: "Server state"
      explanation: "Server state is data that originates from a remote source like a REST API or database. It needs fetching, caching, and revalidation because the true source of truth is the server, not the client."

    - question: "Select all valid examples of local component state."
      type: multiple
      options:
        - "Whether a dropdown menu is open or closed"
        - "The currently authenticated user"
        - "The current value of a text input"
        - "Whether a tooltip is visible"
      correctAnswers:
        - "Whether a dropdown menu is open or closed"
        - "The current value of a text input"
        - "Whether a tooltip is visible"
      explanation: "Local state belongs to a single component and is not needed elsewhere. Open/closed toggles, input values, and tooltip visibility are all UI-specific state. The authenticated user is needed across many components, making it global state."

    - question: "What problem does the Flux/Redux pattern solve?"
      type: single
      options:
        - "Unpredictable state changes from multiple sources by enforcing one-way data flow"
        - "Slow rendering by caching all component output"
        - "Network errors by retrying failed API calls"
        - "CSS conflicts between components"
      correctAnswer: "Unpredictable state changes from multiple sources by enforcing one-way data flow"
      explanation: "Flux/Redux enforces a strict one-way flow: actions describe what happened, reducers compute the new state, and the store holds the single source of truth. This makes state changes predictable and easy to debug because you can trace every change to a specific action."

    - question: "State colocation means putting all state in a single global store."
      type: true-false
      correctAnswer: false
      explanation: "State colocation is the opposite. It means keeping state as close as possible to the component that uses it. Only lift state up when multiple components need it. This reduces complexity and avoids unnecessary re-renders."

    - question: "What is stale-while-revalidate in the context of server state?"
      type: single
      options:
        - "Show cached data immediately while fetching fresh data in the background"
        - "Delete stale data and show a loading spinner"
        - "Prevent any API calls until the cache expires"
        - "Store server responses in localStorage permanently"
      correctAnswer: "Show cached data immediately while fetching fresh data in the background"
      explanation: "Stale-while-revalidate returns cached data to the user instantly for a fast experience, then silently fetches updated data in the background. When the fresh data arrives, the UI updates. This pattern gives both speed and freshness."
---

# State Management Patterns (Local, Global, Server State)

Every interactive frontend has state -- data that changes over time and drives what the user sees. A toggle is open or closed. A user is logged in or out. A list of products came from an API. Managing this state well is the difference between a predictable app and a tangled mess.

The key insight is that **not all state is equal**. Treating everything the same -- dumping it all into a global store -- creates unnecessary complexity. Modern frontend architecture splits state into three categories, each with its own management strategy.

## The Three Categories

| Category | Source | Examples | Lifetime |
|----------|--------|----------|----------|
| **Local** | Component itself | Toggle open/closed, input value, hover state | Component mount/unmount |
| **Global** | Shared across app | Current user, theme, locale, permissions | App session |
| **Server** | Remote API/database | Product list, user profile, order history | Cache with revalidation |

## Local State

Local state belongs to a single component. No other part of the app needs it. Keep it inside the component.

```javascript
// React example
function Dropdown() {
  const [isOpen, setIsOpen] = useState(false);
  return (
    <button onClick={() => setIsOpen(!isOpen)}>
      {isOpen ? 'Close' : 'Open'}
    </button>
  );
}
```

**When to use:** Form inputs, toggles, tooltips, animation state, modal open/closed. If only one component reads and writes the value, keep it local.

### State Colocation

Start with local state. Only lift it to a parent (or global store) when a sibling or distant component actually needs it. This is called **state colocation** -- keeping state close to where it is used. It reduces re-renders and makes components easier to understand.

## Global State

Global state is needed by many components across different pages or sections. Think of the logged-in user, the selected theme, or the user's locale.

### The Flux/Redux Pattern

The most common pattern for global state follows a strict one-way data flow:

::illustration-linear-flow
---
steps:
  - label: Action
    sublabel: Describes what happened
    icon: "\U0001F4E8"
    color: violet
  - label: Reducer
    sublabel: Computes new state
    icon: "\U00002699"
    color: blue
  - label: Store
    sublabel: Holds state tree
    icon: "\U0001F4E6"
    color: emerald
  - label: View
    sublabel: Renders from state
    icon: "\U0001F4BB"
    color: amber
showFeedbackLoop: true
feedbackLabel: User interaction dispatches action
---
::

1. **Action** -- A plain object describing what happened (`{ type: 'LOGIN', user }`)
2. **Reducer** -- A pure function that takes current state + action and returns new state
3. **Store** -- The single source of truth for all global state
4. **View** -- Components read from the store and re-render when state changes

This pattern makes state changes **predictable**. Every change is triggered by an action. You can log every action, replay them for debugging, or undo them.

### Lighter Alternatives

Not every app needs Redux. Simpler tools work for smaller global state:

| Tool | Pattern | Best For |
|------|---------|----------|
| React Context | Provider/Consumer | Theme, locale, auth (low-frequency updates) |
| Zustand | Single store, hooks | Medium apps, simple API |
| Pinia (Vue) | Store with actions | Vue apps, devtools integration |
| Signals | Reactive primitives | Fine-grained reactivity |

## Server State

Server state is data fetched from a remote API. It is fundamentally different from local/global state because:

- The **source of truth is the server**, not the client
- It can become **stale** while the user is on the page
- It needs **caching**, **deduplication**, and **revalidation**
- It has loading, error, and success states

### Stale-While-Revalidate

The most important server state pattern. When a component requests data:

1. Return **cached data instantly** (stale but fast)
2. **Fetch fresh data** in the background
3. **Update the UI** when fresh data arrives

This gives users a fast experience while keeping data fresh. Libraries like TanStack Query, SWR, and Apollo Client implement this pattern automatically.

### What These Libraries Handle

```javascript
// TanStack Query example
const { data, isLoading, error } = useQuery({
  queryKey: ['products'],
  queryFn: () => fetch('/api/products').then(r => r.json()),
  staleTime: 30_000, // Data is fresh for 30 seconds
});
```

The library handles caching, background refetching, request deduplication (multiple components requesting the same data trigger one fetch), and garbage collection of unused cache entries.

## Choosing the Right Category

| Question | Answer |
|----------|--------|
| Does only one component use it? | **Local state** |
| Do many unrelated components need it? | **Global state** |
| Does it come from an API? | **Server state** |
| Is it UI-only (toggle, hover)? | **Local state** |
| Is it user session data (auth, theme)? | **Global state** |

## Best Practices

- **Start local, lift when needed** -- Do not default to global. Let the need drive the decision.
- **Separate server state from UI state** -- Use a server state library for API data. Do not mix API responses into a Redux store.
- **Keep global state minimal** -- Only put truly shared data in the global store. Theme, auth, locale -- that is usually it.
- **Avoid derived state** -- If you can compute a value from existing state, compute it. Do not store both `items` and `itemCount`.

## Key Takeaways

- Frontend state splits into three categories: local, global, and server
- Local state stays inside the component that owns it (colocation principle)
- Global state uses one-way data flow patterns like Flux/Redux for predictability
- Server state needs caching, revalidation, and deduplication -- use a dedicated library
- Start with local state and lift only when another component actually needs it
