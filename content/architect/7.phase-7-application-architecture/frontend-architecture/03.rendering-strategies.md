---
title: "Rendering Strategies (SSR, SSG, CSR, ISR, Streaming)"
description: "Understand the five frontend rendering strategies and how to choose the right one for each page based on content type and performance needs."
estimatedMinutes: 15
difficulty: intermediate
learningObjectives:
  - "Explain how CSR, SSR, SSG, ISR, and streaming rendering each work"
  - "Identify the trade-offs of each strategy for performance, SEO, and scalability"
  - "Choose the right rendering strategy based on content freshness and user expectations"
  - "Understand how modern frameworks mix strategies within a single application"
  - "Recognize the role of hydration in transitioning server-rendered HTML to interactive apps"
prerequisites:
  - "component-architecture-and-design-systems"
quiz:
  passingScore: 70
  questions:
    - question: "What is the main drawback of client-side rendering (CSR) for content-heavy pages?"
      type: single
      options:
        - "The user sees a blank page until JavaScript downloads and executes"
        - "CSR pages cannot use CSS"
        - "CSR requires a database on the client"
        - "CSR only works in Chrome"
      correctAnswer: "The user sees a blank page until JavaScript downloads and executes"
      explanation: "With CSR, the server sends an empty HTML shell. The browser must download, parse, and execute JavaScript before rendering any content. This creates a blank screen (or loading spinner) that hurts perceived performance and SEO."

    - question: "Select all benefits of Static Site Generation (SSG)."
      type: multiple
      options:
        - "Pre-built HTML files serve instantly from a CDN"
        - "Content updates appear in real-time without rebuilds"
        - "No server is needed at request time"
        - "Excellent SEO because crawlers receive full HTML"
      correctAnswers:
        - "Pre-built HTML files serve instantly from a CDN"
        - "No server is needed at request time"
        - "Excellent SEO because crawlers receive full HTML"
      explanation: "SSG generates HTML at build time. Pages serve instantly from a CDN with no server-side processing. Search engines see full HTML. The trade-off is that content updates require a rebuild, so real-time updates are not possible with pure SSG."

    - question: "ISR (Incremental Static Regeneration) rebuilds all pages on every request."
      type: true-false
      correctAnswer: false
      explanation: "ISR does not rebuild all pages on every request. It serves cached static pages and regenerates only individual pages in the background after a configured time interval. This gives the speed of SSG with the freshness of SSR, without full rebuilds."

    - question: "What does hydration do in the context of SSR?"
      type: single
      options:
        - "Attaches JavaScript event handlers to server-rendered HTML to make it interactive"
        - "Compresses HTML files for faster download"
        - "Converts CSS to inline styles"
        - "Removes unused JavaScript from the bundle"
      correctAnswer: "Attaches JavaScript event handlers to server-rendered HTML to make it interactive"
      explanation: "Hydration is the process where the browser receives server-rendered HTML (which is already visible), then downloads JavaScript that attaches event listeners and state to the existing DOM. This makes the static HTML fully interactive."

    - question: "Which rendering strategy would you choose for a blog with posts that change once a day?"
      type: single
      options:
        - "SSG or ISR"
        - "CSR only"
        - "SSR for every request"
        - "Streaming SSR"
      correctAnswer: "SSG or ISR"
      explanation: "Blog content changes infrequently, so pre-building pages at deploy time (SSG) or regenerating them periodically (ISR) gives the best performance. SSR on every request wastes server resources for content that rarely changes. CSR hurts SEO for content pages."
---

# Rendering Strategies (SSR, SSG, CSR, ISR, Streaming)

Where and when HTML is generated determines how fast a page loads, how well it ranks in search engines, and how much server infrastructure you need. Modern frameworks support multiple rendering strategies, and architects must choose the right one for each type of page.

## The Five Strategies

### Client-Side Rendering (CSR)

The server sends a minimal HTML shell with a JavaScript bundle. The browser downloads the JS, executes it, and renders the page entirely on the client.

```html
<!-- What the server sends -->
<div id="app"></div>
<script src="/bundle.js"></script>
```

| Pros | Cons |
|------|------|
| Simple deployment (static files) | Blank screen until JS loads |
| Rich interactivity after load | Poor SEO (crawlers see empty HTML) |
| Reduced server load | Slow on weak devices or slow networks |

**Best for:** Dashboards, admin panels, authenticated apps where SEO does not matter.

### Server-Side Rendering (SSR)

The server runs your application code on **every request**, generates full HTML, and sends it to the browser. The page is visible immediately. JavaScript then **hydrates** the page to make it interactive.

```
Browser request → Server runs app → Full HTML response → Browser hydrates
```

| Pros | Cons |
|------|------|
| Fast first paint (HTML arrives ready) | Server processes every request |
| Full SEO (crawlers see complete content) | Higher infrastructure cost |
| Dynamic content per request | Time to Interactive delayed by hydration |

**Best for:** E-commerce product pages, social feeds, pages with personalized content.

### Static Site Generation (SSG)

HTML is generated **at build time**, not at request time. The output is a set of static HTML files that a CDN serves directly.

```
Build step → HTML files → CDN → Browser (instant)
```

| Pros | Cons |
|------|------|
| Fastest possible load (pre-built files on CDN) | Content changes need a rebuild |
| No server at runtime | Build time grows with page count |
| Excellent SEO | Not suitable for real-time content |

**Best for:** Documentation, blogs, marketing pages, landing pages.

### Incremental Static Regeneration (ISR)

ISR combines SSG speed with SSR freshness. Pages are pre-built at deploy time, but individual pages **regenerate in the background** after a set time interval.

```
First visit → Cached static page (fast)
After revalidation time → Background rebuild → Updated page for next visitor
```

| Pros | Cons |
|------|------|
| CDN speed for most requests | Brief window of stale content |
| No full rebuilds for content updates | Not all frameworks support it |
| Scales to millions of pages | Adds caching complexity |

**Best for:** Product catalogs, news sites, any content that updates periodically but not in real-time.

### Streaming SSR

Traditional SSR waits until the **entire** page is rendered before sending anything. Streaming SSR sends HTML in **chunks** as each section becomes ready. The browser starts painting immediately while the server is still rendering slower sections.

```
Browser request → Server starts rendering
  → Header HTML chunk sent (browser paints header)
  → Main content chunk sent (browser paints content)
  → Sidebar chunk sent (browser paints sidebar)
```

| Pros | Cons |
|------|------|
| Fastest Time to First Byte | More complex server setup |
| User sees content progressively | Harder to debug rendering order |
| Slow data fetches don't block fast sections | Not all hosting supports streaming |

**Best for:** Pages with sections that have different data-fetching speeds (e.g., fast header, slow recommendations).

## Hydration

SSR and SSG send complete HTML, but that HTML is static -- buttons do not respond to clicks. **Hydration** is the process where the browser downloads JavaScript and attaches event handlers to the existing HTML, making it interactive.

Hydration has a cost. The browser must download, parse, and execute the JavaScript bundle before the page becomes fully interactive. This gap between "visible" and "interactive" is called the **uncanny valley** -- the page looks ready but does not respond to clicks.

### Reducing Hydration Cost

- **Partial hydration** -- Only hydrate interactive components, leave static HTML alone
- **Islands architecture** -- Mark specific components as interactive "islands" in a sea of static HTML
- **Progressive hydration** -- Hydrate above-the-fold components first, defer the rest

## Choosing the Right Strategy

| Content Type | Freshness Need | Best Strategy |
|-------------|----------------|---------------|
| Blog post, docs | Rarely changes | SSG |
| Product catalog | Updates daily | ISR |
| User dashboard | Personalized, real-time | CSR or SSR |
| E-commerce product page | SEO + dynamic pricing | SSR or ISR |
| Marketing landing page | Fixed content | SSG |
| Social feed | Real-time, personalized | SSR + Streaming |

Modern frameworks like Next.js, Nuxt, and Astro let you **mix strategies within one app**. Your marketing pages use SSG, product pages use ISR, and the dashboard uses CSR -- all in the same codebase.

## Best Practices

- **Default to SSG** for any page that does not need per-request data
- **Use ISR** when content changes periodically but full rebuilds are too slow
- **Reserve SSR** for pages that need personalization or real-time data
- **Use CSR** only for authenticated, interactive sections behind a login
- **Combine strategies** per route -- do not force one strategy on the entire app

## Key Takeaways

- CSR renders in the browser (fast interactivity, poor SEO)
- SSR renders on the server per request (good SEO, higher server cost)
- SSG renders at build time (fastest load, requires rebuilds for updates)
- ISR regenerates individual static pages in the background on a timer
- Streaming SSR sends HTML in chunks so users see content progressively
- Hydration bridges the gap between static HTML and interactive JavaScript
- Modern apps mix strategies per route based on content type and freshness needs
