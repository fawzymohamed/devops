---
title: "Component Architecture & Design Systems"
description: "Learn how component architecture and design systems create consistent, scalable UIs through composition, encapsulation, and shared design tokens."
estimatedMinutes: 14
difficulty: intermediate
learningObjectives:
  - "Understand atomic design and how components compose into larger UI structures"
  - "Identify the principles of component encapsulation and single responsibility"
  - "Explain how design systems enforce visual and behavioral consistency"
  - "Apply design tokens to decouple style values from component implementations"
  - "Recognize the architect's role in establishing component boundaries"
prerequisites:
  - "backend-architecture"
quiz:
  passingScore: 70
  questions:
    - question: "What is the main purpose of atomic design in component architecture?"
      type: single
      options:
        - "To break UI into reusable layers from atoms to pages"
        - "To reduce the number of CSS files in a project"
        - "To eliminate the need for a design team"
        - "To ensure all components use the same color"
      correctAnswer: "To break UI into reusable layers from atoms to pages"
      explanation: "Atomic design organizes components into five layers -- atoms, molecules, organisms, templates, and pages. Each layer builds on the one below, creating reusable UI pieces that compose into complete interfaces."

    - question: "Select all characteristics of a well-designed component."
      type: multiple
      options:
        - "It has a single, clear responsibility"
        - "It exposes a minimal props interface"
        - "It manages global application state internally"
        - "It can be tested in isolation"
      correctAnswers:
        - "It has a single, clear responsibility"
        - "It exposes a minimal props interface"
        - "It can be tested in isolation"
      explanation: "Good components follow single responsibility, expose only what consumers need through props, and can be tested without the rest of the application. Managing global state internally creates tight coupling and makes the component hard to reuse."

    - question: "What are design tokens?"
      type: single
      options:
        - "Named constants for colors, spacing, typography, and other style values"
        - "Authentication tokens used by the design team"
        - "JavaScript variables that store component state"
        - "API keys for accessing a design tool"
      correctAnswer: "Named constants for colors, spacing, typography, and other style values"
      explanation: "Design tokens are platform-agnostic style values like color-primary: #3b82f6 or spacing-md: 16px. They create a single source of truth for visual decisions, making it easy to update the entire UI by changing one token."

    - question: "A design system is only a component library with no documentation or guidelines."
      type: true-false
      correctAnswer: false
      explanation: "A design system includes the component library, design tokens, usage guidelines, accessibility standards, and documentation. The library is just one piece. Without guidelines and tokens, teams interpret designs differently, which defeats the purpose of consistency."

    - question: "Why should an architect define component boundaries early in a project?"
      type: single
      options:
        - "To enable parallel development by multiple teams with clear ownership"
        - "To prevent designers from changing colors"
        - "To avoid writing any CSS"
        - "To ensure the backend API is designed first"
      correctAnswer: "To enable parallel development by multiple teams with clear ownership"
      explanation: "Clear component boundaries let teams work in parallel without stepping on each other. Each team owns a set of components with defined interfaces. This reduces merge conflicts and makes the codebase easier to scale."
---

# Component Architecture & Design Systems

Building a frontend with hundreds of screens and thousands of UI elements requires structure. Without it, teams create duplicate buttons with different styles, inconsistent spacing, and components that are impossible to reuse. Component architecture and design systems solve this by giving teams shared building blocks and clear rules for composing them.

## Atomic Design

Brad Frost's atomic design model organizes UI components into five layers:

::illustration-pyramid
---
layers:
  - label: Pages
    description: Complete screens with real content
    icon: "\U0001F4C4"
    color: rose
  - label: Templates
    description: Page layouts with placeholder content
    icon: "\U0001F4D0"
    color: amber
  - label: Organisms
    description: Complex sections (header, card list, form)
    icon: "\U0001F9E9"
    color: blue
  - label: Molecules
    description: Small groups (search bar = input + button)
    icon: "\U0001F52C"
    color: cyan
  - label: Atoms
    description: Basic elements (button, input, label, icon)
    icon: "\U0000269B"
    color: emerald
footnote: Each layer builds on the one below
size: xl
---
::

**Atoms** are the smallest units -- a button, an input, a label. **Molecules** combine atoms into small functional groups like a search bar. **Organisms** are complex sections like a navigation header or a product card grid. **Templates** define page layouts. **Pages** are templates filled with real content.

This layering helps architects decide what to build as a shared component versus what belongs in a specific feature.

## Component Design Principles

### Single Responsibility

Each component does one thing well. A `DatePicker` picks dates. It does not validate forms or fetch data. When a component grows beyond its original purpose, split it.

### Encapsulation

Components hide their internal details. Consumers interact through **props** (inputs) and **events** (outputs). Internal state, DOM structure, and styling stay private.

```vue
<!-- Good: clean interface, internals are hidden -->
<DatePicker
  :value="selectedDate"
  :min-date="today"
  @change="handleDateChange"
/>
```

### Composition Over Inheritance

Build complex UIs by **composing** small components, not by extending base classes. A `Card` component wraps a header slot, content slot, and footer slot. Different pages fill those slots differently without modifying the Card itself.

## Design Systems

A design system is more than a component library. It includes:

| Layer | What It Contains | Example |
|-------|-----------------|---------|
| **Design Tokens** | Color, spacing, typography values | `color-primary: #3b82f6` |
| **Component Library** | Reusable coded components | Button, Input, Modal, Card |
| **Usage Guidelines** | When and how to use each component | "Use primary button for one main action per page" |
| **Accessibility Standards** | WCAG compliance rules | Minimum contrast ratios, keyboard navigation |
| **Documentation** | Live examples, prop references | Storybook or similar tool |

### Design Tokens

Tokens are named constants that store style decisions. They decouple **what** a value means from **what** it is.

```json
{
  "color-primary": "#3b82f6",
  "color-error": "#ef4444",
  "spacing-sm": "8px",
  "spacing-md": "16px",
  "font-size-body": "16px",
  "border-radius-default": "8px"
}
```

When you need to rebrand or support dark mode, you change tokens in one place. Every component that references those tokens updates automatically.

## The Architect's Role

As an architect, you do not build every component. You define the **boundaries and contracts**:

- **Decide the component taxonomy** -- Which layers exist and who owns them
- **Define the token system** -- Establish naming conventions and categories
- **Set composition rules** -- How components nest and communicate
- **Choose tooling** -- Storybook for documentation, linting rules for enforcement
- **Review for reuse** -- Spot duplicates and refactor into shared components

## Key Takeaways

- Atomic design structures UI into five layers from atoms to pages
- Components should have a single responsibility, encapsulate internals, and compose through slots or children
- Design systems include tokens, components, guidelines, and documentation -- not just a library
- Design tokens create one source of truth for all style values
- Architects define component boundaries to enable parallel team development
