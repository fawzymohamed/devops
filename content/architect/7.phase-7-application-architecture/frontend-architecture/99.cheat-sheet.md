---
title: "Frontend Architecture - Quick Reference"
description: "Key concepts, patterns, and decision guides for frontend architecture including components, state, rendering, and performance."
estimatedMinutes: 5
difficulty: intermediate
learningObjectives:
  - "Quick reference for frontend architecture concepts"
isCheatSheet: true
cheatSheetTopic: "Frontend Architecture"
---

# Frontend Architecture - Quick Reference

## Component Architecture

| Principle | Rule |
|-----------|------|
| **Single Responsibility** | One component, one job |
| **Encapsulation** | Hide internals, expose props/events |
| **Composition** | Build complex UIs from simple pieces |

### Atomic Design Layers

| Layer | Example | Reusability |
|-------|---------|-------------|
| **Atom** | Button, Input, Icon | Highest |
| **Molecule** | Search bar (input + button) | High |
| **Organism** | Navigation header, Product card grid | Medium |
| **Template** | Page layout with slots | Low |
| **Page** | Template filled with real content | Lowest |

### Design System Components

| Layer | Contains |
|-------|----------|
| Design Tokens | Colors, spacing, typography, border-radius |
| Component Library | Coded, reusable UI components |
| Usage Guidelines | When and how to use each component |
| Accessibility | WCAG compliance, keyboard navigation |
| Documentation | Live examples, prop references |

---

## State Management

| Category | Source | Example | Pattern |
|----------|--------|---------|---------|
| **Local** | Component | Toggle, input value, hover | `useState` / `ref()` |
| **Global** | Shared app-wide | Auth, theme, locale | Redux, Zustand, Pinia |
| **Server** | Remote API | Products, user profile | TanStack Query, SWR |

### Decision Guide

| Question | Use |
|----------|-----|
| Only one component reads it? | Local state |
| Many unrelated components need it? | Global state |
| Comes from an API? | Server state library |
| Can you compute it from other state? | Derived (don't store it) |

### Flux/Redux Flow

> Action --> Reducer --> Store --> View --> (user interaction) --> Action

**Key rule:** Start local, lift only when needed.

---

## Rendering Strategies

| Strategy | When HTML is Built | Server Needed | SEO | Best For |
|----------|-------------------|---------------|-----|----------|
| **CSR** | In browser | No | Poor | Dashboards, admin panels |
| **SSR** | Per request on server | Yes | Good | Personalized pages, e-commerce |
| **SSG** | At build time | No | Excellent | Blogs, docs, marketing |
| **ISR** | Build + background regen | Yes (light) | Excellent | Catalogs, news sites |
| **Streaming** | Per request, in chunks | Yes | Good | Pages with mixed data speeds |

### Hydration

> Server HTML (visible) + Client JS (interactive) = Hydration

**Reducing cost:** Partial hydration, islands architecture, progressive hydration.

---

## Micro-Frontends

### Integration Patterns

| Pattern | Deploy Independently | Complexity | Performance |
|---------|---------------------|------------|-------------|
| **Build-time** (npm) | No | Low | Best |
| **Runtime** (Module Federation) | Yes | Medium | Good |
| **Iframes** | Yes | Low | Poor UX |
| **Server-side** (ESI/proxy) | Yes | Medium | Good |

### When to Use

> Use when 3+ teams share one frontend and independent deployment is a priority. Avoid for small teams or tightly coupled features.

**Key principle:** Shared nothing at runtime. Share design tokens, not state.

---

## Performance Patterns

### Code Splitting

| Type | What It Splits | Impact |
|------|---------------|--------|
| **Route-based** | One chunk per route | Biggest win, least effort |
| **Component-based** | Heavy components (charts, editors) | Targeted improvement |

### Bundle Optimization Pipeline

> Source --> Tree Shaking (remove unused) --> Minification (shrink) --> Compression (gzip/Brotli)

| Technique | Typical Savings |
|-----------|----------------|
| Tree shaking | Removes unused exports |
| Minification | 50-70% size reduction |
| Gzip | 60-70% of minified |
| Brotli | 70-80% of minified |

### Quick Checklist

- [ ] Route-based code splitting enabled
- [ ] Heavy components lazy-loaded
- [ ] Images use `loading="lazy"` below the fold
- [ ] Dependencies audited for size (bundlephobia.com)
- [ ] Performance budget set and enforced in CI

---

## Core Web Vitals

| Metric | Measures | Good | Poor |
|--------|----------|------|------|
| **LCP** | Loading (largest visible element) | ≤ 2.5s | > 4.0s |
| **INP** | Responsiveness (all interactions) | ≤ 200ms | > 500ms |
| **CLS** | Visual stability (layout shifts) | ≤ 0.1 | > 0.25 |

> Measured at the 75th percentile of real user visits. INP replaced FID in March 2024.

### Fix Guide

| Metric | Top Causes | Top Fixes |
|--------|-----------|-----------|
| **LCP** | Slow server, render-blocking resources, large images | Preload LCP image, use CDN/SSG, inline critical CSS |
| **INP** | Long JS tasks, heavy re-renders, third-party scripts | Break tasks, defer work, reduce DOM, virtualize lists |
| **CLS** | Images without dimensions, late-loading ads, font swaps | Set width/height, reserve ad space, use `font-display` |

### Measurement Tools

| Tool | Type | Use For |
|------|------|---------|
| CrUX | Field | Real user metrics (source of truth) |
| PageSpeed Insights | Field + Lab | Quick check with recommendations |
| Lighthouse | Lab | Debugging in controlled conditions |
| DevTools Performance | Lab | Frame-by-frame rendering analysis |

---

## Interview Quick Hits

| Question | Answer |
|----------|--------|
| What is a design system? | A collection of design tokens, reusable components, usage guidelines, and accessibility standards that enforce UI consistency across teams. |
| When would you use SSR vs SSG? | SSR for personalized or real-time content (e-commerce, social feeds). SSG for static content that rarely changes (docs, blogs, marketing). |
| What are the three Core Web Vitals? | LCP (loading speed), INP (input responsiveness), CLS (visual stability). Measured at the 75th percentile of real users. |
| How does code splitting improve performance? | It breaks one large JS bundle into smaller chunks loaded on demand, so users download only the code needed for the current page. |
| What is the difference between local and server state? | Local state lives in the component (toggles, inputs). Server state originates from a remote API and needs caching, revalidation, and error handling. |
| When should you use micro-frontends? | When 3+ autonomous teams need independent deployment of their UI sections. Avoid for small teams -- the coordination overhead is not worth it. |
| What replaced FID in Core Web Vitals? | INP (Interaction to Next Paint) replaced FID in March 2024. INP measures all interactions during a visit, not just the first one. |
| What is tree shaking? | A bundler optimization that removes unused code (dead exports) from the final bundle by analyzing static import/export statements. |
