---
title: "Performance Patterns (Code Splitting, Lazy Loading, Bundle Optimization)"
description: "Learn essential frontend performance patterns that reduce load times by delivering only the code users need, when they need it."
estimatedMinutes: 14
difficulty: intermediate
learningObjectives:
  - "Understand how code splitting breaks a monolithic bundle into smaller chunks"
  - "Apply lazy loading to defer non-critical resources until they are needed"
  - "Identify bundle optimization techniques like tree shaking and minification"
  - "Explain how route-based and component-based splitting strategies differ"
  - "Recognize the performance impact of third-party dependencies"
prerequisites:
  - "rendering-strategies"
quiz:
  passingScore: 70
  questions:
    - question: "What is the primary goal of code splitting?"
      type: single
      options:
        - "Send only the JavaScript needed for the current page instead of the entire application"
        - "Split CSS from JavaScript into different folders"
        - "Divide the codebase across multiple Git repositories"
        - "Separate frontend code from backend code"
      correctAnswer: "Send only the JavaScript needed for the current page instead of the entire application"
      explanation: "Code splitting breaks one large bundle into smaller chunks. The browser downloads only the chunk needed for the current route or feature. Other chunks load on demand when the user navigates. This reduces initial load time."

    - question: "Select all techniques that reduce JavaScript bundle size."
      type: multiple
      options:
        - "Tree shaking removes unused exports from the bundle"
        - "Minification shortens variable names and removes whitespace"
        - "Adding polyfills for every browser version"
        - "Compression (gzip/Brotli) reduces transfer size"
      correctAnswers:
        - "Tree shaking removes unused exports from the bundle"
        - "Minification shortens variable names and removes whitespace"
        - "Compression (gzip/Brotli) reduces transfer size"
      explanation: "Tree shaking, minification, and compression all reduce what the browser must download. Adding polyfills for every browser increases bundle size. Modern approaches use differential serving to send polyfills only to browsers that need them."

    - question: "Lazy loading a component means it is downloaded when the application first loads."
      type: true-false
      correctAnswer: false
      explanation: "Lazy loading is the opposite. A lazy-loaded component is NOT included in the initial bundle. It downloads only when the user triggers it -- for example, by navigating to a route or opening a modal. This keeps the initial load fast."

    - question: "What does tree shaking do?"
      type: single
      options:
        - "Removes unused code (dead exports) from the final bundle"
        - "Organizes files into a tree-shaped folder structure"
        - "Caches JavaScript files in a tree data structure"
        - "Splits the DOM tree across multiple iframes"
      correctAnswer: "Removes unused code (dead exports) from the final bundle"
      explanation: "Tree shaking analyzes import/export statements to find code that is never used. If you import one function from a library that exports fifty, tree shaking removes the other forty-nine from your bundle. It requires ES modules (import/export) to work."

    - question: "Why should you audit third-party dependencies for bundle impact?"
      type: single
      options:
        - "A single large dependency can double the bundle size for a feature that could be done in fewer lines"
        - "Third-party code always has security vulnerabilities"
        - "npm packages do not support tree shaking"
        - "Third-party code runs slower than first-party code"
      correctAnswer: "A single large dependency can double the bundle size for a feature that could be done in fewer lines"
      explanation: "Some npm packages are surprisingly large. Importing a date formatting library that adds 70KB when a 10-line Intl.DateTimeFormat call does the same thing wastes bandwidth. Tools like bundlephobia.com let you check the size cost before installing."
---

# Performance Patterns (Code Splitting, Lazy Loading, Bundle Optimization)

A modern single-page application can easily ship megabytes of JavaScript. Users on slow networks or weak devices wait seconds staring at a blank screen while the browser downloads, parses, and executes all that code. Performance patterns exist to fix this: send less code, send it later, and make what you send smaller.

## Code Splitting

Code splitting breaks one large JavaScript bundle into smaller **chunks**. Instead of downloading the entire app upfront, the browser loads only what the current page needs.

### Route-Based Splitting

The most common approach. Each route gets its own chunk. When the user navigates to `/settings`, only the settings chunk downloads.

```javascript
// React example with lazy routes
const Home = lazy(() => import('./pages/Home'));
const Settings = lazy(() => import('./pages/Settings'));
const Dashboard = lazy(() => import('./pages/Dashboard'));

function App() {
  return (
    <Routes>
      <Route path="/" element={<Home />} />
      <Route path="/settings" element={<Settings />} />
      <Route path="/dashboard" element={<Dashboard />} />
    </Routes>
  );
}
```

Each `import()` call creates a separate chunk. Bundlers like Vite and Webpack handle this automatically.

### Component-Based Splitting

For heavy components that are not always visible -- modals, charts, rich text editors -- split at the component level.

```javascript
// Only download the chart library when the user opens the analytics tab
const AnalyticsChart = lazy(() => import('./components/AnalyticsChart'));
```

This keeps the initial page fast even if it contains features that need large libraries.

## Lazy Loading

Lazy loading defers downloading resources until they are actually needed.

### Images

Images below the fold (not visible without scrolling) should load lazily. The browser downloads them only when the user scrolls near them.

```html
<img src="product.jpg" loading="lazy" alt="Product photo" />
```

### Components

As shown above, `lazy()` and dynamic `import()` defer component loading. Combine with a `Suspense` boundary to show a fallback while the chunk downloads:

```jsx
<Suspense fallback={<Spinner />}>
  <Settings />
</Suspense>
```

### Prefetching

Smart lazy loading predicts what the user will need next. When the user hovers over a navigation link, **prefetch** that route's chunk so it is ready when they click.

```html
<link rel="prefetch" href="/chunks/settings.js" />
```

Frameworks like Next.js and Nuxt prefetch visible links automatically.

## Bundle Optimization

### Tree Shaking

Tree shaking removes **unused code** from the bundle. If you import one function from a utility library, tree shaking strips out every other function you did not use.

```javascript
// Only 'debounce' is included in the bundle
import { debounce } from 'lodash-es';
```

Tree shaking requires **ES module syntax** (`import`/`export`). CommonJS (`require`) cannot be statically analyzed and blocks tree shaking.

### Minification

Minification shrinks code without changing behavior:
- Shortens variable names (`calculateTotalPrice` becomes `a`)
- Removes whitespace and comments
- Simplifies expressions

A 500KB bundle might minify to 150KB.

### Compression

Servers compress responses before sending. Brotli typically achieves 15-20% better compression than gzip.

| Technique | Typical Savings |
|-----------|----------------|
| Minification | 50-70% of original size |
| Gzip | 60-70% of minified size |
| Brotli | 70-80% of minified size |

### Dependency Audit

Third-party packages are the biggest source of bundle bloat. Before adding a dependency:

1. **Check its size** on bundlephobia.com
2. **Check if it is tree-shakeable** (ES module exports)
3. **Ask if you need it** -- Can a native API (`Intl`, `URL`, `fetch`) do the same thing?
4. **Consider lighter alternatives** -- `date-fns` instead of `moment`, `clsx` instead of `classnames`

## Measuring Impact

| Tool | What It Measures |
|------|-----------------|
| Lighthouse | Performance score, bundle analysis |
| Webpack Bundle Analyzer | Visual treemap of chunk contents |
| `import-cost` VS Code extension | Size of each import inline |
| Chrome DevTools Coverage | How much downloaded JS is actually executed |

The Coverage tab in DevTools is especially revealing. It shows the percentage of downloaded JavaScript that the page actually runs. Anything unused is a candidate for lazy loading or removal.

## Best Practices

- **Split at the route level first** -- This gives the biggest wins with the least effort
- **Lazy-load heavy components** -- Charts, editors, and maps should not be in the initial bundle
- **Audit dependencies quarterly** -- Packages grow over time. Re-evaluate whether each one earns its weight
- **Set a performance budget** -- For example, "initial JS must stay under 200KB compressed." Fail the build if exceeded
- **Prefetch the next likely route** -- Use link prefetching or framework-level prefetch to hide loading latency

## Key Takeaways

- Code splitting breaks one bundle into route-based or component-based chunks loaded on demand
- Lazy loading defers images and components until they are needed
- Tree shaking removes unused code; minification and compression shrink the rest
- Third-party dependencies are the top source of bundle bloat -- audit them before installing
- Measure with Lighthouse, bundle analyzers, and DevTools Coverage
- Set a performance budget and enforce it in your build pipeline
