---
title: "Property-Based Testing for Edge Cases"
description: "Learn how property-based testing automatically finds edge cases by generating hundreds of random inputs against defined properties."
estimatedMinutes: 13
difficulty: intermediate
learningObjectives:
  - "Understand what property-based testing is and how it differs from example-based testing"
  - "Identify properties that describe correct behavior for a function"
  - "Explain how random input generation discovers edge cases"
  - "Apply property-based testing to common scenarios like serialization, sorting, and APIs"
  - "Recognize when property-based testing adds the most value"
prerequisites:
  - "test-pyramid"
quiz:
  passingScore: 70
  questions:
    - question: "What is the main difference between example-based and property-based testing?"
      type: single
      options:
        - "Example-based tests use specific inputs; property-based tests generate random inputs"
        - "Example-based tests are automated; property-based tests are manual"
        - "Property-based tests only work with numbers"
        - "Example-based tests are faster than property-based tests"
      correctAnswer: "Example-based tests use specific inputs; property-based tests generate random inputs"
      explanation: "In example-based testing, you pick specific inputs (e.g., input=5, expected=10). In property-based testing, the framework generates hundreds of random inputs and checks that a property (a rule) holds true for all of them."

    - question: "What is a 'property' in property-based testing?"
      type: single
      options:
        - "A rule that must hold true for all valid inputs"
        - "A CSS property used in frontend tests"
        - "A configuration setting for the test runner"
        - "A database column that stores test results"
      correctAnswer: "A rule that must hold true for all valid inputs"
      explanation: "A property is a general rule about how a function should behave. For example, 'sorting a list twice gives the same result as sorting it once' is a property. It must be true no matter what list you provide as input."

    - question: "Select all good candidates for property-based testing."
      type: multiple
      options:
        - "Serialization and deserialization (encode then decode gives back original)"
        - "A function that returns a hardcoded string"
        - "Sorting algorithms (output is ordered, same elements)"
        - "Data validation (valid inputs pass, invalid inputs fail)"
      correctAnswers:
        - "Serialization and deserialization (encode then decode gives back original)"
        - "Sorting algorithms (output is ordered, same elements)"
        - "Data validation (valid inputs pass, invalid inputs fail)"
      explanation: "Property-based testing works well when you can state a rule that must hold for any input. Serialization roundtrips, sort invariants, and validation rules are all great candidates. A function that returns a hardcoded value has nothing meaningful to test with random inputs."

    - question: "When a property-based test finds a failing input, what does shrinking do?"
      type: single
      options:
        - "It simplifies the failing input to the smallest case that still fails"
        - "It reduces the size of the test file"
        - "It compresses the test output for logging"
        - "It removes the test from the suite"
      correctAnswer: "It simplifies the failing input to the smallest case that still fails"
      explanation: "Shrinking takes the random input that caused the failure and reduces it step by step. A failing list of 50 items might shrink to a list of 2 items that still triggers the bug. This makes the failure easy to understand and debug."

    - question: "Property-based testing eliminates the need for example-based unit tests."
      type: true-false
      correctAnswer: false
      explanation: "Property-based testing complements example-based tests. Example-based tests document specific important cases and serve as readable documentation. Property-based tests explore the input space more broadly. The best test suites use both approaches together."
---

# Property-Based Testing for Edge Cases

Traditional tests use specific examples. You pick an input, define the expected output, and check that they match. This works well for known scenarios. But what about the inputs you did not think of?

Property-based testing takes a different approach. Instead of testing with specific examples, you define **properties** -- rules that must be true for **any valid input**. A testing framework then generates hundreds or thousands of random inputs and checks that every one of them follows your rules.

This approach is powerful for finding edge cases that human testers miss: empty strings, negative numbers, Unicode characters, extremely large values, and boundary conditions.

## Example-Based vs Property-Based

Consider testing a function that reverses a string.

### Example-Based Approach

```javascript
test('reverse hello', () => {
  expect(reverse('hello')).toBe('olleh');
});

test('reverse empty string', () => {
  expect(reverse('')).toBe('');
});

test('reverse single character', () => {
  expect(reverse('a')).toBe('a');
});
```

You test three examples. They pass. But what about strings with emoji? Unicode? Very long strings? You can only think of so many cases.

### Property-Based Approach

```javascript
import fc from 'fast-check';

test('reverse twice gives original', () => {
  fc.assert(
    fc.property(fc.string(), (s) => {
      expect(reverse(reverse(s))).toBe(s);
    })
  );
});

test('reverse preserves length', () => {
  fc.assert(
    fc.property(fc.string(), (s) => {
      expect(reverse(s).length).toBe(s.length);
    })
  );
});
```

Instead of picking specific strings, you state properties:
- Reversing a string twice gives back the original
- Reversing does not change the length

The framework generates hundreds of random strings -- including empty strings, single characters, Unicode, and very long text -- and checks these properties against all of them.

## What is a Property?

A property is a rule about your code that must hold true for all valid inputs. Good properties describe **what** the code should guarantee, not **how** it works internally.

### Common Property Patterns

| Pattern | Description | Example |
|---------|-------------|---------|
| **Roundtrip** | encode then decode gives back the original | `decode(encode(data)) == data` |
| **Idempotent** | doing it twice gives the same result as once | `sort(sort(list)) == sort(list)` |
| **Invariant** | a condition that always holds after the operation | `len(sorted_list) == len(original_list)` |
| **Comparison** | two implementations give the same result | `fast_sort(list) == simple_sort(list)` |
| **Hard to compute, easy to verify** | checking the answer is simpler than computing it | `is_sorted(sort(list))` is easy to check |

## How Generators Work

Property-based testing frameworks include **generators** (also called strategies) that create random test data.

Common generators include:
- **integers** -- Random whole numbers, including negatives and zero
- **text** -- Random strings, including empty, Unicode, and special characters
- **lists** -- Random lists of any type, including empty lists
- **dictionaries** -- Random key-value pairs
- **composite** -- Custom generators you build from simpler ones

```javascript
import fc from 'fast-check';

test('sort is idempotent', () => {
  fc.assert(
    fc.property(fc.array(fc.integer()), (numbers) => {
      const sorted1 = [...numbers].sort((a, b) => a - b);
      const sorted2 = [...sorted1].sort((a, b) => a - b);
      expect(sorted2).toEqual(sorted1);
    })
  );
});
```

The framework picks different list sizes, different numbers (positive, negative, zero, very large), and runs the test hundreds of times.

## Shrinking: Finding the Simplest Failure

When a property-based test finds a failing input, the failing value might be complex -- a list with 47 items or a string with 200 characters. **Shrinking** simplifies this input to the smallest case that still fails.

For example, if a sort function fails on the list `[99, -3, 42, 0, -1, 7, 15, ...]`, shrinking might reduce it to `[-1, 0]`. This makes the bug obvious: the function does not handle negative numbers correctly.

Shrinking saves debugging time by giving you the simplest possible reproduction case.

## When to Use Property-Based Testing

Property-based testing adds the most value when:

- **Functions have many input combinations** -- Parsers, validators, serializers
- **You can state invariants** -- Sorting, encryption, compression
- **Edge cases matter** -- Financial calculations, data transformations
- **You want to test code you did not write** -- AI-generated code, third-party libraries

It adds less value when:
- The function has very few possible inputs
- Testing requires complex external state (databases, network)
- The property is hard to state without reimplementing the function

## Practical Example: Testing an API Validator

```javascript
import fc from 'fast-check';

test('validator never crashes on any input', () => {
  fc.assert(
    fc.property(fc.string(), (input) => {
      // The validator should return true or false, never throw
      const result = validateEmail(input);
      expect(typeof result).toBe('boolean');
    })
  );
});

test('valid emails are accepted', () => {
  fc.assert(
    fc.property(fc.emailAddress(), (email) => {
      expect(validateEmail(email)).toBe(true);
    })
  );
});
```

The first test checks a **robustness property**: the validator should never crash, no matter what string you give it. The second uses a generator that produces valid email formats and checks they all pass validation.

## Best Practices

- **Start with roundtrip properties** -- If you serialize data, check that deserializing gives back the original. This is the easiest property to write and catches many bugs.
- **Combine with example-based tests** -- Use example tests for documented edge cases and property tests for broad exploration. They work best together.
- **Set a reasonable number of runs** -- 100-200 runs is often enough. Too many runs slow down CI without finding more bugs.
- **Save failing seeds** -- When a property test finds a bug, save the random seed so you can reproduce the exact failure later.

## Common Mistakes to Avoid

1. **Writing properties that just restate the implementation** -- If your property calls the same logic as the function under test, you are testing nothing. Properties should describe the result, not the process.

2. **Ignoring shrunk examples** -- When a test fails, always look at the shrunk (simplified) input. It tells you the minimal conditions needed to trigger the bug.

## Key Takeaways

- Property-based testing generates random inputs and checks that rules (properties) hold for all of them
- It finds edge cases that example-based tests miss: empty values, negatives, Unicode, boundary conditions
- Common property patterns include roundtrip, idempotent, invariant, and comparison
- Shrinking simplifies failing inputs to the smallest case that still fails
- Use property-based testing alongside example-based tests for the best coverage
- This approach is especially valuable for testing parsers, validators, serializers, and AI-generated code
