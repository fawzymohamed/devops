---
title: "Contract Testing for API Boundaries"
description: "Learn how contract testing catches breaking changes at API boundaries between services without running full integration tests."
estimatedMinutes: 14
difficulty: intermediate
learningObjectives:
  - "Understand what contract testing is and the problem it solves"
  - "Explain the difference between consumer-driven and provider-driven contracts"
  - "Identify when contract testing is more effective than integration testing"
  - "Describe how contract tests fit into a CI/CD pipeline"
  - "Recognize common failure scenarios that contract tests catch"
prerequisites:
  - "test-pyramid"
quiz:
  passingScore: 70
  questions:
    - question: "What problem does contract testing solve?"
      type: single
      options:
        - "It catches breaking API changes between services without running the full stack"
        - "It replaces all other types of testing"
        - "It tests the database schema for errors"
        - "It measures API response time"
      correctAnswer: "It catches breaking API changes between services without running the full stack"
      explanation: "Contract testing verifies that API producers and consumers agree on the request and response format. It catches breaking changes early without needing to deploy both services together, which is the main challenge in microservice testing."

    - question: "In consumer-driven contract testing, who defines the contract?"
      type: single
      options:
        - "The consumer (the service that calls the API)"
        - "The provider (the service that exposes the API)"
        - "The DevOps team"
        - "The database administrator"
      correctAnswer: "The consumer (the service that calls the API)"
      explanation: "In consumer-driven contracts, the consumer writes a contract describing what it needs from the provider. The provider then verifies it can meet that contract. This puts the focus on what consumers actually use, not everything the provider offers."

    - question: "Select all scenarios where contract testing is valuable."
      type: multiple
      options:
        - "Multiple teams own different microservices that call each other"
        - "A single developer maintains one monolithic application"
        - "A public API is consumed by external customers"
        - "Services are deployed independently on different schedules"
      correctAnswers:
        - "Multiple teams own different microservices that call each other"
        - "A public API is consumed by external customers"
        - "Services are deployed independently on different schedules"
      explanation: "Contract testing is most valuable when services are owned by different teams, consumed by external parties, or deployed independently. In a single monolith maintained by one person, integration tests are simpler and sufficient."

    - question: "Contract tests replace the need for integration tests entirely."
      type: true-false
      correctAnswer: false
      explanation: "Contract tests check that the API format is correct (structure, fields, types). They do not check business logic, database behavior, or end-to-end workflows. You still need integration tests for those concerns. Contract tests complement integration tests -- they do not replace them."

    - question: "What happens when a provider runs a consumer's contract test and it fails?"
      type: single
      options:
        - "It means the provider made a change that would break that consumer"
        - "It means the consumer has a bug in its code"
        - "It means the network is down"
        - "It means the contract file is corrupted"
      correctAnswer: "It means the provider made a change that would break that consumer"
      explanation: "When the provider verifies a consumer contract and it fails, the provider knows its latest changes would break that consumer. The provider can fix the issue before deploying, preventing a production outage."
---

# Contract Testing for API Boundaries

In a microservices system, services talk to each other through APIs. Service A calls Service B, which calls Service C. If Service B changes its API response format, Service A might break -- even though nobody changed Service A's code.

This is the **integration boundary problem**. Contract testing solves it by checking that services agree on their API formats **without running the full stack together**.

As a DevOps architect, you need contract testing when teams deploy services independently. It catches breaking changes early, in the CI pipeline, before they reach production.

## What is Contract Testing?

A contract is an agreement between two services about the shape of their API communication. It defines:

- What request the consumer sends (method, path, headers, body)
- What response the provider returns (status code, headers, body structure)

Contract testing verifies this agreement automatically. Each side runs tests independently -- the consumer tests against a mock, and the provider tests against the contract.

::illustration-comparison-map
---
leftTitle: Consumer Side
rightTitle: Provider Side
leftColor: violet
rightColor: emerald
connections:
  - left: Writes contract expectations
    right: Verifies it can meet contracts
    icon: "\U0001F4DD"
  - left: Tests against mock provider
    right: Tests against real implementation
    icon: "\U0001F9EA"
  - left: Runs in consumer CI pipeline
    right: Runs in provider CI pipeline
    icon: "\U00002699\uFE0F"
  - left: Catches consumer assumption errors
    right: Catches breaking provider changes
    icon: "\U0001F6E1\uFE0F"
footnote: Both sides test independently -- no need to deploy together
---
::

## Consumer-Driven vs Provider-Driven

### Consumer-Driven Contracts

The **consumer** writes the contract. It says: "I send this request and I expect this response." The provider then verifies it can meet all consumer contracts.

This approach works well when:
- Multiple consumers depend on one provider
- Consumers only use a subset of the provider's API
- You want to know exactly which consumers would break before deploying

```yaml
# Example: Consumer contract for a user service
consumer: OrderService
provider: UserService
interactions:
  - description: "Get user by ID"
    request:
      method: GET
      path: /users/42
    response:
      status: 200
      body:
        id: 42
        name: "Alice"
        email: "alice@example.com"
```

### Provider-Driven Contracts

The **provider** defines the contract. It publishes a schema (like OpenAPI) that says: "This is what I offer." Consumers validate their code against that published schema.

This approach works well when:
- The provider has a public API with many unknown consumers
- The provider wants to control the API contract centrally
- You use OpenAPI or GraphQL schemas as the source of truth

## How Contract Testing Works

The contract testing workflow has two phases that run separately in each team's CI pipeline.

### Phase 1: Consumer Test

The consumer writes a test that describes what it expects from the provider. The test runs against a mock that simulates the provider's response.

```python
# Consumer test: OrderService expects UserService to return user data
def test_get_user_returns_name_and_email(mock_user_service):
    response = mock_user_service.get("/users/42")
    assert response.status_code == 200
    assert "name" in response.json()
    assert "email" in response.json()
```

This test creates a **contract file** -- a record of what the consumer expects.

### Phase 2: Provider Verification

The provider downloads the consumer's contract file and replays the requests against its real implementation. If the responses match the contract, the verification passes.

```python
# Provider verification: UserService replays OrderService's contract
def test_verify_order_service_contract(contract_replay):
    # Automatically replays GET /users/42 from the contract
    # Checks that the real response matches expected format
    results = contract_replay.verify("OrderService")
    assert results.all_passed()
```

If the provider changes the response format (e.g., renames "name" to "fullName"), the verification fails. The provider team knows immediately which consumers would break.

## Contract Tests in CI/CD

Contract tests fit naturally into CI/CD pipelines because each side runs independently.

::illustration-linear-flow
---
steps:
  - label: Consumer writes contract
    icon: "\U0001F4DD"
    color: violet
  - label: Contract published
    icon: "\U0001F4E6"
    color: blue
  - label: Provider verifies
    icon: "\U00002705"
    color: emerald
  - label: Safe to deploy
    icon: "\U0001F680"
    color: amber
---
::

**In the consumer pipeline:** Run consumer contract tests. Publish the contract to a shared broker or repository.

**In the provider pipeline:** Download all consumer contracts. Verify the provider meets them. Block deployment if any contract fails.

This workflow means you never need to spin up both services together just to check API compatibility. Each team runs their pipeline independently.

## What Contract Tests Catch

| Caught by Contract Tests | Not Caught by Contract Tests |
|--------------------------|------------------------------|
| Renamed or removed fields | Business logic errors |
| Changed data types (string to number) | Performance problems |
| Missing required fields | Database query bugs |
| Changed status codes | Authentication flows |
| New required request parameters | Complex multi-step workflows |

Contract tests check **structure and format**. They do not check business logic or end-to-end behavior. You still need integration and E2E tests for those.

## Best Practices

- **Start with consumer-driven contracts** for internal microservices. Consumers know what they actually need.
- **Use provider-driven contracts** for public APIs where you do not know all consumers.
- **Store contracts in a shared broker** so both sides can access them automatically.
- **Run provider verification on every PR** to catch breaking changes before they merge.
- **Version your contracts** so you can support multiple API versions during migration.

## Common Mistakes to Avoid

1. **Testing too much in the contract** -- Contracts should check structure (field names, types, status codes), not exact values. Testing for `name: "Alice"` makes the contract brittle. Test for `name: string` instead.

2. **Forgetting to update contracts when consumers change** -- If a consumer starts using a new field, it must update its contract. Otherwise the provider does not know about the new dependency.

## Key Takeaways

- Contract testing checks that services agree on their API format without running the full stack
- Consumer-driven contracts let consumers define what they need from providers
- Provider-driven contracts work well for public APIs with many unknown consumers
- Each side runs tests independently in their own CI pipeline
- Contract tests catch structural breaking changes but not business logic errors
- This approach is essential when teams deploy microservices independently on different schedules
