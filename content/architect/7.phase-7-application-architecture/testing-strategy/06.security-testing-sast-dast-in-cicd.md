---
title: "Security Testing (SAST, DAST) in CI/CD"
description: "Learn how to integrate static and dynamic security testing into CI/CD pipelines to catch vulnerabilities before they reach production."
estimatedMinutes: 15
difficulty: intermediate
learningObjectives:
  - "Understand the difference between SAST (static) and DAST (dynamic) security testing"
  - "Explain where each type fits in the CI/CD pipeline"
  - "Identify the types of vulnerabilities each approach catches"
  - "Design a pipeline that includes both SAST and DAST stages"
  - "Apply the shift-left principle to security testing"
prerequisites:
  - "test-pyramid"
quiz:
  passingScore: 70
  questions:
    - question: "What is the main difference between SAST and DAST?"
      type: single
      options:
        - "SAST analyzes source code without running it; DAST tests the running application"
        - "SAST is for backend code; DAST is for frontend code"
        - "SAST is free; DAST requires a paid license"
        - "SAST tests performance; DAST tests security"
      correctAnswer: "SAST analyzes source code without running it; DAST tests the running application"
      explanation: "SAST (Static Application Security Testing) scans source code, bytecode, or binaries without executing the application. DAST (Dynamic Application Security Testing) sends requests to a running application and analyzes the responses. Both test for security vulnerabilities, but from different angles."

    - question: "Where in the CI/CD pipeline should SAST run?"
      type: single
      options:
        - "Early -- during or right after the build stage"
        - "Only in production"
        - "After deployment to users"
        - "Only during annual security audits"
      correctAnswer: "Early -- during or right after the build stage"
      explanation: "SAST scans source code, so it should run early in the pipeline, ideally during or right after the build stage. This catches vulnerabilities before the code is even deployed. This is the shift-left principle: move security checks earlier in the process."

    - question: "Select all vulnerabilities that SAST can typically detect."
      type: multiple
      options:
        - "SQL injection patterns in source code"
        - "Hardcoded secrets and passwords"
        - "Runtime authentication bypass exploits"
        - "Use of vulnerable library functions"
      correctAnswers:
        - "SQL injection patterns in source code"
        - "Hardcoded secrets and passwords"
        - "Use of vulnerable library functions"
      explanation: "SAST analyzes code patterns and can find SQL injection, hardcoded secrets, and calls to known-vulnerable functions. It cannot detect runtime authentication bypass because it does not execute the application -- that requires DAST."

    - question: "DAST can find vulnerabilities without access to the source code."
      type: true-false
      correctAnswer: true
      explanation: "True. DAST tests a running application from the outside, just like an attacker would. It sends HTTP requests and analyzes responses for security issues. It does not need access to source code, which makes it effective for testing third-party applications and deployed services."

    - question: "Why should a CI/CD pipeline include both SAST and DAST?"
      type: single
      options:
        - "They catch different types of vulnerabilities at different stages"
        - "SAST is required by law and DAST is optional"
        - "DAST is faster so it should replace SAST"
        - "They both find the same bugs so you need redundancy"
      correctAnswer: "They catch different types of vulnerabilities at different stages"
      explanation: "SAST finds code-level issues early (hardcoded secrets, injection patterns). DAST finds runtime issues later (authentication bypass, misconfigured headers, XSS in responses). Together they cover a wider range of vulnerabilities than either one alone."

    - question: "What does 'shift-left security' mean in the context of CI/CD?"
      type: single
      options:
        - "Move security testing earlier in the development pipeline"
        - "Move the security team to the left side of the office"
        - "Only test security in the leftmost microservice"
        - "Write security tests left-to-right"
      correctAnswer: "Move security testing earlier in the development pipeline"
      explanation: "Shift-left means moving activities earlier in the timeline. In a CI/CD pipeline diagram, earlier stages are on the left. Shift-left security means running security tests during development and build stages, not waiting until after deployment. This catches issues when they are cheapest to fix."
---

# Security Testing (SAST, DAST) in CI/CD

Traditional security testing happens at the end of the development cycle. A security team reviews the application before release, finds vulnerabilities, and sends them back for fixing. This process is slow, expensive, and blocks releases.

Modern DevOps teams take a different approach: they embed security testing **directly into the CI/CD pipeline**. Every code change is automatically scanned for vulnerabilities before it can merge or deploy. This is the shift-left security principle.

Two key techniques make this possible: **SAST** (Static Application Security Testing) and **DAST** (Dynamic Application Security Testing). Each catches different types of vulnerabilities at different stages.

## SAST: Testing the Code

SAST analyzes source code, bytecode, or compiled binaries **without running the application**. It looks at patterns in the code to find potential security issues.

Think of SAST as a spell-checker for security. It reads your code and flags suspicious patterns.

### What SAST Finds

| Vulnerability | Example in Code |
|---------------|----------------|
| SQL Injection | `query = "SELECT * FROM users WHERE id=" + user_input` |
| Hardcoded Secrets | `api_key = "sk-1234567890abcdef"` |
| Insecure Functions | Using `eval()` or `exec()` with user input |
| Buffer Overflows | Unchecked array bounds in C/C++ |
| Path Traversal | `open("/files/" + user_input)` without validation |

### Where SAST Fits in the Pipeline

SAST runs **early**, during or right after the build stage. Since it analyzes code (not a running app), it can run as soon as the code is available.

```yaml
# Example: SAST stage in a CI pipeline
stages:
  - build
  - sast_scan
  - test
  - deploy

sast_scan:
  stage: sast_scan
  script:
    - semgrep --config auto ./src
    - echo "SAST scan complete"
  allow_failure: false  # Block pipeline on critical findings
```

### SAST Strengths and Limits

**Strengths:**
- Runs early, catches issues before deployment
- Covers all code paths (even unreachable ones)
- Finds issues that are invisible at runtime (hardcoded secrets)
- Fast -- scans complete in minutes

**Limits:**
- Produces false positives (flags code that is not actually vulnerable)
- Cannot find runtime configuration issues
- Does not understand the running environment (network, auth flows)

## DAST: Testing the Running Application

DAST tests a **running application** from the outside. It sends HTTP requests with malicious payloads and checks how the application responds. It does not need access to source code.

Think of DAST as a simulated attacker. It probes your running application for weaknesses.

### What DAST Finds

| Vulnerability | How DAST Detects It |
|---------------|---------------------|
| Cross-Site Scripting (XSS) | Sends script tags in input fields, checks if they execute |
| Authentication Bypass | Tries accessing protected pages without credentials |
| Insecure Headers | Checks for missing HSTS, CSP, X-Frame-Options |
| Server Misconfigurations | Looks for exposed error pages, directory listing |
| Cookie Issues | Checks for missing Secure, HttpOnly, SameSite flags |

### Where DAST Fits in the Pipeline

DAST runs **later**, after the application is deployed to a staging environment. It needs a running application to test against.

```yaml
# Example: DAST stage after staging deployment
stages:
  - build
  - sast_scan
  - test
  - deploy_staging
  - dast_scan
  - deploy_production

dast_scan:
  stage: dast_scan
  script:
    - zap-cli quick-scan --self-contained https://staging.example.com
    - zap-cli report -o dast-report.html
  allow_failure: false
```

### DAST Strengths and Limits

**Strengths:**
- Finds runtime vulnerabilities SAST cannot see
- No source code access needed
- Tests the real deployed configuration
- Low false positive rate for confirmed exploits

**Limits:**
- Slower than SAST (minutes to hours)
- Needs a running environment
- Cannot find issues deep in code logic
- Only tests code paths it can reach through the UI/API

## SAST and DAST Together

SAST and DAST are not competing approaches. They are complementary layers that catch different vulnerabilities at different times.

::illustration-comparison-map
---
leftTitle: SAST
rightTitle: DAST
leftColor: violet
rightColor: emerald
connections:
  - left: Scans source code
    right: Tests running application
    icon: "\U0001F50D"
  - left: Runs early (build stage)
    right: Runs late (staging stage)
    icon: "\U000023F1\uFE0F"
  - left: Finds code-level flaws
    right: Finds runtime flaws
    icon: "\U0001F41B"
  - left: Higher false positive rate
    right: Lower false positive rate
    icon: "\U0001F4CA"
  - left: No running environment needed
    right: Needs deployed application
    icon: "\U0001F5A5\uFE0F"
footnote: Use both for comprehensive security coverage
---
::

## Pipeline Design

A well-designed pipeline includes both SAST and DAST at the right stages.

::illustration-linear-flow
---
steps:
  - label: Code
    sublabel: Developer commits
    icon: "\U0001F4BB"
    color: blue
  - label: Build
    sublabel: Compile & package
    icon: "\U0001F528"
    color: blue
  - label: SAST
    sublabel: Scan source code
    icon: "\U0001F50D"
    color: violet
  - label: Unit Tests
    sublabel: Fast tests
    icon: "\U0001F9EA"
    color: emerald
  - label: Deploy Staging
    sublabel: Staging environment
    icon: "\U0001F680"
    color: amber
  - label: DAST
    sublabel: Scan running app
    icon: "\U0001F6E1\uFE0F"
    color: rose
  - label: Deploy Prod
    sublabel: Production
    icon: "\U00002705"
    color: emerald
---
::

**Key decisions:**
- SAST blocks the pipeline if critical vulnerabilities are found
- DAST runs against staging, not production
- Results feed into a vulnerability dashboard for tracking
- Teams set thresholds: critical and high block deployment, medium and low create tickets

## Handling False Positives

Both SAST and DAST produce false positives -- flagging code that is not actually vulnerable. This is one of the biggest challenges in security testing.

**Strategies to manage false positives:**
- **Tune rules gradually** -- Start with a small, high-confidence rule set and expand over time
- **Use suppression files** -- Mark verified false positives so they do not block future scans
- **Prioritize by severity** -- Block only on critical/high findings; review medium/low asynchronously
- **Review weekly** -- A security champion reviews new findings each week and triages them

## Best Practices

- **Run SAST on every pull request** to catch issues before they merge
- **Run DAST nightly** against staging if full scans are too slow for every deployment
- **Block merges for critical SAST findings** but allow medium/low to be tracked as tickets
- **Combine with Software Composition Analysis (SCA)** to also check for vulnerable dependencies
- **Track vulnerability trends** over time to measure whether security is improving

## Common Mistakes to Avoid

1. **Running security scans only before releases** -- By then, vulnerabilities are expensive to fix and may delay the release. Run scans continuously in every pipeline.

2. **Ignoring false positives without documenting why** -- If you suppress a finding, record the reason. Otherwise, a real vulnerability might be hidden behind a blanket suppression.

## Key Takeaways

- SAST scans source code without running it and catches code-level vulnerabilities early
- DAST tests the running application from the outside and catches runtime configuration issues
- SAST runs early in the pipeline (build stage); DAST runs later (staging stage)
- Together they cover a wider range of vulnerabilities than either alone
- Shift-left security means embedding these scans into every CI/CD pipeline run
- Managing false positives with tuning, suppression files, and severity thresholds keeps the pipeline practical
