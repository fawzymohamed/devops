---
title: "Process Management"
description: "Learn to view and control Linux processes using ps, top, kill, and background job management."
estimatedMinutes: 12
difficulty: beginner
learningObjectives:
  - "View running processes with ps and top"
  - "Understand process states, PIDs, and parent-child relationships"
  - "Terminate processes using kill, killall, and pkill"
  - "Run and manage background processes with &, jobs, fg, and bg"
quiz:
  passingScore: 70
  questions:
    - question: "Which signal gracefully asks a process to terminate?"
      type: single
      options:
        - "SIGKILL (9)"
        - "SIGTERM (15)"
        - "SIGSTOP (19)"
        - "SIGHUP (1)"
      correctAnswer: "SIGTERM (15)"
      explanation: "SIGTERM (signal 15) is the default signal sent by kill. It requests graceful termination, allowing the process to clean up. SIGKILL (9) forcefully terminates without cleanup."

    - question: "What command shows a real-time, continuously updating view of processes?"
      type: single
      options:
        - "ps aux"
        - "top"
        - "jobs"
        - "pstree"
      correctAnswer: "top"
      explanation: "top shows a real-time view that updates every few seconds. ps shows a snapshot at a single moment. jobs shows background jobs in the current shell."

    - question: "Select all ways to run a command in the background."
      type: multiple
      options:
        - "Append & to the command"
        - "Press Ctrl+Z then run bg"
        - "Use the nohup command"
        - "Add sudo before the command"
      correctAnswers:
        - "Append & to the command"
        - "Press Ctrl+Z then run bg"
        - "Use the nohup command"
      explanation: "& runs a command in background immediately, Ctrl+Z suspends then bg resumes in background, nohup runs immune to hangups. sudo is for privilege elevation, not background execution."

    - question: "When you close a terminal, background jobs in that terminal automatically stop."
      type: true-false
      correctAnswer: true
      explanation: "True. When a terminal closes, it sends SIGHUP to its child processes, which typically terminates them. Use 'nohup' or 'disown' to prevent this, or use tools like screen or tmux."

    - question: "What does the command 'kill -9 1234' do?"
      type: single
      options:
        - "Gracefully stops process 1234"
        - "Forcefully terminates process 1234"
        - "Restarts process 1234"
        - "Pauses process 1234"
      correctAnswer: "Forcefully terminates process 1234"
      explanation: "kill -9 sends SIGKILL, which forcefully terminates a process immediately. The process cannot catch or ignore this signal. Use this only when SIGTERM (default) fails."
---

# Process Management

Every running program in Linux is a process. As a DevOps engineer, you need to monitor processes, stop misbehaving ones, and manage background tasks. This lesson covers the essential tools for process management.

## What is a Process?

A process is a running instance of a program. When you run `ls`, the system creates a process, executes it, and it terminates. Long-running programs like web servers stay as processes until stopped.

Each process has:
- **PID** - Process ID, a unique number
- **PPID** - Parent Process ID (who started it)
- **State** - Running, sleeping, stopped, etc.
- **Owner** - The user running the process

## Viewing Processes: ps

The `ps` command shows a snapshot of current processes.

### Common ps Commands

```bash
# Show your processes
ps

# Show all processes with details
ps aux

# Show all processes in full format
ps -ef

# Show process tree
ps -ef --forest
```

### Understanding ps aux Output

```bash
ps aux | head -5

USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.1 169432 11680 ?        Ss   Jan10   0:08 /sbin/init
root         2  0.0  0.0      0     0 ?        S    Jan10   0:00 [kthreadd]
ahmed     1543  0.5  2.1 523456 89012 ?        Sl   10:30   0:15 /usr/bin/code
```

| Column | Meaning |
|--------|---------|
| USER | Process owner |
| PID | Process ID |
| %CPU | CPU usage percentage |
| %MEM | Memory usage percentage |
| VSZ | Virtual memory size |
| RSS | Resident memory (actual RAM used) |
| TTY | Terminal (? means no terminal) |
| STAT | Process state |
| START | Start time |
| TIME | CPU time used |
| COMMAND | Command that started the process |

### Process States

| State | Meaning |
|-------|---------|
| R | Running or runnable |
| S | Sleeping (waiting for event) |
| D | Uninterruptible sleep (usually I/O) |
| Z | Zombie (terminated but not cleaned up) |
| T | Stopped |

### Finding Specific Processes

```bash
# Find processes by name
ps aux | grep nginx

# Find by PID
ps -p 1234

# Find processes by user
ps -u ahmed
```

## Real-Time Monitoring: top and htop

### top - Interactive Process Viewer

```bash
top
```

::illustration-checklist
---
title: top Keyboard Shortcuts
items:
  - text: "q    Quit"
    icon: "\U0001F6AA"
  - text: "k    Kill a process (enter PID)"
    icon: "\U0000274C"
  - text: "M    Sort by memory usage"
    icon: "\U0001F4CA"
  - text: "P    Sort by CPU usage"
    icon: "\U0001F4C8"
  - text: "u    Filter by user"
    icon: "\U0001F464"
note: Press h for help inside top
color: blue
size: 2xl
---
::

### htop - Better top

`htop` is a more user-friendly alternative with colors and mouse support:

```bash
# Install htop (if not available)
sudo apt install htop    # Debian/Ubuntu
sudo yum install htop    # RHEL/CentOS

# Run htop
htop
```

## Stopping Processes: kill

The `kill` command sends signals to processes. Despite its name, it does not always kill - it sends signals.

### Common Signals

| Signal | Number | Effect |
|--------|--------|--------|
| SIGTERM | 15 | Graceful termination (default) |
| SIGKILL | 9 | Force kill (cannot be ignored) |
| SIGHUP | 1 | Hangup (often reloads config) |
| SIGSTOP | 19 | Pause process |
| SIGCONT | 18 | Resume paused process |

### Using kill

```bash
# Send SIGTERM (graceful stop)
kill 1234

# Send SIGKILL (force stop)
kill -9 1234
kill -KILL 1234

# Send SIGHUP (reload config)
kill -1 1234
kill -HUP 1234
```

### killall and pkill

```bash
# Kill all processes by name
killall nginx

# Kill processes matching a pattern
pkill -f "python script.py"

# Kill all processes by user
pkill -u ahmed
```

**Always try SIGTERM first.** SIGKILL (9) should be a last resort because:
- Process cannot clean up (close files, release locks)
- May cause data corruption
- Child processes may become orphans

## Background and Foreground Jobs

### Running in Background

Add `&` to run a command in the background:

```bash
# Run in background
./long-script.sh &

# Background with output suppression
./script.sh > output.log 2>&1 &
```

### Managing Jobs

```bash
# List background jobs
jobs

# Example output
[1]+  Running    ./script.sh &
[2]-  Stopped    vim file.txt

# Bring job to foreground
fg %1

# Send job to background
bg %1
```

### Suspending and Resuming

```bash
# While a command runs, press Ctrl+Z to suspend it
# Then use bg to continue in background
^Z
[1]+  Stopped    ./script.sh
bg %1
[1]+ ./script.sh &
```

### Keeping Processes Running After Logout

When you close a terminal, background jobs usually stop. Use `nohup` to prevent this:

```bash
# Run immune to hangups
nohup ./script.sh &

# Output goes to nohup.out by default
nohup ./script.sh > output.log 2>&1 &
```

For more control, use `screen` or `tmux` which let you detach and reattach to sessions.

## Process Relationships

Every process has a parent. The first process (PID 1) is `init` or `systemd`, which spawns all other processes.

```bash
# View process tree
pstree

# Show parent-child relationships
ps -ef --forest

# Find parent of a process
ps -o ppid= -p 1234
```

When a parent dies before its children, the children become orphans and are adopted by PID 1.

## Practical Examples

### Finding and Killing a Stuck Process

```bash
# Find the process
ps aux | grep stuck-app

# Note the PID (second column)
# Try graceful termination first
kill 12345

# Wait a few seconds, check if it's gone
ps -p 12345

# If still running, force kill
kill -9 12345
```

### Monitoring Server Resources

```bash
# Quick overview
top -b -n 1 | head -20

# Watch memory usage
watch -n 2 free -h

# See what's using CPU
ps aux --sort=-%cpu | head -10

# See what's using memory
ps aux --sort=-%mem | head -10
```

### Running a Task That Survives Logout

```bash
# Start long task that won't die on logout
nohup ./backup-script.sh > backup.log 2>&1 &

# Check it's running
jobs
ps aux | grep backup
```

## Key Takeaways

- Every running program is a process with a unique PID
- `ps aux` shows all processes; `top` shows real-time updates
- `kill` sends signals; SIGTERM (15) for graceful, SIGKILL (9) for forced termination
- Use `&` to run commands in background; `jobs`, `fg`, `bg` to manage them
- Use `nohup` to keep processes running after logout
- Always try graceful termination before force killing

In the next lesson, you will learn about package managers - how to install, update, and remove software on Linux systems.
