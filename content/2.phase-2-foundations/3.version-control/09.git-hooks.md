---
title: "Git Hooks"
description: "Learn how to use Git hooks to automate tasks like linting, testing, and validation at key points in your workflow."
estimatedMinutes: 12
difficulty: intermediate
learningObjectives:
  - "Understand what Git hooks are and when they run"
  - "Create and configure common Git hooks"
  - "Use hooks for code quality enforcement"
  - "Share hooks with your team using tools like Husky"
prerequisites:
  - "git-basics"
quiz:
  passingScore: 70
  questions:
    - question: "Where are Git hooks stored in a repository?"
      type: single
      options:
        - "/hooks"
        - ".git/hooks"
        - ".hooks"
        - "git-hooks/"
      correctAnswer: ".git/hooks"
      explanation: "Git hooks are stored in the .git/hooks directory. Since .git is not tracked, hooks need special handling to share with the team."

    - question: "Which hook runs before a commit is created?"
      type: single
      options:
        - "post-commit"
        - "pre-push"
        - "pre-commit"
        - "commit-msg"
      correctAnswer: "pre-commit"
      explanation: "pre-commit runs before the commit is created. It is commonly used for linting, formatting, and running tests. If it exits with non-zero, the commit is aborted."

    - question: "Select all common uses for Git hooks."
      type: multiple
      options:
        - "Running linters before commit"
        - "Validating commit message format"
        - "Running tests before push"
        - "Automatically merging branches"
      correctAnswers:
        - "Running linters before commit"
        - "Validating commit message format"
        - "Running tests before push"
      explanation: "Hooks automate validation and quality checks. They run code at specific Git events. Automatic merging is not a hook use case."

    - question: "A hook that exits with code 0 allows the Git operation to proceed."
      type: true-false
      correctAnswer: true
      explanation: "True. Exit code 0 means success, allowing the operation. Any non-zero exit code aborts the operation (for pre-* hooks)."

    - question: "Why are hooks in .git/hooks not automatically shared with the team?"
      type: single
      options:
        - "Hooks are too large to commit"
        - "The .git directory is not tracked by Git"
        - "Hooks contain passwords"
        - "Only admins can use hooks"
      correctAnswer: "The .git directory is not tracked by Git"
      explanation: "The .git folder is Git's internal storage and is never tracked. This means hooks must be shared through other means like setup scripts or tools like Husky."
---

# Git Hooks

Git hooks are scripts that run automatically at specific points in your Git workflow. They let you automate tasks like running tests, checking code style, or validating commit messages.

## What Are Git Hooks?

Hooks are scripts in `.git/hooks/`. When you run certain Git commands, Git checks for a matching hook and runs it if found.

```bash
# See available hooks
ls .git/hooks/

# Example output (sample hooks)
applypatch-msg.sample
pre-commit.sample
prepare-commit-msg.sample
commit-msg.sample
pre-push.sample
```

The `.sample` extension disables them. Remove it to activate a hook.

## Types of Hooks

::illustration-linear-flow
---
steps:
  - label: pre-commit
    sublabel: Before commit
    icon: "\U0001F6E1\uFE0F"
    color: blue
  - label: commit-msg
    sublabel: Validate message
    icon: "\U0001F4DD"
    color: violet
  - label: post-commit
    sublabel: After commit
    icon: "\U00002705"
    color: emerald
  - label: pre-push
    sublabel: Before push
    icon: "\U0001F680"
    color: amber
direction: horizontal
size: full
---
::

### Client-Side Hooks

| Hook | When It Runs | Common Use |
|------|--------------|------------|
| `pre-commit` | Before commit is created | Lint, format, run quick tests |
| `prepare-commit-msg` | Before commit message editor opens | Add template to message |
| `commit-msg` | After message is entered | Validate message format |
| `post-commit` | After commit is complete | Notifications |
| `pre-push` | Before push to remote | Run full test suite |
| `post-checkout` | After checkout | Setup environment |
| `pre-rebase` | Before rebase starts | Prevent rebasing certain branches |

### Server-Side Hooks

| Hook | When It Runs | Common Use |
|------|--------------|------------|
| `pre-receive` | Before accepting push | Enforce policies |
| `update` | Per branch being updated | Branch-specific rules |
| `post-receive` | After push accepted | Deploy, notify |

## Creating a Hook

Hooks are executable scripts. They can be shell scripts, Python, Node.js, or any language.

### Simple pre-commit Hook

```bash
# Create the hook file
nano .git/hooks/pre-commit
```

```bash
#!/bin/bash

echo "Running pre-commit checks..."

# Run linter
npm run lint
if [ $? -ne 0 ]; then
    echo "Linting failed! Fix errors before committing."
    exit 1
fi

echo "All checks passed!"
exit 0
```

Make it executable:

```bash
chmod +x .git/hooks/pre-commit
```

Now the linter runs before every commit. If it fails, the commit is blocked.

### commit-msg Hook

Validate commit message format:

```bash
#!/bin/bash

# Get the commit message file
MSG_FILE=$1
MSG=$(cat "$MSG_FILE")

# Check message length
if [ ${#MSG} -lt 10 ]; then
    echo "Error: Commit message must be at least 10 characters."
    exit 1
fi

# Check for conventional commit format
if ! echo "$MSG" | grep -qE "^(feat|fix|docs|style|refactor|test|chore):"; then
    echo "Error: Commit must start with: feat:, fix:, docs:, style:, refactor:, test:, or chore:"
    exit 1
fi

exit 0
```

### pre-push Hook

Run tests before pushing:

```bash
#!/bin/bash

echo "Running tests before push..."

npm test
if [ $? -ne 0 ]; then
    echo "Tests failed! Fix them before pushing."
    exit 1
fi

exit 0
```

## Bypassing Hooks

Sometimes you need to skip hooks:

```bash
# Skip pre-commit hook
git commit --no-verify -m "Emergency fix"

# Skip pre-push hook
git push --no-verify
```

Use this sparingly. If you skip hooks often, the hooks might be too strict.

## Sharing Hooks with Your Team

The `.git` directory is not tracked, so hooks are not automatically shared. Solutions:

### Option 1: Setup Script

Store hooks in a tracked folder and copy them:

```bash
# Project structure
my-project/
  scripts/
    hooks/
      pre-commit
      commit-msg
  setup.sh
```

```bash
# setup.sh
#!/bin/bash
cp scripts/hooks/* .git/hooks/
chmod +x .git/hooks/*
echo "Hooks installed!"
```

### Option 2: Git Config

Point to a different hooks directory:

```bash
# In the repo
git config core.hooksPath scripts/hooks
```

Add to your documentation so everyone runs this.

### Option 3: Husky (Recommended for Node.js)

Husky is a popular tool for managing hooks:

```bash
# Install Husky
npm install husky --save-dev

# Enable Git hooks
npx husky install

# Add to package.json so it runs on npm install
# In package.json, add:
# "scripts": { "prepare": "husky install" }

# Create a pre-commit hook
npx husky add .git/hooks/pre-commit "npm run lint"
```

This creates hooks that work for everyone who runs `npm install`.

## Practical Example: Full Setup

Complete pre-commit setup with multiple checks:

```bash
#!/bin/bash

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
NC='\033[0m' # No Color

echo "Running pre-commit hooks..."

# Check for debugging statements
if git diff --cached --name-only | xargs grep -l "console.log\|debugger" 2>/dev/null; then
    echo -e "${RED}Error: Remove console.log or debugger statements${NC}"
    exit 1
fi

# Run linter on staged files only
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.js$')
if [ -n "$STAGED_FILES" ]; then
    echo "Linting staged JavaScript files..."
    echo "$STAGED_FILES" | xargs npx eslint
    if [ $? -ne 0 ]; then
        echo -e "${RED}Linting failed!${NC}"
        exit 1
    fi
fi

# Run type check
echo "Running type check..."
npm run typecheck
if [ $? -ne 0 ]; then
    echo -e "${RED}Type check failed!${NC}"
    exit 1
fi

echo -e "${GREEN}All pre-commit checks passed!${NC}"
exit 0
```

## Best Practices

::illustration-checklist
---
title: Git Hooks Best Practices
items:
  - text: Keep hooks fast (< 10 seconds)
    icon: "\U000026A1"
  - text: Only check staged files in pre-commit
    icon: "\U0001F3AF"
  - text: Use tools like Husky for team sharing
    icon: "\U0001F465"
  - text: Provide clear error messages
    icon: "\U0001F4AC"
  - text: Allow bypass for emergencies
    icon: "\U0001F6AA"
note: Slow hooks lead to people bypassing them
color: violet
size: 2xl
---
::

## Common Mistakes to Avoid

1. **Slow hooks**: If pre-commit takes 2 minutes, people will bypass it
2. **Not sharing hooks**: Team members should have the same checks
3. **No error messages**: Tell users what failed and how to fix it
4. **Too strict**: Balance quality with developer experience
5. **Not testing hooks**: Test your hooks before requiring them

## Key Takeaways

- Git hooks run scripts at key points like commit and push
- Hooks live in `.git/hooks/` and must be executable
- Use pre-commit for linting, commit-msg for message validation
- Exit code 0 allows the operation, non-zero blocks it
- Share hooks using Husky or setup scripts
- Keep hooks fast and provide clear error messages

In the next lesson, you will learn about tags and releases for marking important versions in your project.
