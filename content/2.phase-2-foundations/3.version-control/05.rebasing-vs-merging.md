---
title: "Rebasing vs Merging"
description: "Understand the differences between git rebase and git merge, and when to use each approach."
estimatedMinutes: 15
difficulty: intermediate
learningObjectives:
  - "Understand how merge creates a merge commit"
  - "Understand how rebase replays commits on a new base"
  - "Know when to use merge vs rebase"
  - "Perform interactive rebase to clean up history"
prerequisites:
  - "branching-merging"
quiz:
  passingScore: 70
  questions:
    - question: "What does git rebase do to your commits?"
      type: single
      options:
        - "Creates a merge commit"
        - "Moves and replays commits onto a new base"
        - "Deletes old commits"
        - "Copies commits to a remote"
      correctAnswer: "Moves and replays commits onto a new base"
      explanation: "Rebase takes your commits, temporarily removes them, updates your branch to the new base, then replays your commits on top. This creates new commit hashes."

    - question: "Select all true statements about git merge."
      type: multiple
      options:
        - "It preserves the complete branch history"
        - "It creates a merge commit"
        - "It changes existing commit hashes"
        - "It can be a fast-forward if no divergence"
      correctAnswers:
        - "It preserves the complete branch history"
        - "It creates a merge commit"
        - "It can be a fast-forward if no divergence"
      explanation: "Merge preserves history and creates merge commits. It does not change existing commits. Fast-forward happens when there is no divergence."

    - question: "When should you avoid rebasing?"
      type: single
      options:
        - "On local branches before pushing"
        - "On branches that have been pushed and shared"
        - "When you want a cleaner history"
        - "Before creating a pull request"
      correctAnswer: "On branches that have been pushed and shared"
      explanation: "Never rebase commits that others are working with. Rebase changes commit hashes, which causes problems for anyone who has the old commits."

    - question: "Interactive rebase (git rebase -i) lets you edit, squash, or reorder commits."
      type: true-false
      correctAnswer: true
      explanation: "True. Interactive rebase gives you full control over commits. You can squash multiple commits into one, edit commit messages, reorder commits, or remove commits entirely."

    - question: "What is the golden rule of rebasing?"
      type: single
      options:
        - "Always rebase before merging"
        - "Never rebase public/shared branches"
        - "Rebase at least once per day"
        - "Only rebase main branch"
      correctAnswer: "Never rebase public/shared branches"
      explanation: "The golden rule is to never rebase commits that have been pushed and shared with others. Rebasing rewrites history, which causes serious problems for collaborators."
---

# Rebasing vs Merging

Both merge and rebase combine work from different branches. But they do it in very different ways. Understanding when to use each is key to maintaining a clean and useful Git history.

## The Problem They Solve

You have a feature branch that started from main. While you worked, main got new commits. Now you need to integrate those changes.

```
Before integration:

main:    A---B---C
              \
feature:       D---E
```

You can either merge or rebase. The result looks different.

## How Merge Works

Merge creates a new commit that combines both branches:

```bash
git checkout feature
git merge main
```

Result:

```
main:    A---B---C
              \   \
feature:       D---E---M
```

The merge commit M has two parents: C and E. This preserves the complete history of both branches.

::illustration-comparison-map
---
leftTitle: Before Merge
rightTitle: After Merge
leftColor: blue
rightColor: emerald
connections:
  - left: main branch
    right: Unchanged
    icon: "\U0001F3E0"
  - left: feature branch
    right: Gets merge commit
    icon: "\U0001F500"
  - left: History
    right: Preserved completely
    icon: "\U0001F4DC"
footnote: Merge is safe and preserves all history
---
::

## How Rebase Works

Rebase moves your commits to start from the new tip:

```bash
git checkout feature
git rebase main
```

Result:

```
main:    A---B---C
                  \
feature:           D'---E'
```

Your commits D and E become D' and E' - they have new hashes because their parent changed.

```bash
# Before rebase
git log --oneline
# e4f5g6h (HEAD -> feature) Add login form     # commit E
# d3c2b1a Add login validation                  # commit D

# After rebase - same changes, new hashes
git log --oneline
# a1b2c3d (HEAD -> feature) Add login form     # commit E'
# f4e5d6c Add login validation                  # commit D'
```

## Visual Comparison

```
Merge keeps parallel history:

main:    A---B---C
              \   \
feature:       D---E---M

Rebase creates linear history:

main:    A---B---C
                  \
feature:           D'---E'
```

## When to Use Merge

Use merge when:

- Working on shared branches
- You want to preserve the complete history
- Combining long-running branches
- Creating pull requests (often prefer merge)

```bash
# Merging main into your feature branch
git checkout feature
git merge main

# Merging feature into main (often done via PR)
git checkout main
git merge feature
```

## When to Use Rebase

Use rebase when:

- Cleaning up local commits before sharing
- Keeping a linear history
- Updating a feature branch with main changes (before PR)
- Working alone on a branch

```bash
# Update feature with latest main before opening PR
git checkout feature
git rebase main

# Then force push if already pushed (only if branch is not shared)
git push --force-with-lease
```

## Interactive Rebase

Interactive rebase lets you edit commits before replaying them:

```bash
# Rebase last 3 commits interactively
git rebase -i HEAD~3
```

This opens an editor:

```
pick a1b2c3d Add login form
pick e4f5g6h Fix typo
pick h7i8j9k Add validation

# Commands:
# p, pick = use commit
# r, reword = edit commit message
# e, edit = pause for amending
# s, squash = combine with previous
# f, fixup = like squash but discard message
# d, drop = remove commit
```

### Squashing Commits

Combine multiple commits into one:

```
pick a1b2c3d Add login form
squash e4f5g6h Fix typo
squash h7i8j9k Add validation
```

This creates one clean commit instead of three messy ones.

### Reordering Commits

Just change the order of lines:

```
pick h7i8j9k Add validation
pick a1b2c3d Add login form
```

### Editing Commit Messages

```
reword a1b2c3d Add login form
pick e4f5g6h Fix typo
```

## The Golden Rule

**Never rebase commits that have been pushed and shared with others.**

Rebasing rewrites history. If others have your old commits, they will have conflicts when you push the rewritten history.

```bash
# This is dangerous on shared branches
git rebase main
git push --force  # DON'T do this on shared branches
```

Safe rebasing:

```bash
# Only rebase local commits
# Or use --force-with-lease for extra safety
git push --force-with-lease
```

`--force-with-lease` fails if someone else has pushed changes since your last fetch.

## Practical Workflow

Common pattern for feature branches:

```bash
# 1. Work on feature
git checkout -b feature/login
# ... make commits ...

# 2. Before PR, update with main
git fetch origin
git rebase origin/main

# 3. If conflicts, resolve them
# ... edit files to fix conflicts ...
git add .
git rebase --continue

# 4. Push (force if already pushed)
git push --force-with-lease origin feature/login

# 5. Create pull request
```

## Handling Rebase Conflicts

During rebase, conflicts can occur at each commit:

```bash
git rebase main
# CONFLICT in file.txt

# Fix the conflict
# ... edit file.txt ...

# Mark resolved and continue
git add file.txt
git rebase --continue

# Or abort the rebase
git rebase --abort
```

## Summary Comparison

| Aspect | Merge | Rebase |
|--------|-------|--------|
| History | Preserves branches | Creates linear history |
| Commits | Adds merge commit | Rewrites commit hashes |
| Conflicts | Resolve once | May resolve per commit |
| Shared branches | Safe | Dangerous |
| Undo | Easy | Harder |

## Best Practices

::illustration-checklist
---
title: Rebase vs Merge Guidelines
items:
  - text: Rebase local commits before pushing
    icon: "\U00002705"
  - text: Never rebase shared branches
    icon: "\U0001F6AB"
  - text: Use merge for pull requests
    icon: "\U0001F500"
  - text: Squash messy commits before PR
    icon: "\U0001F9F9"
  - text: Use --force-with-lease not --force
    icon: "\U0001F6E1\uFE0F"
note: When in doubt, merge is safer
color: amber
size: 2xl
---
::

## Key Takeaways

- Merge preserves history and creates merge commits
- Rebase replays commits and creates linear history
- Rebase changes commit hashes - never rebase shared branches
- Interactive rebase lets you squash, edit, and reorder commits
- Use merge for shared branches, rebase for local cleanup
- When in doubt, merge is the safer option

In the next lesson, you will learn about cherry-picking specific commits from one branch to another.
