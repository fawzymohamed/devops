---
title: "Git Basics"
description: "Learn the fundamental Git commands: init, clone, add, and commit to start tracking your code changes."
estimatedMinutes: 12
difficulty: beginner
learningObjectives:
  - "Understand what Git is and why version control matters"
  - "Initialize a new Git repository with git init"
  - "Clone existing repositories from remote sources"
  - "Stage changes with git add and create commits"
quiz:
  passingScore: 70
  questions:
    - question: "What command creates a new Git repository in the current directory?"
      type: single
      options:
        - "git new"
        - "git init"
        - "git create"
        - "git start"
      correctAnswer: "git init"
      explanation: "git init initializes a new Git repository in the current directory. It creates the hidden .git folder that stores all version control information."

    - question: "What is the correct order of steps to save changes in Git?"
      type: single
      options:
        - "commit, then add"
        - "add, then commit"
        - "push, then commit"
        - "commit, then push"
      correctAnswer: "add, then commit"
      explanation: "You first stage changes with 'git add' to select what goes into the next commit. Then you run 'git commit' to save those staged changes permanently."

    - question: "Select all commands that download a repository from a remote server."
      type: multiple
      options:
        - "git clone"
        - "git pull"
        - "git init"
        - "git fetch"
      correctAnswers:
        - "git clone"
        - "git pull"
        - "git fetch"
      explanation: "git clone downloads a complete repository. git pull and git fetch also download from remotes - pull fetches and merges, fetch only downloads. git init creates a new local repository, it does not download anything."

    - question: "The .git folder contains all the version history of your repository."
      type: true-false
      correctAnswer: true
      explanation: "True. The hidden .git folder stores all commits, branches, configuration, and history. If you delete this folder, you lose all version control information."

    - question: "What does git status show you?"
      type: single
      options:
        - "The commit history"
        - "The current state of your working directory and staging area"
        - "The list of remote repositories"
        - "The differences between files"
      correctAnswer: "The current state of your working directory and staging area"
      explanation: "git status shows which files are modified, staged, or untracked. It tells you the current branch and whether you have commits to push."
---

# Git Basics

Git is the most widely used version control system in the world. It tracks changes to your files over time. This means you can go back to any previous version, work with others without overwriting each other's work, and understand what changed and why.

## Why Git Matters in DevOps

Every DevOps workflow starts with code. Git is the foundation for:

- **Collaboration**: Multiple developers work on the same project
- **CI/CD Pipelines**: Automated builds trigger when code changes
- **Infrastructure as Code**: Track changes to your infrastructure
- **Audit Trail**: Know who changed what and when

## What is Version Control?

Version control is like a time machine for your code. Without it, you might save files as `project_v1.py`, `project_v2.py`, `project_final.py`, `project_final_FINAL.py`. This gets messy fast.

Git solves this by storing snapshots of your project. Each snapshot is called a **commit**. You can jump between commits, compare them, or restore old versions.

::illustration-linear-flow
---
steps:
  - label: Edit Files
    sublabel: Make changes
    icon: "\U0001F4DD"
    color: blue
  - label: Stage
    sublabel: git add
    icon: "\U0001F4E6"
    color: violet
  - label: Commit
    sublabel: git commit
    icon: "\U00002705"
    color: emerald
  - label: Push
    sublabel: git push
    icon: "\U0001F680"
    color: amber
direction: horizontal
size: full
---
::

## Installing Git

Git comes pre-installed on most Linux systems. To check:

```bash
git --version
# git version 2.34.1
```

If not installed:

```bash
# Ubuntu/Debian
sudo apt install git

# RHEL/CentOS
sudo dnf install git
```

## Configuring Git

Before your first commit, tell Git who you are:

```bash
# Set your name
git config --global user.name "Your Name"

# Set your email
git config --global user.email "your.email@example.com"

# Check your configuration
git config --list
```

The `--global` flag applies these settings to all repositories on your machine.

## Initializing a Repository

To start tracking a project with Git:

```bash
# Go to your project folder
cd my-project

# Initialize Git
git init
```

This creates a hidden `.git` folder. This folder contains all version history. Do not delete it unless you want to remove all Git tracking.

```bash
# See the .git folder
ls -la
# drwxr-xr-x  .git/
```

## Cloning a Repository

To get a copy of an existing repository:

```bash
# Clone from GitHub
git clone https://github.com/username/repository.git

# Clone with SSH (if you have SSH keys set up)
git clone git@github.com:username/repository.git

# Clone into a specific folder
git clone https://github.com/username/repository.git my-folder
```

Cloning downloads the entire project and all its history.

## Checking Status

The `git status` command shows what is happening in your repository:

```bash
git status
```

Example output:

```
On branch main
Changes not staged for commit:
  modified:   app.py

Untracked files:
  config.yml
```

This tells you:
- You are on the `main` branch
- `app.py` was modified but not staged
- `config.yml` is new and not tracked yet

## Staging Changes with git add

Before you can commit, you must **stage** your changes. Staging lets you choose which changes to include in your next commit.

```bash
# Stage a specific file
git add app.py

# Stage multiple files
git add app.py config.yml

# Stage all changes in current directory
git add .

# Stage all changes everywhere
git add -A
```

After staging, check status again:

```bash
git status
# Changes to be committed:
#   new file:   config.yml
#   modified:   app.py
```

## Creating Commits

A commit saves your staged changes with a message describing what you did:

```bash
git commit -m "Add database configuration"
```

Write clear commit messages. Good messages explain **why** you made the change, not just what changed.

```bash
# Good commit messages
git commit -m "Fix login timeout by increasing session duration"
git commit -m "Add user profile page with avatar upload"

# Bad commit messages
git commit -m "Fixed stuff"
git commit -m "Updates"
```

## Viewing History

See your commit history:

```bash
# Full history
git log

# One line per commit
git log --oneline

# Show last 5 commits
git log -5
```

Example output:

```
a1b2c3d (HEAD -> main) Add database configuration
e4f5g6h Fix login validation
i7j8k9l Initial commit
```

## Practical Example

Let us create a project from scratch:

```bash
# Create and enter project folder
mkdir my-app && cd my-app

# Initialize Git
git init

# Create a file
echo "# My App" > README.md

# Check status
git status

# Stage the file
git add README.md

# Commit
git commit -m "Initial commit with README"

# Check history
git log --oneline
```

## Common Mistakes to Avoid

1. **Committing without staging**: Run `git add` before `git commit`
2. **Vague commit messages**: Write clear descriptions of your changes
3. **Committing secrets**: Never commit passwords, API keys, or private keys
4. **Large binary files**: Git works best with text files

## Key Takeaways

- Git tracks changes to your files over time using commits
- `git init` creates a new repository, `git clone` downloads an existing one
- Stage changes with `git add`, then save them with `git commit`
- `git status` shows what is modified, staged, or untracked
- Write clear commit messages that explain why you made changes

In the next lesson, you will learn about branching and merging to work on features without affecting the main codebase.
